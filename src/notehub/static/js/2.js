/**
 * @license
 For license information please see 2.1afbd823.chunk.js.LICENSE.txt */
'use strict';
(this.webpackJsonpweread_helper_notehub = this.webpackJsonpweread_helper_notehub || []).push([[2], [function(module, canCreateDiscussions, factory) {
  module.exports = factory(111);
}, function(mixin, canCreateDiscussions) {
  if ("function" === typeof Object.create) {
    /**
     * @param {!Object} obj
     * @param {!Object} source
     * @return {undefined}
     */
    mixin.exports = function(obj, source) {
      if (source) {
        /** @type {!Object} */
        obj.super_ = source;
        /** @type {!Object} */
        obj.prototype = Object.create(source.prototype, {
          constructor : {
            value : obj,
            enumerable : false,
            writable : true,
            configurable : true
          }
        });
      }
    };
  } else {
    /**
     * @param {!Object} obj
     * @param {!Object} parent
     * @return {undefined}
     */
    mixin.exports = function(obj, parent) {
      if (parent) {
        /** @type {!Object} */
        obj.super_ = parent;
        /**
         * @return {undefined}
         */
        var Surrogate = function() {
        };
        Surrogate.prototype = parent.prototype;
        obj.prototype = new Surrogate;
        /** @type {!Object} */
        obj.prototype.constructor = obj;
      }
    };
  }
}, function(module, context, factory) {
  /**
   * @param {!Object} a
   * @param {!Function} obj
   * @return {undefined}
   */
  function extend(a, obj) {
    var prop;
    for (prop in a) {
      obj[prop] = a[prop];
    }
  }
  /**
   * @param {?} data
   * @param {!Array} callback
   * @param {!Object} name
   * @return {?}
   */
  function Buffer(data, callback, name) {
    return fn(data, callback, name);
  }
  var exports = factory(3);
  var fn = exports.Buffer;
  if (fn.from && fn.alloc && fn.allocUnsafe && fn.allocUnsafeSlow) {
    module.exports = exports;
  } else {
    extend(exports, context);
    /** @type {function(?, !Array, !Object): ?} */
    context.Buffer = Buffer;
  }
  /** @type {!Object} */
  Buffer.prototype = Object.create(fn.prototype);
  extend(fn, Buffer);
  /**
   * @param {?} data
   * @param {?} str
   * @param {!Object} callback
   * @return {?}
   */
  Buffer.from = function(data, str, callback) {
    if ("number" === typeof data) {
      throw new TypeError("Argument must not be a number");
    }
    return fn(data, str, callback);
  };
  /**
   * @param {?} num
   * @param {number} value
   * @param {undefined} length
   * @return {?}
   */
  Buffer.alloc = function(num, value, length) {
    if ("number" !== typeof num) {
      throw new TypeError("Argument must be a number");
    }
    var text = fn(num);
    return void 0 !== value ? "string" === typeof length ? text.fill(value, length) : text.fill(value) : text.fill(0), text;
  };
  /**
   * @param {?} a
   * @return {?}
   */
  Buffer.allocUnsafe = function(a) {
    if ("number" !== typeof a) {
      throw new TypeError("Argument must be a number");
    }
    return fn(a);
  };
  /**
   * @param {?} a
   * @return {?}
   */
  Buffer.allocUnsafeSlow = function(a) {
    if ("number" !== typeof a) {
      throw new TypeError("Argument must be a number");
    }
    return exports.SlowBuffer(a);
  };
}, function(canCreateDiscussions, exports, $) {
  (function(global) {
    /**
     * @return {?}
     */
    function kMaxLength() {
      return Buffer.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
    }
    /**
     * @param {!Object} that
     * @param {number} length
     * @return {?}
     */
    function createBuffer(that, length) {
      if (kMaxLength() < length) {
        throw new RangeError("Invalid typed array length");
      }
      return Buffer.TYPED_ARRAY_SUPPORT ? (that = new Uint8Array(length)).__proto__ = Buffer.prototype : (null === that && (that = new Buffer(length)), that.length = length), that;
    }
    /**
     * @param {?} arg
     * @param {!Object} type
     * @param {!Object} length
     * @return {?}
     */
    function Buffer(arg, type, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, type, length);
      }
      if ("number" === typeof arg) {
        if ("string" === typeof type) {
          throw new Error("If encoding is specified then the first argument must be a string");
        }
        return allocUnsafe(this, arg);
      }
      return parse(this, arg, type, length);
    }
    /**
     * @param {string} a
     * @param {(Object|string)} val
     * @param {boolean} n
     * @param {boolean} word
     * @return {?}
     */
    function parse(a, val, n, word) {
      if ("number" === typeof val) {
        throw new TypeError('"value" argument must not be a number');
      }
      return "undefined" !== typeof ArrayBuffer && val instanceof ArrayBuffer ? function(that, array, byteOffset, length) {
        if (array.byteLength, byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError("'offset' is out of bounds");
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError("'length' is out of bounds");
        }
        /** @type {!Uint8Array} */
        array = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length);
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          (that = array).__proto__ = Buffer.prototype;
        } else {
          that = fromArrayLike(that, array);
        }
        return that;
      }(a, val, n, word) : "string" === typeof val ? function(that, data, key) {
        if (!("string" === typeof key && "" !== key)) {
          /** @type {string} */
          key = "utf8";
        }
        if (!Buffer.isEncoding(key)) {
          throw new TypeError('"encoding" must be a valid string encoding');
        }
        /** @type {number} */
        var length = 0 | byteLength(data, key);
        var actual = (that = createBuffer(that, length)).write(data, key);
        if (actual !== length) {
          that = that.slice(0, actual);
        }
        return that;
      }(a, val, n) : function(that, obj) {
        if (Buffer.isBuffer(obj)) {
          /** @type {number} */
          var len = 0 | checked(obj.length);
          return 0 === (that = createBuffer(that, len)).length || obj.copy(that, 0, 0, len), that;
        }
        if (obj) {
          if ("undefined" !== typeof ArrayBuffer && obj.buffer instanceof ArrayBuffer || "length" in obj) {
            return "number" !== typeof obj.length || (i = obj.length) !== i ? createBuffer(that, 0) : fromArrayLike(that, obj);
          }
          if ("Buffer" === obj.type && copy(obj.data)) {
            return fromArrayLike(that, obj.data);
          }
        }
        var i;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
      }(a, val);
    }
    /**
     * @param {number} size
     * @return {undefined}
     */
    function assertSize(size) {
      if ("number" !== typeof size) {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
    }
    /**
     * @param {!Object} that
     * @param {number} size
     * @return {?}
     */
    function allocUnsafe(that, size) {
      if (assertSize(size), that = createBuffer(that, size < 0 ? 0 : 0 | checked(size)), !Buffer.TYPED_ARRAY_SUPPORT) {
        /** @type {number} */
        var i = 0;
        for (; i < size; ++i) {
          /** @type {number} */
          that[i] = 0;
        }
      }
      return that;
    }
    /**
     * @param {!Object} that
     * @param {?} obj
     * @return {?}
     */
    function fromArrayLike(that, obj) {
      /** @type {number} */
      var length = obj.length < 0 ? 0 : 0 | checked(obj.length);
      that = createBuffer(that, length);
      /** @type {number} */
      var i = 0;
      for (; i < length; i = i + 1) {
        /** @type {number} */
        that[i] = 255 & obj[i];
      }
      return that;
    }
    /**
     * @param {number} length
     * @return {?}
     */
    function checked(length) {
      if (length >= kMaxLength()) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
      }
      return 0 | length;
    }
    /**
     * @param {!Object} value
     * @param {string} encoding
     * @return {?}
     */
    function byteLength(value, encoding) {
      if (Buffer.isBuffer(value)) {
        return value.length;
      }
      if ("undefined" !== typeof ArrayBuffer && "function" === typeof ArrayBuffer.isView && (ArrayBuffer.isView(value) || value instanceof ArrayBuffer)) {
        return value.byteLength;
      }
      if ("string" !== typeof value) {
        /** @type {string} */
        value = "" + value;
      }
      var len = value.length;
      if (0 === len) {
        return 0;
      }
      /** @type {boolean} */
      var n = false;
      for (;;) {
        switch(encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
          case void 0:
            return utf8ToBytes(value).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * len;
          case "hex":
            return len >>> 1;
          case "base64":
            return replace(value).length;
          default:
            if (n) {
              return utf8ToBytes(value).length;
            }
            /** @type {string} */
            encoding = ("" + encoding).toLowerCase();
            /** @type {boolean} */
            n = true;
        }
      }
    }
    /**
     * @param {string} encoding
     * @param {number} value
     * @param {number} length
     * @return {?}
     */
    function write(encoding, value, length) {
      /** @type {boolean} */
      var n = false;
      if ((void 0 === value || value < 0) && (value = 0), value > this.length) {
        return "";
      }
      if ((void 0 === length || length > this.length) && (length = this.length), length <= 0) {
        return "";
      }
      if ((length = length >>> 0) <= (value = value >>> 0)) {
        return "";
      }
      if (!encoding) {
        /** @type {string} */
        encoding = "utf8";
      }
      for (;;) {
        switch(encoding) {
          case "hex":
            return map(this, value, length);
          case "utf8":
          case "utf-8":
            return update(this, value, length);
          case "ascii":
            return push(this, value, length);
          case "latin1":
          case "binary":
            return read(this, value, length);
          case "base64":
            return cb(this, value, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return callback(this, value, length);
          default:
            if (n) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            /** @type {string} */
            encoding = (encoding + "").toLowerCase();
            /** @type {boolean} */
            n = true;
        }
      }
    }
    /**
     * @param {!NodeList} o
     * @param {number} i
     * @param {number} name
     * @return {undefined}
     */
    function swap(o, i, name) {
      var type = o[i];
      o[i] = o[name];
      o[name] = type;
    }
    /**
     * @param {number} buffer
     * @param {number} val
     * @param {number} byteOffset
     * @param {number} encoding
     * @param {boolean} dir
     * @return {?}
     */
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (0 === buffer.length) {
        return -1;
      }
      if ("string" === typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 2147483647 ? byteOffset = 2147483647 : byteOffset < -2147483648 && (byteOffset = -2147483648), byteOffset = +byteOffset, isNaN(byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
        if (dir) {
          return -1;
        }
        /** @type {number} */
        byteOffset = buffer.length - 1;
      } else {
        if (byteOffset < 0) {
          if (!dir) {
            return -1;
          }
          /** @type {number} */
          byteOffset = 0;
        }
      }
      if ("string" === typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val)) {
        return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      }
      if ("number" === typeof val) {
        return val = val & 255, Buffer.TYPED_ARRAY_SUPPORT && "function" === typeof Uint8Array.prototype.indexOf ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    /**
     * @param {number} arr
     * @param {number} val
     * @param {number} e
     * @param {?} key
     * @param {boolean} item
     * @return {?}
     */
    function arrayIndexOf(arr, val, e, key, item) {
      /**
       * @param {number} buf
       * @param {number} i
       * @return {?}
       */
      function read(buf, i) {
        return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
      }
      var i;
      /** @type {number} */
      var indexSize = 1;
      var m = arr.length;
      var c = val.length;
      if (void 0 !== key && ("ucs2" === (key = String(key).toLowerCase()) || "ucs-2" === key || "utf16le" === key || "utf-16le" === key)) {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        /** @type {number} */
        indexSize = 2;
        /** @type {number} */
        m = m / 2;
        /** @type {number} */
        c = c / 2;
        /** @type {number} */
        e = e / 2;
      }
      if (item) {
        /** @type {number} */
        var foundIndex = -1;
        /** @type {number} */
        i = e;
        for (; i < m; i++) {
          if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
            if (-1 === foundIndex && (foundIndex = i), i - foundIndex + 1 === c) {
              return foundIndex * indexSize;
            }
          } else {
            if (-1 !== foundIndex) {
              /** @type {number} */
              i = i - (i - foundIndex);
            }
            /** @type {number} */
            foundIndex = -1;
          }
        }
      } else {
        if (e + c > m) {
          /** @type {number} */
          e = m - c;
        }
        /** @type {number} */
        i = e;
        for (; i >= 0; i--) {
          /** @type {boolean} */
          var l = true;
          /** @type {number} */
          var j = 0;
          for (; j < c; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              /** @type {boolean} */
              l = false;
              break;
            }
          }
          if (l) {
            return i;
          }
        }
      }
      return -1;
    }
    /**
     * @param {!Object} data
     * @param {!Object} input
     * @param {number} offset
     * @param {number} n
     * @return {?}
     */
    function add(data, input, offset, n) {
      /** @type {number} */
      offset = Number(offset) || 0;
      /** @type {number} */
      var size = data.length - offset;
      if (n) {
        if ((n = Number(n)) > size) {
          /** @type {number} */
          n = size;
        }
      } else {
        /** @type {number} */
        n = size;
      }
      var l = input.length;
      if (l % 2 !== 0) {
        throw new TypeError("Invalid hex string");
      }
      if (n > l / 2) {
        /** @type {number} */
        n = l / 2;
      }
      /** @type {number} */
      var i = 0;
      for (; i < n; ++i) {
        /** @type {number} */
        var bottom1 = parseInt(input.substr(2 * i, 2), 16);
        if (isNaN(bottom1)) {
          return i;
        }
        /** @type {number} */
        data[offset + i] = bottom1;
      }
      return i;
    }
    /**
     * @param {!NodeList} buf
     * @param {boolean} string
     * @param {number} offset
     * @param {number} length
     * @return {?}
     */
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    /**
     * @param {!NodeList} buf
     * @param {!Function} string
     * @param {number} offset
     * @param {number} length
     * @return {?}
     */
    function append(buf, string, offset, length) {
      return blitBuffer(function(remaining) {
        /** @type {!Array} */
        var results = [];
        /** @type {number} */
        var i = 0;
        for (; i < remaining.length; ++i) {
          results.push(255 & remaining.charCodeAt(i));
        }
        return results;
      }(string), buf, offset, length);
    }
    /**
     * @param {(Node|NodeList|string)} arr
     * @param {!Object} string
     * @param {number} start
     * @param {number} end
     * @return {?}
     */
    function format(arr, string, start, end) {
      return append(arr, string, start, end);
    }
    /**
     * @param {!NodeList} buf
     * @param {!Object} string
     * @param {number} offset
     * @param {number} length
     * @return {?}
     */
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(replace(string), buf, offset, length);
    }
    /**
     * @param {!NodeList} buf
     * @param {boolean} string
     * @param {number} offset
     * @param {number} length
     * @return {?}
     */
    function check(buf, string, offset, length) {
      return blitBuffer(function(name, linksCount) {
        var i;
        var index;
        var slice;
        /** @type {!Array} */
        var obj = [];
        /** @type {number} */
        var k = 0;
        for (; k < name.length && !((linksCount = linksCount - 2) < 0); ++k) {
          i = name.charCodeAt(k);
          /** @type {number} */
          index = i >> 8;
          /** @type {number} */
          slice = i % 256;
          obj.push(slice);
          obj.push(index);
        }
        return obj;
      }(string, buf.length - offset), buf, offset, length);
    }
    /**
     * @param {string} buf
     * @param {number} start
     * @param {number} end
     * @return {?}
     */
    function cb(buf, start, end) {
      return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
    }
    /**
     * @param {!Array} link
     * @param {number} value
     * @param {number} length
     * @return {?}
     */
    function update(link, value, length) {
      /** @type {number} */
      length = Math.min(link.length, length);
      /** @type {!Array} */
      var n = [];
      /** @type {number} */
      var i = value;
      for (; i < length;) {
        var inside;
        var subFeedId;
        var selfId;
        var no;
        var href = link[i];
        /** @type {null} */
        var p = null;
        /** @type {number} */
        var limit = href > 239 ? 4 : href > 223 ? 3 : href > 191 ? 2 : 1;
        if (i + limit <= length) {
          switch(limit) {
            case 1:
              if (href < 128) {
                p = href;
              }
              break;
            case 2:
              if (128 === (192 & (inside = link[i + 1])) && (no = (31 & href) << 6 | 63 & inside) > 127) {
                /** @type {number} */
                p = no;
              }
              break;
            case 3:
              inside = link[i + 1];
              subFeedId = link[i + 2];
              if (128 === (192 & inside) && 128 === (192 & subFeedId) && (no = (15 & href) << 12 | (63 & inside) << 6 | 63 & subFeedId) > 2047 && (no < 55296 || no > 57343)) {
                /** @type {number} */
                p = no;
              }
              break;
            case 4:
              inside = link[i + 1];
              subFeedId = link[i + 2];
              selfId = link[i + 3];
              if (128 === (192 & inside) && 128 === (192 & subFeedId) && 128 === (192 & selfId) && (no = (15 & href) << 18 | (63 & inside) << 12 | (63 & subFeedId) << 6 | 63 & selfId) > 65535 && no < 1114112) {
                /** @type {number} */
                p = no;
              }
          }
        }
        if (null === p) {
          /** @type {number} */
          p = 65533;
          /** @type {number} */
          limit = 1;
        } else {
          if (p > 65535) {
            /** @type {number} */
            p = p - 65536;
            n.push(p >>> 10 & 1023 | 55296);
            /** @type {number} */
            p = 56320 | 1023 & p;
          }
        }
        n.push(p);
        i = i + limit;
      }
      return function(data) {
        /** @type {number} */
        var bc = data.length;
        if (bc <= 4096) {
          return String.fromCharCode.apply(String, data);
        }
        /** @type {string} */
        var res = "";
        /** @type {number} */
        var c = 0;
        for (; c < bc;) {
          /** @type {string} */
          res = res + String.fromCharCode.apply(String, data.slice(c, c = c + 4096));
        }
        return res;
      }(n);
    }
    /**
     * @param {!Array} offset
     * @param {number} value
     * @param {number} count
     * @return {?}
     */
    function push(offset, value, count) {
      /** @type {string} */
      var logData = "";
      /** @type {number} */
      count = Math.min(offset.length, count);
      /** @type {number} */
      var x = value;
      for (; x < count; ++x) {
        /** @type {string} */
        logData = logData + String.fromCharCode(127 & offset[x]);
      }
      return logData;
    }
    /**
     * @param {!Array} buffer
     * @param {number} position
     * @param {number} length
     * @return {?}
     */
    function read(buffer, position, length) {
      /** @type {string} */
      var resp = "";
      /** @type {number} */
      length = Math.min(buffer.length, length);
      /** @type {number} */
      var i = position;
      for (; i < length; ++i) {
        /** @type {string} */
        resp = resp + String.fromCharCode(buffer[i]);
      }
      return resp;
    }
    /**
     * @param {!Array} current
     * @param {number} index
     * @param {number} length
     * @return {?}
     */
    function map(current, index, length) {
      var j = current.length;
      if (!index || index < 0) {
        /** @type {number} */
        index = 0;
      }
      if (!length || length < 0 || length > j) {
        length = j;
      }
      /** @type {string} */
      var loader = "";
      /** @type {number} */
      var i = index;
      for (; i < length; ++i) {
        /** @type {string} */
        loader = loader + forEach(current[i]);
      }
      return loader;
    }
    /**
     * @param {string} file
     * @param {number} line
     * @param {number} pos
     * @return {?}
     */
    function callback(file, line, pos) {
      var results = file.slice(line, pos);
      /** @type {string} */
      var resp = "";
      /** @type {number} */
      var i = 0;
      for (; i < results.length; i = i + 2) {
        /** @type {string} */
        resp = resp + String.fromCharCode(results[i] + 256 * results[i + 1]);
      }
      return resp;
    }
    /**
     * @param {number} offset
     * @param {number} ext
     * @param {?} length
     * @return {undefined}
     */
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) {
        throw new RangeError("offset is not uint");
      }
      if (offset + ext > length) {
        throw new RangeError("Trying to access beyond buffer length");
      }
    }
    /**
     * @param {!Array} buffer
     * @param {number} value
     * @param {number} offset
     * @param {number} ext
     * @param {number} max
     * @param {number} min
     * @return {undefined}
     */
    function checkInt(buffer, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buffer)) {
        throw new TypeError('"buffer" argument must be a Buffer instance');
      }
      if (value > max || value < min) {
        throw new RangeError('"value" argument is out of bounds');
      }
      if (offset + ext > buffer.length) {
        throw new RangeError("Index out of range");
      }
    }
    /**
     * @param {!NodeList} buf
     * @param {number} value
     * @param {number} offset
     * @param {boolean} littleEndian
     * @return {undefined}
     */
    function objectWriteUInt16(buf, value, offset, littleEndian) {
      if (value < 0) {
        value = 65535 + value + 1;
      }
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var cell_amount = Math.min(buf.length - offset, 2);
      for (; i < cell_amount; ++i) {
        /** @type {number} */
        buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> 8 * (littleEndian ? i : 1 - i);
      }
    }
    /**
     * @param {!NodeList} buf
     * @param {number} value
     * @param {number} offset
     * @param {boolean} littleEndian
     * @return {undefined}
     */
    function objectWriteUInt32(buf, value, offset, littleEndian) {
      if (value < 0) {
        value = 4294967295 + value + 1;
      }
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var cell_amount = Math.min(buf.length - offset, 4);
      for (; i < cell_amount; ++i) {
        /** @type {number} */
        buf[offset + i] = value >>> 8 * (littleEndian ? i : 3 - i) & 255;
      }
    }
    /**
     * @param {number} data
     * @param {number} expression
     * @param {number} n
     * @param {number} offset
     * @param {?} options
     * @param {?} noForm
     * @return {undefined}
     */
    function assert(data, expression, n, offset, options, noForm) {
      if (n + offset > data.length) {
        throw new RangeError("Index out of range");
      }
      if (n < 0) {
        throw new RangeError("Index out of range");
      }
    }
    /**
     * @param {undefined} buffer
     * @param {!Array} offset
     * @param {number} val
     * @param {boolean} littleEndian
     * @param {string} noAssert
     * @return {?}
     */
    function writeFloat(buffer, offset, val, littleEndian, noAssert) {
      return noAssert || assert(buffer, 0, val, 4), that.write(buffer, offset, val, littleEndian, 23, 4), val + 4;
    }
    /**
     * @param {undefined} buffer
     * @param {!Array} offset
     * @param {number} val
     * @param {boolean} littleEndian
     * @param {string} noAssert
     * @return {?}
     */
    function writeDouble(buffer, offset, val, littleEndian, noAssert) {
      return noAssert || assert(buffer, 0, val, 8), that.write(buffer, offset, val, littleEndian, 52, 8), val + 8;
    }
    /**
     * @param {number} it
     * @return {?}
     */
    function forEach(it) {
      return it < 16 ? "0" + it.toString(16) : it.toString(16);
    }
    /**
     * @param {string} string
     * @param {number} units
     * @return {?}
     */
    function utf8ToBytes(string, units) {
      var i;
      units = units || 1 / 0;
      var length = string.length;
      /** @type {null} */
      var m = null;
      /** @type {!Array} */
      var bytes = [];
      /** @type {number} */
      var index = 0;
      for (; index < length; ++index) {
        if ((i = string.charCodeAt(index)) > 55295 && i < 57344) {
          if (!m) {
            if (i > 56319) {
              if ((units = units - 3) > -1) {
                bytes.push(239, 191, 189);
              }
              continue;
            }
            if (index + 1 === length) {
              if ((units = units - 3) > -1) {
                bytes.push(239, 191, 189);
              }
              continue;
            }
            m = i;
            continue;
          }
          if (i < 56320) {
            if ((units = units - 3) > -1) {
              bytes.push(239, 191, 189);
            }
            m = i;
            continue;
          }
          /** @type {number} */
          i = 65536 + (m - 55296 << 10 | i - 56320);
        } else {
          if (m && (units = units - 3) > -1) {
            bytes.push(239, 191, 189);
          }
        }
        if (m = null, i < 128) {
          if ((units = units - 1) < 0) {
            break;
          }
          bytes.push(i);
        } else {
          if (i < 2048) {
            if ((units = units - 2) < 0) {
              break;
            }
            bytes.push(i >> 6 | 192, 63 & i | 128);
          } else {
            if (i < 65536) {
              if ((units = units - 3) < 0) {
                break;
              }
              bytes.push(i >> 12 | 224, i >> 6 & 63 | 128, 63 & i | 128);
            } else {
              if (!(i < 1114112)) {
                throw new Error("Invalid code point");
              }
              if ((units = units - 4) < 0) {
                break;
              }
              bytes.push(i >> 18 | 240, i >> 12 & 63 | 128, i >> 6 & 63 | 128, 63 & i | 128);
            }
          }
        }
      }
      return bytes;
    }
    /**
     * @param {!Function} str
     * @return {?}
     */
    function replace(str) {
      return base64.toByteArray(function(pattern) {
        if ((pattern = function(s) {
          return s.trim ? s.trim() : s.replace(/^\s+|\s+$/g, "");
        }(pattern).replace(replaceRegex, "")).length < 2) {
          return "";
        }
        for (; pattern.length % 4 !== 0;) {
          /** @type {string} */
          pattern = pattern + "=";
        }
        return pattern;
      }(str));
    }
    /**
     * @param {!NodeList} src
     * @param {(Array|NodeList)} dst
     * @param {number} offset
     * @param {number} length
     * @return {?}
     */
    function blitBuffer(src, dst, offset, length) {
      /** @type {number} */
      var i = 0;
      for (; i < length && !(i + offset >= dst.length || i >= src.length); ++i) {
        dst[i + offset] = src[i];
      }
      return i;
    }
    var base64 = $(118);
    var that = $(119);
    var copy = $(63);
    /** @type {function(?, !Object, !Object): ?} */
    exports.Buffer = Buffer;
    /**
     * @param {number} length
     * @return {?}
     */
    exports.SlowBuffer = function(length) {
      if (+length != length) {
        /** @type {number} */
        length = 0;
      }
      return Buffer.alloc(+length);
    };
    /** @type {number} */
    exports.INSPECT_MAX_BYTES = 50;
    Buffer.TYPED_ARRAY_SUPPORT = void 0 !== global.TYPED_ARRAY_SUPPORT ? global.TYPED_ARRAY_SUPPORT : function() {
      try {
        /** @type {!Uint8Array} */
        var arr = new Uint8Array(1);
        return arr.__proto__ = {
          __proto__ : Uint8Array.prototype,
          foo : function() {
            return 42;
          }
        }, 42 === arr.foo() && "function" === typeof arr.subarray && 0 === arr.subarray(1, 1).byteLength;
      } catch (t) {
        return false;
      }
    }();
    exports.kMaxLength = kMaxLength();
    /** @type {number} */
    Buffer.poolSize = 8192;
    /**
     * @param {!Object} arr
     * @return {?}
     */
    Buffer._augment = function(arr) {
      return arr.__proto__ = Buffer.prototype, arr;
    };
    /**
     * @param {?} arg
     * @param {?} type
     * @param {boolean} val
     * @return {?}
     */
    Buffer.from = function(arg, type, val) {
      return parse(null, arg, type, val);
    };
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype;
      /** @type {function(new:Uint8Array, (Array<number>|ArrayBuffer|ArrayBufferView|SharedArrayBuffer|null|number), number=, number=): ?} */
      Buffer.__proto__ = Uint8Array;
      if ("undefined" !== typeof Symbol && Symbol.species && Buffer[Symbol.species] === Buffer) {
        Object.defineProperty(Buffer, Symbol.species, {
          value : null,
          configurable : true
        });
      }
    }
    /**
     * @param {?} num
     * @param {?} type
     * @param {undefined} value
     * @return {?}
     */
    Buffer.alloc = function(num, type, value) {
      return function(length, size, val, value) {
        return assertSize(size), size <= 0 ? createBuffer(length, size) : void 0 !== val ? "string" === typeof value ? createBuffer(length, size).fill(val, value) : createBuffer(length, size).fill(val) : createBuffer(length, size);
      }(null, num, type, value);
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    Buffer.allocUnsafe = function(arg) {
      return allocUnsafe(null, arg);
    };
    /**
     * @param {?} arg
     * @return {?}
     */
    Buffer.allocUnsafeSlow = function(arg) {
      return allocUnsafe(null, arg);
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    Buffer.isBuffer = function(obj) {
      return !(null == obj || !obj._isBuffer);
    };
    /**
     * @param {!Array} obj
     * @param {!Array} value
     * @return {?}
     */
    Buffer.compare = function(obj, value) {
      if (!Buffer.isBuffer(obj) || !Buffer.isBuffer(value)) {
        throw new TypeError("Arguments must be Buffers");
      }
      if (obj === value) {
        return 0;
      }
      var x = obj.length;
      var y = value.length;
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var key = Math.min(x, y);
      for (; i < key; ++i) {
        if (obj[i] !== value[i]) {
          x = obj[i];
          y = value[i];
          break;
        }
      }
      return x < y ? -1 : y < x ? 1 : 0;
    };
    /**
     * @param {!Object} encoding
     * @return {?}
     */
    Buffer.isEncoding = function(encoding) {
      switch(String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    /**
     * @param {!Object} a
     * @param {number} size
     * @return {?}
     */
    Buffer.concat = function(a, size) {
      if (!copy(a)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (0 === a.length) {
        return Buffer.alloc(0);
      }
      var k;
      if (void 0 === size) {
        /** @type {number} */
        size = 0;
        /** @type {number} */
        k = 0;
        for (; k < a.length; ++k) {
          size = size + a[k].length;
        }
      }
      var x = Buffer.allocUnsafe(size);
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      k = 0;
      for (; k < a.length; ++k) {
        var e = a[k];
        if (!Buffer.isBuffer(e)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        e.copy(x, i);
        i = i + e.length;
      }
      return x;
    };
    /** @type {function(!Object, string): ?} */
    Buffer.byteLength = byteLength;
    /** @type {boolean} */
    Buffer.prototype._isBuffer = true;
    /**
     * @return {?}
     */
    Buffer.prototype.swap16 = function() {
      var l = this.length;
      if (l % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      /** @type {number} */
      var i = 0;
      for (; i < l; i = i + 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    /**
     * @return {?}
     */
    Buffer.prototype.swap32 = function() {
      var l = this.length;
      if (l % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      /** @type {number} */
      var i = 0;
      for (; i < l; i = i + 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    /**
     * @return {?}
     */
    Buffer.prototype.swap64 = function() {
      var l = this.length;
      if (l % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      /** @type {number} */
      var i = 0;
      for (; i < l; i = i + 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    /**
     * @return {?}
     */
    Buffer.prototype.toString = function() {
      /** @type {number} */
      var b = 0 | this.length;
      return 0 === b ? "" : 0 === arguments.length ? update(this, 0, b) : write.apply(this, arguments);
    };
    /**
     * @param {undefined} b
     * @return {?}
     */
    Buffer.prototype.equals = function(b) {
      if (!Buffer.isBuffer(b)) {
        throw new TypeError("Argument must be a Buffer");
      }
      return this === b || 0 === Buffer.compare(this, b);
    };
    /**
     * @return {?}
     */
    Buffer.prototype.inspect = function() {
      /** @type {string} */
      var pix_color = "";
      var max = exports.INSPECT_MAX_BYTES;
      return this.length > 0 && (pix_color = this.toString("hex", 0, max).match(/.{2}/g).join(" "), this.length > max && (pix_color = pix_color + " ... ")), "<Buffer " + pix_color + ">";
    };
    /**
     * @param {string} e
     * @param {number} r
     * @param {number} b
     * @param {number} start
     * @param {number} end
     * @return {?}
     */
    Buffer.prototype.compare = function(e, r, b, start, end) {
      if (!Buffer.isBuffer(e)) {
        throw new TypeError("Argument must be a Buffer");
      }
      if (void 0 === r && (r = 0), void 0 === b && (b = e ? e.length : 0), void 0 === start && (start = 0), void 0 === end && (end = this.length), r < 0 || b > e.length || start < 0 || end > this.length) {
        throw new RangeError("out of range index");
      }
      if (start >= end && r >= b) {
        return 0;
      }
      if (start >= end) {
        return -1;
      }
      if (r >= b) {
        return 1;
      }
      if (this === e) {
        return 0;
      }
      /** @type {number} */
      var from = (end = end >>> 0) - (start = start >>> 0);
      /** @type {number} */
      var value = (b = b >>> 0) - (r = r >>> 0);
      /** @type {number} */
      var s = Math.min(from, value);
      var parts = this.slice(start, end);
      var args = e.slice(r, b);
      /** @type {number} */
      var i = 0;
      for (; i < s; ++i) {
        if (parts[i] !== args[i]) {
          from = parts[i];
          value = args[i];
          break;
        }
      }
      return from < value ? -1 : value < from ? 1 : 0;
    };
    /**
     * @param {string} val
     * @param {undefined} byteOffset
     * @param {undefined} encoding
     * @return {?}
     */
    Buffer.prototype.includes = function(val, byteOffset, encoding) {
      return -1 !== this.indexOf(val, byteOffset, encoding);
    };
    /**
     * @param {string} val
     * @param {number} byteOffset
     * @param {number} encoding
     * @return {?}
     */
    Buffer.prototype.indexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    /**
     * @param {?} val
     * @param {number} byteOffset
     * @param {undefined} encoding
     * @return {?}
     */
    Buffer.prototype.lastIndexOf = function(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    /**
     * @param {!Object} string
     * @param {number} start
     * @param {number} end
     * @param {number} encoding
     * @return {?}
     */
    Buffer.prototype.write = function(string, start, end, encoding) {
      if (void 0 === start) {
        /** @type {string} */
        encoding = "utf8";
        end = this.length;
        /** @type {number} */
        start = 0;
      } else {
        if (void 0 === end && "string" === typeof start) {
          /** @type {number} */
          encoding = start;
          end = this.length;
          /** @type {number} */
          start = 0;
        } else {
          if (!isFinite(start)) {
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
          }
          /** @type {number} */
          start = start | 0;
          if (isFinite(end)) {
            /** @type {number} */
            end = end | 0;
            if (void 0 === encoding) {
              /** @type {string} */
              encoding = "utf8";
            }
          } else {
            /** @type {number} */
            encoding = end;
            end = void 0;
          }
        }
      }
      /** @type {number} */
      var len = this.length - start;
      if ((void 0 === end || end > len) && (end = len), string.length > 0 && (end < 0 || start < 0) || start > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) {
        /** @type {string} */
        encoding = "utf8";
      }
      /** @type {boolean} */
      var o = false;
      for (;;) {
        switch(encoding) {
          case "hex":
            return add(this, string, start, end);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, start, end);
          case "ascii":
            return append(this, string, start, end);
          case "latin1":
          case "binary":
            return format(this, string, start, end);
          case "base64":
            return ucs2Write(this, string, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return check(this, string, start, end);
          default:
            if (o) {
              throw new TypeError("Unknown encoding: " + encoding);
            }
            /** @type {string} */
            encoding = ("" + encoding).toLowerCase();
            /** @type {boolean} */
            o = true;
        }
      }
    };
    /**
     * @return {?}
     */
    Buffer.prototype.toJSON = function() {
      return {
        type : "Buffer",
        data : Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    /**
     * @param {number} start
     * @param {number} end
     * @return {?}
     */
    Buffer.prototype.slice = function(start, end) {
      var newBuf;
      var len = this.length;
      if ((start = ~~start) < 0 ? (start = start + len) < 0 && (start = 0) : start > len && (start = len), (end = void 0 === end ? len : ~~end) < 0 ? (end = end + len) < 0 && (end = 0) : end > len && (end = len), end < start && (end = start), Buffer.TYPED_ARRAY_SUPPORT) {
        (newBuf = this.subarray(start, end)).__proto__ = Buffer.prototype;
      } else {
        /** @type {number} */
        var sliceLen = end - start;
        newBuf = new Buffer(sliceLen, void 0);
        /** @type {number} */
        var i = 0;
        for (; i < sliceLen; ++i) {
          newBuf[i] = this[i + start];
        }
      }
      return newBuf;
    };
    /**
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readUIntLE = function(offset, byteLength, noAssert) {
      /** @type {number} */
      offset = offset | 0;
      /** @type {number} */
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      var val = this[offset];
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      var i = 0;
      for (; ++i < byteLength && (mul = mul * 256);) {
        val = val + this[offset + i] * mul;
      }
      return val;
    };
    /**
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readUIntBE = function(offset, byteLength, noAssert) {
      /** @type {number} */
      offset = offset | 0;
      /** @type {number} */
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      var val = this[offset + --byteLength];
      /** @type {number} */
      var mul = 1;
      for (; byteLength > 0 && (mul = mul * 256);) {
        val = val + this[offset + --byteLength] * mul;
      }
      return val;
    };
    /**
     * @param {?} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.readUInt8 = function(offset, noAssert) {
      return noAssert || checkOffset(offset, 1, this.length), this[offset];
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readUInt16LE = function(offset, limit) {
      return limit || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readUInt16BE = function(offset, limit) {
      return limit || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readUInt32LE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 16777216 * this[offset + 3];
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readUInt32BE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), 16777216 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    /**
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readIntLE = function(offset, byteLength, noAssert) {
      /** @type {number} */
      offset = offset | 0;
      /** @type {number} */
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      var val = this[offset];
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      var i = 0;
      for (; ++i < byteLength && (mul = mul * 256);) {
        val = val + this[offset + i] * mul;
      }
      return val >= (mul = mul * 128) && (val = val - Math.pow(2, 8 * byteLength)), val;
    };
    /**
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readIntBE = function(offset, byteLength, noAssert) {
      /** @type {number} */
      offset = offset | 0;
      /** @type {number} */
      byteLength = byteLength | 0;
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
      }
      /** @type {number} */
      var i = byteLength;
      /** @type {number} */
      var mul = 1;
      var val = this[offset + --i];
      for (; i > 0 && (mul = mul * 256);) {
        val = val + this[offset + --i] * mul;
      }
      return val >= (mul = mul * 128) && (val = val - Math.pow(2, 8 * byteLength)), val;
    };
    /**
     * @param {undefined} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readInt8 = function(offset, limit) {
      return limit || checkOffset(offset, 1, this.length), 128 & this[offset] ? -1 * (255 - this[offset] + 1) : this[offset];
    };
    /**
     * @param {number} offset
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readInt16LE = function(offset, noAssert) {
      if (!noAssert) {
        checkOffset(offset, 2, this.length);
      }
      /** @type {number} */
      var r = this[offset] | this[offset + 1] << 8;
      return 32768 & r ? 4294901760 | r : r;
    };
    /**
     * @param {number} offset
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.readInt16BE = function(offset, noAssert) {
      if (!noAssert) {
        checkOffset(offset, 2, this.length);
      }
      /** @type {number} */
      var r = this[offset + 1] | this[offset] << 8;
      return 32768 & r ? 4294901760 | r : r;
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readInt32LE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    /**
     * @param {number} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readInt32BE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    /**
     * @param {undefined} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readFloatLE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), that.read(this, offset, true, 23, 4);
    };
    /**
     * @param {undefined} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readFloatBE = function(offset, limit) {
      return limit || checkOffset(offset, 4, this.length), that.read(this, offset, false, 23, 4);
    };
    /**
     * @param {undefined} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readDoubleLE = function(offset, limit) {
      return limit || checkOffset(offset, 8, this.length), that.read(this, offset, true, 52, 8);
    };
    /**
     * @param {undefined} offset
     * @param {string} limit
     * @return {?}
     */
    Buffer.prototype.readDoubleBE = function(offset, limit) {
      return limit || checkOffset(offset, 8, this.length), that.read(this, offset, false, 52, 8);
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUIntLE = function(value, offset, byteLength, noAssert) {
      if (!(value = +value, offset = offset | 0, byteLength = byteLength | 0, noAssert)) {
        checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
      }
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      this[offset] = 255 & value;
      for (; ++i < byteLength && (mul = mul * 256);) {
        /** @type {number} */
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUIntBE = function(value, offset, byteLength, noAssert) {
      if (!(value = +value, offset = offset | 0, byteLength = byteLength | 0, noAssert)) {
        checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
      }
      /** @type {number} */
      var i = byteLength - 1;
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      this[offset + i] = 255 & value;
      for (; --i >= 0 && (mul = mul * 256);) {
        /** @type {number} */
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUInt8 = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 1, 255, 0), Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), this[offset] = 255 & value, offset + 1;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUInt16LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, true), offset + 2;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUInt16BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 65535, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = 255 & value) : objectWriteUInt16(this, value, offset, false), offset + 2;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUInt32LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, this[offset] = 255 & value) : objectWriteUInt32(this, value, offset, true), offset + 4;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeUInt32BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 4294967295, 0), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value) : objectWriteUInt32(this, value, offset, false), offset + 4;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.writeIntLE = function(value, offset, byteLength, noAssert) {
      if (value = +value, offset = offset | 0, !noAssert) {
        /** @type {number} */
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }
      /** @type {number} */
      var i = 0;
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      var s = 0;
      /** @type {number} */
      this[offset] = 255 & value;
      for (; ++i < byteLength && (mul = mul * 256);) {
        if (value < 0 && 0 === s && 0 !== this[offset + i - 1]) {
          /** @type {number} */
          s = 1;
        }
        /** @type {number} */
        this[offset + i] = (value / mul >> 0) - s & 255;
      }
      return offset + byteLength;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {number} byteLength
     * @param {?} noAssert
     * @return {?}
     */
    Buffer.prototype.writeIntBE = function(value, offset, byteLength, noAssert) {
      if (value = +value, offset = offset | 0, !noAssert) {
        /** @type {number} */
        var limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
      }
      /** @type {number} */
      var i = byteLength - 1;
      /** @type {number} */
      var mul = 1;
      /** @type {number} */
      var s = 0;
      /** @type {number} */
      this[offset + i] = 255 & value;
      for (; --i >= 0 && (mul = mul * 256);) {
        if (value < 0 && 0 === s && 0 !== this[offset + i + 1]) {
          /** @type {number} */
          s = 1;
        }
        /** @type {number} */
        this[offset + i] = (value / mul >> 0) - s & 255;
      }
      return offset + byteLength;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeInt8 = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 1, 127, -128), Buffer.TYPED_ARRAY_SUPPORT || (value = Math.floor(value)), value < 0 && (value = 255 + value + 1), this[offset] = 255 & value, offset + 1;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeInt16LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8) : objectWriteUInt16(this, value, offset, true), offset + 2;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeInt16BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 2, 32767, -32768), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 8, this[offset + 1] = 255 & value) : objectWriteUInt16(this, value, offset, false), offset + 2;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeInt32LE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = 255 & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, this[offset + 3] = value >>> 24) : objectWriteUInt32(this, value, offset, true), offset + 4;
    };
    /**
     * @param {number} value
     * @param {number} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeInt32BE = function(value, offset, noAssert) {
      return value = +value, offset = offset | 0, noAssert || checkInt(this, value, offset, 4, 2147483647, -2147483648), value < 0 && (value = 4294967295 + value + 1), Buffer.TYPED_ARRAY_SUPPORT ? (this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, this[offset + 3] = 255 & value) : objectWriteUInt32(this, value, offset, false), offset + 4;
    };
    /**
     * @param {!Array} value
     * @param {undefined} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeFloatLE = function(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    /**
     * @param {!Array} value
     * @param {undefined} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeFloatBE = function(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    /**
     * @param {!Array} value
     * @param {undefined} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeDoubleLE = function(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    /**
     * @param {!Array} value
     * @param {undefined} offset
     * @param {string} noAssert
     * @return {?}
     */
    Buffer.prototype.writeDoubleBE = function(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    /**
     * @param {!Object} value
     * @param {number} i
     * @param {number} start
     * @param {number} end
     * @return {?}
     */
    Buffer.prototype.copy = function(value, i, start, end) {
      if (start || (start = 0), end || 0 === end || (end = this.length), i >= value.length && (i = value.length), i || (i = 0), end > 0 && end < start && (end = start), end === start) {
        return 0;
      }
      if (0 === value.length || 0 === this.length) {
        return 0;
      }
      if (i < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) {
        throw new RangeError("sourceStart out of bounds");
      }
      if (end < 0) {
        throw new RangeError("sourceEnd out of bounds");
      }
      if (end > this.length) {
        end = this.length;
      }
      if (value.length - i < end - start) {
        end = value.length - i + start;
      }
      var j;
      /** @type {number} */
      var len = end - start;
      if (this === value && start < i && i < end) {
        /** @type {number} */
        j = len - 1;
        for (; j >= 0; --j) {
          value[j + i] = this[j + start];
        }
      } else {
        if (len < 1E3 || !Buffer.TYPED_ARRAY_SUPPORT) {
          /** @type {number} */
          j = 0;
          for (; j < len; ++j) {
            value[j + i] = this[j + start];
          }
        } else {
          Uint8Array.prototype.set.call(value, this.subarray(start, start + len), i);
        }
      }
      return len;
    };
    /**
     * @param {(number|string)} b
     * @param {number} start
     * @param {number} end
     * @param {?} encoding
     * @return {?}
     */
    Buffer.prototype.fill = function(b, start, end, encoding) {
      if ("string" === typeof b) {
        if ("string" === typeof start ? (encoding = start, start = 0, end = this.length) : "string" === typeof end && (encoding = end, end = this.length), 1 === b.length) {
          /** @type {number} */
          var vfrac = b.charCodeAt(0);
          if (vfrac < 256) {
            /** @type {number} */
            b = vfrac;
          }
        }
        if (void 0 !== encoding && "string" !== typeof encoding) {
          throw new TypeError("encoding must be a string");
        }
        if ("string" === typeof encoding && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
      } else {
        if ("number" === typeof b) {
          /** @type {number} */
          b = b & 255;
        }
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      var i;
      if (start = start >>> 0, end = void 0 === end ? this.length : end >>> 0, b || (b = 0), "number" === typeof b) {
        /** @type {number} */
        i = start;
        for (; i < end; ++i) {
          /** @type {(number|string)} */
          this[i] = b;
        }
      } else {
        var m = Buffer.isBuffer(b) ? b : utf8ToBytes((new Buffer(b, encoding)).toString());
        var len = m.length;
        /** @type {number} */
        i = 0;
        for (; i < end - start; ++i) {
          this[i + start] = m[i % len];
        }
      }
      return this;
    };
    /** @type {!RegExp} */
    var replaceRegex = /[^+\/0-9A-Za-z-_]/g;
  }).call(this, $(5));
}, function(e, canCreateDiscussions, require) {
  (function(moduleTransport) {
    !function(module, exports) {
      /**
       * @param {boolean} expected_true
       * @param {string} message
       * @return {undefined}
       */
      function assert(expected_true, message) {
        if (!expected_true) {
          throw new Error(message || "Assertion failed");
        }
      }
      /**
       * @param {!Object} ctor
       * @param {!Function} superCtor
       * @return {undefined}
       */
      function inherits(ctor, superCtor) {
        /** @type {!Function} */
        ctor.super_ = superCtor;
        /**
         * @return {undefined}
         */
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor;
        /** @type {!Object} */
        ctor.prototype.constructor = ctor;
      }
      /**
       * @param {string} value
       * @param {string} base
       * @param {string} endian
       * @return {?}
       */
      function BN(value, base, endian) {
        if (BN.isBN(value)) {
          return value;
        }
        /** @type {number} */
        this.negative = 0;
        /** @type {null} */
        this.words = null;
        /** @type {number} */
        this.length = 0;
        /** @type {null} */
        this.red = null;
        if (null !== value) {
          if (!("le" !== base && "be" !== base)) {
            /** @type {string} */
            endian = base;
            /** @type {number} */
            base = 10;
          }
          this._init(value || 0, base || 10, endian || "be");
        }
      }
      /**
       * @param {string} s
       * @param {number} index
       * @param {number} start
       * @return {?}
       */
      function parseHex(s, index, start) {
        /** @type {number} */
        var res = 0;
        /** @type {number} */
        var opts = Math.min(s.length, start);
        /** @type {number} */
        var o = index;
        for (; o < opts; o++) {
          /** @type {number} */
          var b = s.charCodeAt(o) - 48;
          /** @type {number} */
          res = res << 4;
          /** @type {number} */
          res = res | (b >= 49 && b <= 54 ? b - 49 + 10 : b >= 17 && b <= 22 ? b - 17 + 10 : 15 & b);
        }
        return res;
      }
      /**
       * @param {string} str
       * @param {?} input
       * @param {undefined} start
       * @param {number} base
       * @return {?}
       */
      function parseBase(str, input, start, base) {
        /** @type {number} */
        var r = 0;
        /** @type {number} */
        var end = Math.min(str.length, start);
        var i = input;
        for (; i < end; i++) {
          /** @type {number} */
          var pos = str.charCodeAt(i) - 48;
          /** @type {number} */
          r = r * base;
          /** @type {number} */
          r = r + (pos >= 49 ? pos - 49 + 10 : pos >= 17 ? pos - 17 + 10 : pos);
        }
        return r;
      }
      /**
       * @param {!Object} self
       * @param {!Object} num
       * @param {!Object} out
       * @return {?}
       */
      function smallMulTo(self, num, out) {
        /** @type {number} */
        out.negative = num.negative ^ self.negative;
        /** @type {number} */
        var curveCount = self.length + num.length | 0;
        /** @type {number} */
        out.length = curveCount;
        /** @type {number} */
        curveCount = curveCount - 1 | 0;
        /** @type {number} */
        var m1 = 0 | self.words[0];
        /** @type {number} */
        var m2 = 0 | num.words[0];
        /** @type {number} */
        var val = m1 * m2;
        /** @type {number} */
        var new_lo = 67108863 & val;
        /** @type {number} */
        var a = val / 67108864 | 0;
        /** @type {number} */
        out.words[0] = new_lo;
        /** @type {number} */
        var i = 1;
        for (; i < curveCount; i++) {
          /** @type {number} */
          var b = a >>> 26;
          /** @type {number} */
          var carry = 67108863 & a;
          /** @type {number} */
          var loopLen = Math.min(i, num.length - 1);
          /** @type {number} */
          var off = Math.max(0, i - self.length + 1);
          for (; off <= loopLen; off++) {
            /** @type {number} */
            var word = i - off | 0;
            /** @type {number} */
            b = b + ((val = (m1 = 0 | self.words[word]) * (m2 = 0 | num.words[off]) + carry) / 67108864 | 0);
            /** @type {number} */
            carry = 67108863 & val;
          }
          /** @type {number} */
          out.words[i] = 0 | carry;
          /** @type {number} */
          a = 0 | b;
        }
        return 0 !== a ? out.words[i] = 0 | a : out.length--, out.strip();
      }
      /**
       * @param {!Object} self
       * @param {!Array} num
       * @param {!Object} out
       * @return {?}
       */
      function jumboMulTo(self, num, out) {
        return (new FFTM).mulp(self, num, out);
      }
      /**
       * @param {string} x
       * @param {string} y
       * @return {undefined}
       */
      function FFTM(x, y) {
        /** @type {string} */
        this.x = x;
        /** @type {string} */
        this.y = y;
      }
      /**
       * @param {string} name
       * @param {!Image} p
       * @return {undefined}
       */
      function MPrime(name, p) {
        /** @type {string} */
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = (new BN(1)).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      /**
       * @return {undefined}
       */
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      /**
       * @return {undefined}
       */
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      /**
       * @return {undefined}
       */
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      /**
       * @return {undefined}
       */
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      /**
       * @param {!Array} m
       * @return {undefined}
       */
      function Red(m) {
        if ("string" === typeof m) {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          /** @type {!Array} */
          this.m = m;
          /** @type {null} */
          this.prime = null;
        }
      }
      /**
       * @param {?} m
       * @return {undefined}
       */
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = (new BN(1)).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      var Buffer;
      if ("object" === typeof module) {
        /** @type {function(string, string, string): ?} */
        module.exports = BN;
      } else {
        /** @type {function(string, string, string): ?} */
        exports.BN = BN;
      }
      /** @type {function(string, string, string): ?} */
      BN.BN = BN;
      /** @type {number} */
      BN.wordSize = 26;
      try {
        Buffer = require(154).Buffer;
      } catch (E) {
      }
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.isBN = function(num) {
        return num instanceof BN || null !== num && "object" === typeof num && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      /**
       * @param {!Object} x
       * @param {number} key
       * @return {?}
       */
      BN.max = function(x, key) {
        return x.cmp(key) > 0 ? x : key;
      };
      /**
       * @param {!Object} key
       * @param {number} x
       * @return {?}
       */
      BN.min = function(key, x) {
        return key.cmp(x) < 0 ? key : x;
      };
      /**
       * @param {number} number
       * @param {number} base
       * @param {string} endian
       * @return {?}
       */
      BN.prototype._init = function(number, base, endian) {
        if ("number" === typeof number) {
          return this._initNumber(number, base, endian);
        }
        if ("object" === typeof number) {
          return this._initArray(number, base, endian);
        }
        if ("hex" === base) {
          /** @type {number} */
          base = 16;
        }
        assert(base === (0 | base) && base >= 2 && base <= 36);
        /** @type {number} */
        var start = 0;
        if ("-" === (number = number.toString().replace(/\s+/g, ""))[0]) {
          start++;
        }
        if (16 === base) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if ("-" === number[0]) {
          /** @type {number} */
          this.negative = 1;
        }
        this.strip();
        if ("le" === endian) {
          this._initArray(this.toArray(), base, endian);
        }
      };
      /**
       * @param {number} number
       * @param {number} base
       * @param {string} endian
       * @return {undefined}
       */
      BN.prototype._initNumber = function(number, base, endian) {
        if (number < 0) {
          /** @type {number} */
          this.negative = 1;
          /** @type {number} */
          number = -number;
        }
        if (number < 67108864) {
          /** @type {!Array} */
          this.words = [67108863 & number];
          /** @type {number} */
          this.length = 1;
        } else {
          if (number < 4503599627370496) {
            /** @type {!Array} */
            this.words = [67108863 & number, number / 67108864 & 67108863];
            /** @type {number} */
            this.length = 2;
          } else {
            assert(number < 9007199254740992);
            /** @type {!Array} */
            this.words = [67108863 & number, number / 67108864 & 67108863, 1];
            /** @type {number} */
            this.length = 3;
          }
        }
        if ("le" === endian) {
          this._initArray(this.toArray(), base, endian);
        }
      };
      /**
       * @param {number} number
       * @param {number} base
       * @param {string} endian
       * @return {?}
       */
      BN.prototype._initArray = function(number, base, endian) {
        if (assert("number" === typeof number.length), number.length <= 0) {
          return this.words = [0], this.length = 1, this;
        }
        /** @type {number} */
        this.length = Math.ceil(number.length / 3);
        /** @type {!Array} */
        this.words = new Array(this.length);
        /** @type {number} */
        var i = 0;
        for (; i < this.length; i++) {
          /** @type {number} */
          this.words[i] = 0;
        }
        var j;
        var val;
        /** @type {number} */
        var bi_valid = 0;
        if ("be" === endian) {
          /** @type {number} */
          i = number.length - 1;
          /** @type {number} */
          j = 0;
          for (; i >= 0; i = i - 3) {
            /** @type {number} */
            val = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= val << bi_valid & 67108863;
            /** @type {number} */
            this.words[j + 1] = val >>> 26 - bi_valid & 67108863;
            if ((bi_valid = bi_valid + 24) >= 26) {
              /** @type {number} */
              bi_valid = bi_valid - 26;
              j++;
            }
          }
        } else {
          if ("le" === endian) {
            /** @type {number} */
            i = 0;
            /** @type {number} */
            j = 0;
            for (; i < number.length; i = i + 3) {
              /** @type {number} */
              val = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
              this.words[j] |= val << bi_valid & 67108863;
              /** @type {number} */
              this.words[j + 1] = val >>> 26 - bi_valid & 67108863;
              if ((bi_valid = bi_valid + 24) >= 26) {
                /** @type {number} */
                bi_valid = bi_valid - 26;
                j++;
              }
            }
          }
        }
        return this.strip();
      };
      /**
       * @param {!Function} number
       * @param {number} start
       * @return {undefined}
       */
      BN.prototype._parseHex = function(number, start) {
        /** @type {number} */
        this.length = Math.ceil((number.length - start) / 6);
        /** @type {!Array} */
        this.words = new Array(this.length);
        /** @type {number} */
        var i = 0;
        for (; i < this.length; i++) {
          /** @type {number} */
          this.words[i] = 0;
        }
        var j;
        var w;
        /** @type {number} */
        var off = 0;
        /** @type {number} */
        i = number.length - 6;
        /** @type {number} */
        j = 0;
        for (; i >= start; i = i - 6) {
          w = parseHex(number, i, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
          if ((off = off + 24) >= 26) {
            /** @type {number} */
            off = off - 26;
            j++;
          }
        }
        if (i + 6 !== start) {
          w = parseHex(number, start, i + 6);
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] |= w >>> 26 - off & 4194303;
        }
        this.strip();
      };
      /**
       * @param {!Function} number
       * @param {number} base
       * @param {number} start
       * @return {undefined}
       */
      BN.prototype._parseBase = function(number, base, start) {
        /** @type {!Array} */
        this.words = [0];
        /** @type {number} */
        this.length = 1;
        /** @type {number} */
        var limbLen = 0;
        /** @type {number} */
        var limbPow = 1;
        for (; limbPow <= 67108863; limbPow = limbPow * base) {
          limbLen++;
        }
        limbLen--;
        /** @type {number} */
        limbPow = limbPow / base | 0;
        /** @type {number} */
        var total = number.length - start;
        /** @type {number} */
        var mod = total % limbLen;
        var page = Math.min(total, total - mod) + start;
        /** @type {number} */
        var word = 0;
        /** @type {number} */
        var i = start;
        for (; i < page; i = i + limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (0 !== mod) {
          /** @type {number} */
          var limbPow = 1;
          word = parseBase(number, i, number.length, base);
          /** @type {number} */
          i = 0;
          for (; i < mod; i++) {
            /** @type {number} */
            limbPow = limbPow * base;
          }
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      /**
       * @param {!Object} dest
       * @return {undefined}
       */
      BN.prototype.copy = function(dest) {
        /** @type {!Array} */
        dest.words = new Array(this.length);
        /** @type {number} */
        var i = 0;
        for (; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      /**
       * @return {?}
       */
      BN.prototype.clone = function() {
        var r = new BN(null);
        return this.copy(r), r;
      };
      /**
       * @param {number} i
       * @return {?}
       */
      BN.prototype._expand = function(i) {
        for (; this.length < i;) {
          /** @type {number} */
          this.words[this.length++] = 0;
        }
        return this;
      };
      /**
       * @return {?}
       */
      BN.prototype.strip = function() {
        for (; this.length > 1 && 0 === this.words[this.length - 1];) {
          this.length--;
        }
        return this._normSign();
      };
      /**
       * @return {?}
       */
      BN.prototype._normSign = function() {
        return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
      };
      /**
       * @return {?}
       */
      BN.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      /** @type {!Array} */
      var output = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
      /** @type {!Array} */
      var input = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      /** @type {!Array} */
      var defaultProviderConfig$1 = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1E7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64E6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243E5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
      /**
       * @param {number} key
       * @param {number} n
       * @return {?}
       */
      BN.prototype.toString = function(key, n) {
        var name;
        if (n = 0 | n || 1, 16 === (key = key || 10) || "hex" === key) {
          /** @type {string} */
          name = "";
          /** @type {number} */
          var off = 0;
          /** @type {number} */
          var carry = 0;
          /** @type {number} */
          var i = 0;
          for (; i < this.length; i++) {
            var w = this.words[i];
            /** @type {string} */
            var b = (16777215 & (w << off | carry)).toString(16);
            /** @type {string} */
            name = 0 !== (carry = w >>> 24 - off & 16777215) || i !== this.length - 1 ? output[6 - b.length] + b + name : b + name;
            if ((off = off + 2) >= 26) {
              /** @type {number} */
              off = off - 26;
              i--;
            }
          }
          if (0 !== carry) {
            /** @type {string} */
            name = carry.toString(16) + name;
          }
          for (; name.length % n !== 0;) {
            /** @type {string} */
            name = "0" + name;
          }
          return 0 !== this.negative && (name = "-" + name), name;
        }
        if (key === (0 | key) && key >= 2 && key <= 36) {
          var fixed = input[key];
          var value = defaultProviderConfig$1[key];
          /** @type {string} */
          name = "";
          var c = this.clone();
          /** @type {number} */
          c.negative = 0;
          for (; !c.isZero();) {
            var b = c.modn(value).toString(key);
            /** @type {string} */
            name = (c = c.idivn(value)).isZero() ? b + name : output[fixed - b.length] + b + name;
          }
          if (this.isZero()) {
            /** @type {string} */
            name = "0" + name;
          }
          for (; name.length % n !== 0;) {
            /** @type {string} */
            name = "0" + name;
          }
          return 0 !== this.negative && (name = "-" + name), name;
        }
        assert(false, "Base should be between 2 and 36");
      };
      /**
       * @return {?}
       */
      BN.prototype.toNumber = function() {
        var ret = this.words[0];
        return 2 === this.length ? ret = ret + 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? ret = ret + (4503599627370496 + 67108864 * this.words[1]) : this.length > 2 && assert(false, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -ret : ret;
      };
      /**
       * @return {?}
       */
      BN.prototype.toJSON = function() {
        return this.toString(16);
      };
      /**
       * @param {string} endian
       * @param {string} length
       * @return {?}
       */
      BN.prototype.toBuffer = function(endian, length) {
        return assert("undefined" !== typeof Buffer), this.toArrayLike(Buffer, endian, length);
      };
      /**
       * @param {string} key
       * @param {string} length
       * @return {?}
       */
      BN.prototype.toArray = function(key, length) {
        return this.toArrayLike(Array, key, length);
      };
      /**
       * @param {!Function} ArrayType
       * @param {string} endian
       * @param {string} length
       * @return {?}
       */
      BN.prototype.toArrayLike = function(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var broken_ipv6;
        var i;
        /** @type {boolean} */
        var f = "le" === endian;
        var res = new ArrayType(reqLength);
        var q = this.clone();
        if (f) {
          /** @type {number} */
          i = 0;
          for (; !q.isZero(); i++) {
            broken_ipv6 = q.andln(255);
            q.iushrn(8);
            res[i] = broken_ipv6;
          }
          for (; i < reqLength; i++) {
            /** @type {number} */
            res[i] = 0;
          }
        } else {
          /** @type {number} */
          i = 0;
          for (; i < reqLength - byteLength; i++) {
            /** @type {number} */
            res[i] = 0;
          }
          /** @type {number} */
          i = 0;
          for (; !q.isZero(); i++) {
            broken_ipv6 = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = broken_ipv6;
          }
        }
        return res;
      };
      if (Math.clz32) {
        /**
         * @param {number} w
         * @return {?}
         */
        BN.prototype._countBits = function(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        /**
         * @param {number} w
         * @return {?}
         */
        BN.prototype._countBits = function(w) {
          /** @type {number} */
          var t = w;
          /** @type {number} */
          var y = 0;
          return t >= 4096 && (y = y + 13, t = t >>> 13), t >= 64 && (y = y + 7, t = t >>> 7), t >= 8 && (y = y + 4, t = t >>> 4), t >= 2 && (y = y + 2, t = t >>> 2), y + t;
        };
      }
      /**
       * @param {number} w
       * @return {?}
       */
      BN.prototype._zeroBits = function(w) {
        if (0 === w) {
          return 26;
        }
        /** @type {number} */
        var t = w;
        /** @type {number} */
        var n = 0;
        return 0 === (8191 & t) && (n = n + 13, t = t >>> 13), 0 === (127 & t) && (n = n + 7, t = t >>> 7), 0 === (15 & t) && (n = n + 4, t = t >>> 4), 0 === (3 & t) && (n = n + 2, t = t >>> 2), 0 === (1 & t) && n++, n;
      };
      /**
       * @return {?}
       */
      BN.prototype.bitLength = function() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return 26 * (this.length - 1) + hi;
      };
      /**
       * @return {?}
       */
      BN.prototype.zeroBits = function() {
        if (this.isZero()) {
          return 0;
        }
        /** @type {number} */
        var r = 0;
        /** @type {number} */
        var i = 0;
        for (; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          if (r = r + b, 26 !== b) {
            break;
          }
        }
        return r;
      };
      /**
       * @return {?}
       */
      BN.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      };
      /**
       * @param {undefined} width
       * @return {?}
       */
      BN.prototype.toTwos = function(width) {
        return 0 !== this.negative ? this.abs().inotn(width).iaddn(1) : this.clone();
      };
      /**
       * @param {number} width
       * @return {?}
       */
      BN.prototype.fromTwos = function(width) {
        return this.testn(width - 1) ? this.notn(width).iaddn(1).ineg() : this.clone();
      };
      /**
       * @return {?}
       */
      BN.prototype.isNeg = function() {
        return 0 !== this.negative;
      };
      /**
       * @return {?}
       */
      BN.prototype.neg = function() {
        return this.clone().ineg();
      };
      /**
       * @return {?}
       */
      BN.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.iuor = function(num) {
        for (; this.length < num.length;) {
          /** @type {number} */
          this.words[this.length++] = 0;
        }
        /** @type {number} */
        var i = 0;
        for (; i < num.length; i++) {
          /** @type {number} */
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.ior = function(num) {
        return assert(0 === (this.negative | num.negative)), this.iuor(num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.or = function(num) {
        return this.length > num.length ? this.clone().ior(num) : num.clone().ior(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.uor = function(num) {
        return this.length > num.length ? this.clone().iuor(num) : num.clone().iuor(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.iuand = function(num) {
        var $images;
        $images = this.length > num.length ? num : this;
        /** @type {number} */
        var i = 0;
        for (; i < $images.length; i++) {
          /** @type {number} */
          this.words[i] = this.words[i] & num.words[i];
        }
        return this.length = $images.length, this.strip();
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.iand = function(num) {
        return assert(0 === (this.negative | num.negative)), this.iuand(num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.and = function(num) {
        return this.length > num.length ? this.clone().iand(num) : num.clone().iand(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.uand = function(num) {
        return this.length > num.length ? this.clone().iuand(num) : num.clone().iuand(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.iuxor = function(num) {
        var options;
        var b;
        if (this.length > num.length) {
          options = this;
          /** @type {!Object} */
          b = num;
        } else {
          /** @type {!Object} */
          options = num;
          b = this;
        }
        /** @type {number} */
        var i = 0;
        for (; i < b.length; i++) {
          /** @type {number} */
          this.words[i] = options.words[i] ^ b.words[i];
        }
        if (this !== options) {
          for (; i < options.length; i++) {
            this.words[i] = options.words[i];
          }
        }
        return this.length = options.length, this.strip();
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.ixor = function(num) {
        return assert(0 === (this.negative | num.negative)), this.iuxor(num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.xor = function(num) {
        return this.length > num.length ? this.clone().ixor(num) : num.clone().ixor(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.uxor = function(num) {
        return this.length > num.length ? this.clone().iuxor(num) : num.clone().iuxor(this);
      };
      /**
       * @param {number} width
       * @return {?}
       */
      BN.prototype.inotn = function(width) {
        assert("number" === typeof width && width >= 0);
        /** @type {number} */
        var len = 0 | Math.ceil(width / 26);
        /** @type {number} */
        var bitsLeft = width % 26;
        this._expand(len);
        if (bitsLeft > 0) {
          len--;
        }
        /** @type {number} */
        var i = 0;
        for (; i < len; i++) {
          /** @type {number} */
          this.words[i] = 67108863 & ~this.words[i];
        }
        return bitsLeft > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft), this.strip();
      };
      /**
       * @param {number} width
       * @return {?}
       */
      BN.prototype.notn = function(width) {
        return this.clone().inotn(width);
      };
      /**
       * @param {number} val
       * @param {number} opt_validate
       * @return {?}
       */
      BN.prototype.setn = function(val, opt_validate) {
        assert("number" === typeof val && val >= 0);
        /** @type {number} */
        var off = val / 26 | 0;
        /** @type {number} */
        var wbit = val % 26;
        return this._expand(off + 1), this.words[off] = opt_validate ? this.words[off] | 1 << wbit : this.words[off] & ~(1 << wbit), this.strip();
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.iadd = function(num) {
        var r;
        var options;
        var b;
        if (0 !== this.negative && 0 === num.negative) {
          return this.negative = 0, r = this.isub(num), this.negative ^= 1, this._normSign();
        }
        if (0 === this.negative && 0 !== num.negative) {
          return num.negative = 0, r = this.isub(num), num.negative = 1, r._normSign();
        }
        if (this.length > num.length) {
          options = this;
          /** @type {!Object} */
          b = num;
        } else {
          /** @type {!Object} */
          options = num;
          b = this;
        }
        /** @type {number} */
        var carry = 0;
        /** @type {number} */
        var i = 0;
        for (; i < b.length; i++) {
          /** @type {number} */
          r = (0 | options.words[i]) + (0 | b.words[i]) + carry;
          /** @type {number} */
          this.words[i] = 67108863 & r;
          /** @type {number} */
          carry = r >>> 26;
        }
        for (; 0 !== carry && i < options.length; i++) {
          /** @type {number} */
          r = (0 | options.words[i]) + carry;
          /** @type {number} */
          this.words[i] = 67108863 & r;
          /** @type {number} */
          carry = r >>> 26;
        }
        if (this.length = options.length, 0 !== carry) {
          /** @type {number} */
          this.words[this.length] = carry;
          this.length++;
        } else {
          if (options !== this) {
            for (; i < options.length; i++) {
              this.words[i] = options.words[i];
            }
          }
        }
        return this;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.add = function(num) {
        var res;
        return 0 !== num.negative && 0 === this.negative ? (num.negative = 0, res = this.sub(num), num.negative ^= 1, res) : 0 === num.negative && 0 !== this.negative ? (this.negative = 0, res = num.sub(this), this.negative = 1, res) : this.length > num.length ? this.clone().iadd(num) : num.clone().iadd(this);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.isub = function(num) {
        if (0 !== num.negative) {
          /** @type {number} */
          num.negative = 0;
          var r = this.iadd(num);
          return num.negative = 1, r._normSign();
        }
        if (0 !== this.negative) {
          return this.negative = 0, this.iadd(num), this.negative = 1, this._normSign();
        }
        var options;
        var b;
        var cmp = this.cmp(num);
        if (0 === cmp) {
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        }
        if (cmp > 0) {
          options = this;
          /** @type {!Object} */
          b = num;
        } else {
          /** @type {!Object} */
          options = num;
          b = this;
        }
        /** @type {number} */
        var string = 0;
        /** @type {number} */
        var i = 0;
        for (; i < b.length; i++) {
          /** @type {number} */
          string = (r = (0 | options.words[i]) - (0 | b.words[i]) + string) >> 26;
          /** @type {number} */
          this.words[i] = 67108863 & r;
        }
        for (; 0 !== string && i < options.length; i++) {
          /** @type {number} */
          string = (r = (0 | options.words[i]) + string) >> 26;
          /** @type {number} */
          this.words[i] = 67108863 & r;
        }
        if (0 === string && i < options.length && options !== this) {
          for (; i < options.length; i++) {
            this.words[i] = options.words[i];
          }
        }
        return this.length = Math.max(this.length, i), options !== this && (this.negative = 1), this.strip();
      };
      /**
       * @param {!Object} b
       * @return {?}
       */
      BN.prototype.sub = function(b) {
        return this.clone().isub(b);
      };
      /**
       * @param {!Object} self
       * @param {!Object} num
       * @param {!Object} out
       * @return {?}
       */
      var comb10MulTo = function(self, num, out) {
        var lo;
        var mid;
        var hi;
        var words = self.words;
        var e = num.words;
        var f = out.words;
        /** @type {number} */
        var amndx = 0;
        /** @type {number} */
        var a0 = 0 | words[0];
        /** @type {number} */
        var al0 = 8191 & a0;
        /** @type {number} */
        var ah0 = a0 >>> 13;
        /** @type {number} */
        var a8 = 0 | words[1];
        /** @type {number} */
        var al2 = 8191 & a8;
        /** @type {number} */
        var ah8 = a8 >>> 13;
        /** @type {number} */
        var a1 = 0 | words[2];
        /** @type {number} */
        var al3 = 8191 & a1;
        /** @type {number} */
        var ah1 = a1 >>> 13;
        /** @type {number} */
        var a2 = 0 | words[3];
        /** @type {number} */
        var al4 = 8191 & a2;
        /** @type {number} */
        var ah2 = a2 >>> 13;
        /** @type {number} */
        var a3 = 0 | words[4];
        /** @type {number} */
        var al5 = 8191 & a3;
        /** @type {number} */
        var ah3 = a3 >>> 13;
        /** @type {number} */
        var a4 = 0 | words[5];
        /** @type {number} */
        var al6 = 8191 & a4;
        /** @type {number} */
        var ah4 = a4 >>> 13;
        /** @type {number} */
        var a5 = 0 | words[6];
        /** @type {number} */
        var al7 = 8191 & a5;
        /** @type {number} */
        var ah5 = a5 >>> 13;
        /** @type {number} */
        var a6 = 0 | words[7];
        /** @type {number} */
        var al8 = 8191 & a6;
        /** @type {number} */
        var ah6 = a6 >>> 13;
        /** @type {number} */
        var a7 = 0 | words[8];
        /** @type {number} */
        var al1 = 8191 & a7;
        /** @type {number} */
        var ah7 = a7 >>> 13;
        /** @type {number} */
        var a9 = 0 | words[9];
        /** @type {number} */
        var al9 = 8191 & a9;
        /** @type {number} */
        var ah9 = a9 >>> 13;
        /** @type {number} */
        var b0 = 0 | e[0];
        /** @type {number} */
        var bl0 = 8191 & b0;
        /** @type {number} */
        var bh0 = b0 >>> 13;
        /** @type {number} */
        var b9 = 0 | e[1];
        /** @type {number} */
        var bl3 = 8191 & b9;
        /** @type {number} */
        var bh9 = b9 >>> 13;
        /** @type {number} */
        var b3 = 0 | e[2];
        /** @type {number} */
        var bl4 = 8191 & b3;
        /** @type {number} */
        var bh3 = b3 >>> 13;
        /** @type {number} */
        var b7 = 0 | e[3];
        /** @type {number} */
        var bl5 = 8191 & b7;
        /** @type {number} */
        var bh7 = b7 >>> 13;
        /** @type {number} */
        var b4 = 0 | e[4];
        /** @type {number} */
        var bl6 = 8191 & b4;
        /** @type {number} */
        var bh4 = b4 >>> 13;
        /** @type {number} */
        var b8 = 0 | e[5];
        /** @type {number} */
        var bl1 = 8191 & b8;
        /** @type {number} */
        var bh8 = b8 >>> 13;
        /** @type {number} */
        var b5 = 0 | e[6];
        /** @type {number} */
        var bl2 = 8191 & b5;
        /** @type {number} */
        var bh5 = b5 >>> 13;
        /** @type {number} */
        var b6 = 0 | e[7];
        /** @type {number} */
        var bl9 = 8191 & b6;
        /** @type {number} */
        var bh6 = b6 >>> 13;
        /** @type {number} */
        var b2 = 0 | e[8];
        /** @type {number} */
        var bl8 = 8191 & b2;
        /** @type {number} */
        var bh2 = b2 >>> 13;
        /** @type {number} */
        var b1 = 0 | e[9];
        /** @type {number} */
        var bl7 = 8191 & b1;
        /** @type {number} */
        var bh1 = b1 >>> 13;
        /** @type {number} */
        out.negative = self.negative ^ num.negative;
        /** @type {number} */
        out.length = 19;
        /** @type {number} */
        var baz = (amndx + (lo = Math.imul(al0, bl0)) | 0) + ((8191 & (mid = (mid = Math.imul(al0, bh0)) + Math.imul(ah0, bl0) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = Math.imul(ah0, bh0)) + (mid >>> 13) | 0) + (baz >>> 26) | 0;
        /** @type {number} */
        baz = baz & 67108863;
        /** @type {number} */
        lo = Math.imul(al2, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al2, bh0)) + Math.imul(ah8, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah8, bh0);
        /** @type {number} */
        var tmp = (amndx + (lo = lo + Math.imul(al0, bl3) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh9) | 0) + Math.imul(ah0, bl3) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh9) | 0) + (mid >>> 13) | 0) + (tmp >>> 26) | 0;
        /** @type {number} */
        tmp = tmp & 67108863;
        /** @type {number} */
        lo = Math.imul(al3, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al3, bh0)) + Math.imul(ah1, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah1, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al2, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh9) | 0) + Math.imul(ah8, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh9) | 0;
        /** @type {number} */
        var a = (amndx + (lo = lo + Math.imul(al0, bl4) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh3) | 0) + Math.imul(ah0, bl4) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh3) | 0) + (mid >>> 13) | 0) + (a >>> 26) | 0;
        /** @type {number} */
        a = a & 67108863;
        /** @type {number} */
        lo = Math.imul(al4, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al4, bh0)) + Math.imul(ah2, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah2, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al3, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh9) | 0) + Math.imul(ah1, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh3) | 0) + Math.imul(ah8, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh3) | 0;
        /** @type {number} */
        var val = (amndx + (lo = lo + Math.imul(al0, bl5) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh7) | 0) + Math.imul(ah0, bl5) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh7) | 0) + (mid >>> 13) | 0) + (val >>> 26) | 0;
        /** @type {number} */
        val = val & 67108863;
        /** @type {number} */
        lo = Math.imul(al5, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al5, bh0)) + Math.imul(ah3, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah3, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al4, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh9) | 0) + Math.imul(ah2, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh3) | 0) + Math.imul(ah1, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh7) | 0) + Math.imul(ah8, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh7) | 0;
        /** @type {number} */
        var i = (amndx + (lo = lo + Math.imul(al0, bl6) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh4) | 0) + Math.imul(ah0, bl6) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh4) | 0) + (mid >>> 13) | 0) + (i >>> 26) | 0;
        /** @type {number} */
        i = i & 67108863;
        /** @type {number} */
        lo = Math.imul(al6, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al6, bh0)) + Math.imul(ah4, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah4, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al5, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh9) | 0) + Math.imul(ah3, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh3) | 0) + Math.imul(ah2, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh7) | 0) + Math.imul(ah1, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh4) | 0) + Math.imul(ah8, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh4) | 0;
        /** @type {number} */
        var methods = (amndx + (lo = lo + Math.imul(al0, bl1) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh8) | 0) + Math.imul(ah0, bl1) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh8) | 0) + (mid >>> 13) | 0) + (methods >>> 26) | 0;
        /** @type {number} */
        methods = methods & 67108863;
        /** @type {number} */
        lo = Math.imul(al7, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al7, bh0)) + Math.imul(ah5, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah5, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al6, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh9) | 0) + Math.imul(ah4, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh3) | 0) + Math.imul(ah3, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh7) | 0) + Math.imul(ah2, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh4) | 0) + Math.imul(ah1, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh8) | 0) + Math.imul(ah8, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh8) | 0;
        /** @type {number} */
        var bestStatType = (amndx + (lo = lo + Math.imul(al0, bl2) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh5) | 0) + Math.imul(ah0, bl2) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh5) | 0) + (mid >>> 13) | 0) + (bestStatType >>> 26) | 0;
        /** @type {number} */
        bestStatType = bestStatType & 67108863;
        /** @type {number} */
        lo = Math.imul(al8, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al8, bh0)) + Math.imul(ah6, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah6, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al7, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh9) | 0) + Math.imul(ah5, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh3) | 0) + Math.imul(ah4, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh7) | 0) + Math.imul(ah3, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh4) | 0) + Math.imul(ah2, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh8) | 0) + Math.imul(ah1, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh5) | 0) + Math.imul(ah8, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh5) | 0;
        /** @type {number} */
        var value = (amndx + (lo = lo + Math.imul(al0, bl9) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh6) | 0) + Math.imul(ah0, bl9) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh6) | 0) + (mid >>> 13) | 0) + (value >>> 26) | 0;
        /** @type {number} */
        value = value & 67108863;
        /** @type {number} */
        lo = Math.imul(al1, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al1, bh0)) + Math.imul(ah7, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah7, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al8, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh9) | 0) + Math.imul(ah6, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh3) | 0) + Math.imul(ah5, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh7) | 0) + Math.imul(ah4, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh4) | 0) + Math.imul(ah3, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh8) | 0) + Math.imul(ah2, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh5) | 0) + Math.imul(ah1, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh6) | 0) + Math.imul(ah8, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh6) | 0;
        /** @type {number} */
        var NaN = (amndx + (lo = lo + Math.imul(al0, bl8) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh2) | 0) + Math.imul(ah0, bl8) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh2) | 0) + (mid >>> 13) | 0) + (NaN >>> 26) | 0;
        /** @type {number} */
        NaN = NaN & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl0);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh0)) + Math.imul(ah9, bl0) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh0);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl3) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh9) | 0) + Math.imul(ah7, bl3) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh9) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh3) | 0) + Math.imul(ah6, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh7) | 0) + Math.imul(ah5, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh4) | 0) + Math.imul(ah4, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh8) | 0) + Math.imul(ah3, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh5) | 0) + Math.imul(ah2, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh6) | 0) + Math.imul(ah1, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al2, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al2, bh2) | 0) + Math.imul(ah8, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah8, bh2) | 0;
        /** @type {number} */
        var base = (amndx + (lo = lo + Math.imul(al0, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al0, bh1) | 0) + Math.imul(ah0, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah0, bh1) | 0) + (mid >>> 13) | 0) + (base >>> 26) | 0;
        /** @type {number} */
        base = base & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl3);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh9)) + Math.imul(ah9, bl3) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh9);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl4) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh3) | 0) + Math.imul(ah7, bl4) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh3) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh7) | 0) + Math.imul(ah6, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh4) | 0) + Math.imul(ah5, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh8) | 0) + Math.imul(ah4, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh5) | 0) + Math.imul(ah3, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh6) | 0) + Math.imul(ah2, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al3, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al3, bh2) | 0) + Math.imul(ah1, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah1, bh2) | 0;
        /** @type {number} */
        var message = (amndx + (lo = lo + Math.imul(al2, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al2, bh1) | 0) + Math.imul(ah8, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah8, bh1) | 0) + (mid >>> 13) | 0) + (message >>> 26) | 0;
        /** @type {number} */
        message = message & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl4);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh3)) + Math.imul(ah9, bl4) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh3);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl5) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh7) | 0) + Math.imul(ah7, bl5) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh7) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh4) | 0) + Math.imul(ah6, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh8) | 0) + Math.imul(ah5, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh5) | 0) + Math.imul(ah4, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh6) | 0) + Math.imul(ah3, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al4, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al4, bh2) | 0) + Math.imul(ah2, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah2, bh2) | 0;
        /** @type {number} */
        var elem = (amndx + (lo = lo + Math.imul(al3, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al3, bh1) | 0) + Math.imul(ah1, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah1, bh1) | 0) + (mid >>> 13) | 0) + (elem >>> 26) | 0;
        /** @type {number} */
        elem = elem & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl5);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh7)) + Math.imul(ah9, bl5) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh7);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl6) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh4) | 0) + Math.imul(ah7, bl6) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh4) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh8) | 0) + Math.imul(ah6, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh5) | 0) + Math.imul(ah5, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh6) | 0) + Math.imul(ah4, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al5, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al5, bh2) | 0) + Math.imul(ah3, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah3, bh2) | 0;
        /** @type {number} */
        var bestStat = (amndx + (lo = lo + Math.imul(al4, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al4, bh1) | 0) + Math.imul(ah2, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah2, bh1) | 0) + (mid >>> 13) | 0) + (bestStat >>> 26) | 0;
        /** @type {number} */
        bestStat = bestStat & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl6);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh4)) + Math.imul(ah9, bl6) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh4);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl1) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh8) | 0) + Math.imul(ah7, bl1) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh8) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh5) | 0) + Math.imul(ah6, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh6) | 0) + Math.imul(ah5, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al6, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al6, bh2) | 0) + Math.imul(ah4, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah4, bh2) | 0;
        /** @type {number} */
        var n = (amndx + (lo = lo + Math.imul(al5, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al5, bh1) | 0) + Math.imul(ah3, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah3, bh1) | 0) + (mid >>> 13) | 0) + (n >>> 26) | 0;
        /** @type {number} */
        n = n & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl1);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh8)) + Math.imul(ah9, bl1) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh8);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl2) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh5) | 0) + Math.imul(ah7, bl2) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh5) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh6) | 0) + Math.imul(ah6, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al7, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al7, bh2) | 0) + Math.imul(ah5, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah5, bh2) | 0;
        /** @type {number} */
        var v = (amndx + (lo = lo + Math.imul(al6, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al6, bh1) | 0) + Math.imul(ah4, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah4, bh1) | 0) + (mid >>> 13) | 0) + (v >>> 26) | 0;
        /** @type {number} */
        v = v & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl2);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh5)) + Math.imul(ah9, bl2) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh5);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl9) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh6) | 0) + Math.imul(ah7, bl9) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh6) | 0;
        /** @type {number} */
        lo = lo + Math.imul(al8, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al8, bh2) | 0) + Math.imul(ah6, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah6, bh2) | 0;
        /** @type {number} */
        var id = (amndx + (lo = lo + Math.imul(al7, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al7, bh1) | 0) + Math.imul(ah5, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah5, bh1) | 0) + (mid >>> 13) | 0) + (id >>> 26) | 0;
        /** @type {number} */
        id = id & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl9);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh6)) + Math.imul(ah9, bl9) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh6);
        /** @type {number} */
        lo = lo + Math.imul(al1, bl8) | 0;
        /** @type {number} */
        mid = (mid = mid + Math.imul(al1, bh2) | 0) + Math.imul(ah7, bl8) | 0;
        /** @type {number} */
        hi = hi + Math.imul(ah7, bh2) | 0;
        /** @type {number} */
        var d = (amndx + (lo = lo + Math.imul(al8, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al8, bh1) | 0) + Math.imul(ah6, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah6, bh1) | 0) + (mid >>> 13) | 0) + (d >>> 26) | 0;
        /** @type {number} */
        d = d & 67108863;
        /** @type {number} */
        lo = Math.imul(al9, bl8);
        /** @type {number} */
        mid = (mid = Math.imul(al9, bh2)) + Math.imul(ah9, bl8) | 0;
        /** @type {number} */
        hi = Math.imul(ah9, bh2);
        /** @type {number} */
        var b = (amndx + (lo = lo + Math.imul(al1, bl7) | 0) | 0) + ((8191 & (mid = (mid = mid + Math.imul(al1, bh1) | 0) + Math.imul(ah7, bl7) | 0)) << 13) | 0;
        /** @type {number} */
        amndx = ((hi = hi + Math.imul(ah7, bh1) | 0) + (mid >>> 13) | 0) + (b >>> 26) | 0;
        /** @type {number} */
        b = b & 67108863;
        /** @type {number} */
        var matches = (amndx + (lo = Math.imul(al9, bl7)) | 0) + ((8191 & (mid = (mid = Math.imul(al9, bh1)) + Math.imul(ah9, bl7) | 0)) << 13) | 0;
        return amndx = ((hi = Math.imul(ah9, bh1)) + (mid >>> 13) | 0) + (matches >>> 26) | 0, matches = matches & 67108863, f[0] = baz, f[1] = tmp, f[2] = a, f[3] = val, f[4] = i, f[5] = methods, f[6] = bestStatType, f[7] = value, f[8] = NaN, f[9] = base, f[10] = message, f[11] = elem, f[12] = bestStat, f[13] = n, f[14] = v, f[15] = id, f[16] = d, f[17] = b, f[18] = matches, 0 !== amndx && (f[19] = amndx, out.length++), out;
      };
      if (!Math.imul) {
        /** @type {function(!Object, !Object, !Object): ?} */
        comb10MulTo = smallMulTo;
      }
      /**
       * @param {?} num
       * @param {!Object} out
       * @return {?}
       */
      BN.prototype.mulTo = function(num, out) {
        var l = this.length + num.length;
        return 10 === this.length && 10 === num.length ? comb10MulTo(this, num, out) : l < 63 ? smallMulTo(this, num, out) : l < 1024 ? function(self, num, a) {
          /** @type {number} */
          a.negative = num.negative ^ self.negative;
          a.length = self.length + num.length;
          /** @type {number} */
          var nv = 0;
          /** @type {number} */
          var ele = 0;
          /** @type {number} */
          var i = 0;
          for (; i < a.length - 1; i++) {
            /** @type {number} */
            var n = ele;
            /** @type {number} */
            ele = 0;
            /** @type {number} */
            var icon = 67108863 & nv;
            /** @type {number} */
            var loopLen = Math.min(i, num.length - 1);
            /** @type {number} */
            var off = Math.max(0, i - self.length + 1);
            for (; off <= loopLen; off++) {
              /** @type {number} */
              var j = i - off;
              /** @type {number} */
              var TAG_CODE_MASK = (0 | self.words[j]) * (0 | num.words[off]);
              /** @type {number} */
              var blockTagCode = 67108863 & TAG_CODE_MASK;
              /** @type {number} */
              icon = 67108863 & (blockTagCode = blockTagCode + icon | 0);
              /** @type {number} */
              ele = ele + ((n = (n = n + (TAG_CODE_MASK / 67108864 | 0) | 0) + (blockTagCode >>> 26) | 0) >>> 26);
              /** @type {number} */
              n = n & 67108863;
            }
            /** @type {number} */
            a.words[i] = icon;
            /** @type {number} */
            nv = n;
            /** @type {number} */
            n = ele;
          }
          return 0 !== nv ? a.words[i] = nv : a.length--, a.strip();
        }(this, num, out) : jumboMulTo(this, num, out);
      };
      /**
       * @param {number} N
       * @return {?}
       */
      FFTM.prototype.makeRBT = function(N) {
        /** @type {!Array} */
        var t = new Array(N);
        /** @type {number} */
        var l = BN.prototype._countBits(N) - 1;
        /** @type {number} */
        var i = 0;
        for (; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      /**
       * @param {number} x
       * @param {number} l
       * @param {number} N
       * @return {?}
       */
      FFTM.prototype.revBin = function(x, l, N) {
        if (0 === x || x === N - 1) {
          return x;
        }
        /** @type {number} */
        var rb = 0;
        /** @type {number} */
        var i = 0;
        for (; i < l; i++) {
          /** @type {number} */
          rb = rb | (1 & x) << l - i - 1;
          /** @type {number} */
          x = x >> 1;
        }
        return rb;
      };
      /**
       * @param {!NodeList} rbt
       * @param {!Array} rws
       * @param {!Array} iws
       * @param {!Object} rtws
       * @param {!Object} itws
       * @param {number} N
       * @return {undefined}
       */
      FFTM.prototype.permute = function(rbt, rws, iws, rtws, itws, N) {
        /** @type {number} */
        var i = 0;
        for (; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      /**
       * @param {!Array} rws
       * @param {!Array} iws
       * @param {!Object} rtws
       * @param {!Object} itws
       * @param {number} N
       * @param {(Node|NodeList|string)} rbt
       * @return {undefined}
       */
      FFTM.prototype.transform = function(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        /** @type {number} */
        var s = 1;
        for (; s < N; s = s << 1) {
          /** @type {number} */
          var l = s << 1;
          /** @type {number} */
          var rtwdf = Math.cos(2 * Math.PI / l);
          /** @type {number} */
          var itwdf = Math.sin(2 * Math.PI / l);
          /** @type {number} */
          var p = 0;
          for (; p < N; p = p + l) {
            /** @type {number} */
            var rtwdf_ = rtwdf;
            /** @type {number} */
            var itwdf_ = itwdf;
            /** @type {number} */
            var j = 0;
            for (; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              /** @type {number} */
              var rx = rtwdf_ * ro - itwdf_ * io;
              /** @type {number} */
              io = rtwdf_ * io + itwdf_ * ro;
              /** @type {number} */
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              /** @type {number} */
              rtws[p + j + s] = re - ro;
              /** @type {number} */
              itws[p + j + s] = ie - io;
              if (j !== l) {
                /** @type {number} */
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                /** @type {number} */
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                /** @type {number} */
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      /**
       * @param {undefined} m
       * @param {!Object} n
       * @return {?}
       */
      FFTM.prototype.guessLen13b = function(m, n) {
        /** @type {number} */
        var bi_buf = 1 | Math.max(n, m);
        /** @type {number} */
        var dupeNameCount = 1 & bi_buf;
        /** @type {number} */
        var groupNamePrefix = 0;
        /** @type {number} */
        bi_buf = bi_buf / 2 | 0;
        for (; bi_buf; bi_buf = bi_buf >>> 1) {
          groupNamePrefix++;
        }
        return 1 << groupNamePrefix + 1 + dupeNameCount;
      };
      /**
       * @param {!Array} rws
       * @param {!Array} iws
       * @param {number} N
       * @return {undefined}
       */
      FFTM.prototype.conjugate = function(rws, iws, N) {
        if (!(N <= 1)) {
          /** @type {number} */
          var i = 0;
          for (; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            /** @type {number} */
            iws[i] = -iws[N - i - 1];
            /** @type {number} */
            iws[N - i - 1] = -t;
          }
        }
      };
      /**
       * @param {!Array} ws
       * @param {number} N
       * @return {?}
       */
      FFTM.prototype.normalize13b = function(ws, N) {
        /** @type {number} */
        var baseName = 0;
        /** @type {number} */
        var i = 0;
        for (; i < N / 2; i++) {
          /** @type {number} */
          var middlePathName = 8192 * Math.round(ws[2 * i + 1] / N) + Math.round(ws[2 * i] / N) + baseName;
          /** @type {number} */
          ws[i] = 67108863 & middlePathName;
          /** @type {number} */
          baseName = middlePathName < 67108864 ? 0 : middlePathName / 67108864 | 0;
        }
        return ws;
      };
      /**
       * @param {!NodeList} ws
       * @param {number} len
       * @param {!Array} rws
       * @param {number} N
       * @return {undefined}
       */
      FFTM.prototype.convert13b = function(ws, len, rws, N) {
        /** @type {number} */
        var b = 0;
        /** @type {number} */
        var i = 0;
        for (; i < len; i++) {
          /** @type {number} */
          b = b + (0 | ws[i]);
          /** @type {number} */
          rws[2 * i] = 8191 & b;
          /** @type {number} */
          b = b >>> 13;
          /** @type {number} */
          rws[2 * i + 1] = 8191 & b;
          /** @type {number} */
          b = b >>> 13;
        }
        /** @type {number} */
        i = 2 * len;
        for (; i < N; ++i) {
          /** @type {number} */
          rws[i] = 0;
        }
        assert(0 === b);
        assert(0 === (-8192 & b));
      };
      /**
       * @param {number} name
       * @return {?}
       */
      FFTM.prototype.stub = function(name) {
        /** @type {!Array} */
        var object = new Array(name);
        /** @type {number} */
        var exkey = 0;
        for (; exkey < name; exkey++) {
          /** @type {number} */
          object[exkey] = 0;
        }
        return object;
      };
      /**
       * @param {!Object} x
       * @param {!Object} y
       * @param {!Object} out
       * @return {?}
       */
      FFTM.prototype.mulp = function(x, y, out) {
        /** @type {number} */
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        /** @type {!Array} */
        var nrws = new Array(N);
        /** @type {!Array} */
        var rwst = new Array(N);
        /** @type {!Array} */
        var iwst = new Array(N);
        /** @type {!Array} */
        var rws = new Array(N);
        /** @type {!Array} */
        var nrwst = new Array(N);
        /** @type {!Array} */
        var niwst = new Array(N);
        var rmws = out.words;
        /** @type {number} */
        rmws.length = N;
        this.convert13b(x.words, x.length, nrws, N);
        this.convert13b(y.words, y.length, rws, N);
        this.transform(nrws, _, rwst, iwst, N, rbt);
        this.transform(rws, _, nrwst, niwst, N, rbt);
        /** @type {number} */
        var i = 0;
        for (; i < N; i++) {
          /** @type {number} */
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          /** @type {number} */
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          /** @type {number} */
          rwst[i] = rx;
        }
        return this.conjugate(rwst, iwst, N), this.transform(rwst, iwst, rmws, _, N, rbt), this.conjugate(rmws, _, N), this.normalize13b(rmws, N), out.negative = x.negative ^ y.negative, out.length = x.length + y.length, out.strip();
      };
      /**
       * @param {?} num
       * @return {?}
       */
      BN.prototype.mul = function(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), this.mulTo(num, out);
      };
      /**
       * @param {!Array} num
       * @return {?}
       */
      BN.prototype.mulf = function(num) {
        var out = new BN(null);
        return out.words = new Array(this.length + num.length), jumboMulTo(this, num, out);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.imul = function(num) {
        return this.clone().mulTo(num, this);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.imuln = function(num) {
        assert("number" === typeof num);
        assert(num < 67108864);
        /** @type {number} */
        var carry = 0;
        /** @type {number} */
        var i = 0;
        for (; i < this.length; i++) {
          /** @type {number} */
          var x = (0 | this.words[i]) * num;
          /** @type {number} */
          var wideValue = (67108863 & x) + (67108863 & carry);
          /** @type {number} */
          carry = carry >> 26;
          /** @type {number} */
          carry = carry + (x / 67108864 | 0);
          /** @type {number} */
          carry = carry + (wideValue >>> 26);
          /** @type {number} */
          this.words[i] = 67108863 & wideValue;
        }
        return 0 !== carry && (this.words[i] = carry, this.length++), this;
      };
      /**
       * @param {undefined} value
       * @return {?}
       */
      BN.prototype.muln = function(value) {
        return this.clone().imuln(value);
      };
      /**
       * @return {?}
       */
      BN.prototype.sqr = function() {
        return this.mul(this);
      };
      /**
       * @return {?}
       */
      BN.prototype.isqr = function() {
        return this.imul(this.clone());
      };
      /**
       * @param {number} arg
       * @return {?}
       */
      BN.prototype.pow = function(arg) {
        var args = function(num) {
          /** @type {!Array} */
          var w = new Array(num.bitLength());
          /** @type {number} */
          var bit = 0;
          for (; bit < w.length; bit++) {
            /** @type {number} */
            var off = bit / 26 | 0;
            /** @type {number} */
            var wbit = bit % 26;
            /** @type {number} */
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }(arg);
        if (0 === args.length) {
          return new BN(1);
        }
        var res = this;
        /** @type {number} */
        var i = 0;
        for (; i < args.length && 0 === args[i]; i++, res = res.sqr()) {
        }
        if (++i < args.length) {
          var q = res.sqr();
          for (; i < args.length; i++, q = q.sqr()) {
            if (0 !== args[i]) {
              res = res.mul(q);
            }
          }
        }
        return res;
      };
      /**
       * @param {number} bits
       * @return {?}
       */
      BN.prototype.iushln = function(bits) {
        assert("number" === typeof bits && bits >= 0);
        var i;
        /** @type {number} */
        var r = bits % 26;
        /** @type {number} */
        var s = (bits - r) / 26;
        /** @type {number} */
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        if (0 !== r) {
          /** @type {number} */
          var carry = 0;
          /** @type {number} */
          i = 0;
          for (; i < this.length; i++) {
            /** @type {number} */
            var newCarry = this.words[i] & carryMask;
            /** @type {number} */
            var c = (0 | this.words[i]) - newCarry << r;
            /** @type {number} */
            this.words[i] = c | carry;
            /** @type {number} */
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            /** @type {number} */
            this.words[i] = carry;
            this.length++;
          }
        }
        if (0 !== s) {
          /** @type {number} */
          i = this.length - 1;
          for (; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          /** @type {number} */
          i = 0;
          for (; i < s; i++) {
            /** @type {number} */
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      /**
       * @param {number} bits
       * @return {?}
       */
      BN.prototype.ishln = function(bits) {
        return assert(0 === this.negative), this.iushln(bits);
      };
      /**
       * @param {number} value
       * @param {number} hint
       * @param {!Object} extended
       * @return {?}
       */
      BN.prototype.iushrn = function(value, hint, extended) {
        var t;
        assert("number" === typeof value && value >= 0);
        /** @type {number} */
        t = hint ? (hint - hint % 26) / 26 : 0;
        /** @type {number} */
        var y = value % 26;
        /** @type {number} */
        var s = Math.min((value - y) / 26, this.length);
        /** @type {number} */
        var m = 67108863 ^ 67108863 >>> y << y;
        /** @type {!Object} */
        var maskedWords = extended;
        if (t = t - s, t = Math.max(0, t), maskedWords) {
          /** @type {number} */
          var i = 0;
          for (; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          /** @type {number} */
          maskedWords.length = s;
        }
        if (0 === s) {
        } else {
          if (this.length > s) {
            this.length -= s;
            /** @type {number} */
            i = 0;
            for (; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            /** @type {number} */
            this.words[0] = 0;
            /** @type {number} */
            this.length = 1;
          }
        }
        /** @type {number} */
        var x = 0;
        /** @type {number} */
        i = this.length - 1;
        for (; i >= 0 && (0 !== x || i >= t); i--) {
          /** @type {number} */
          var p = 0 | this.words[i];
          /** @type {number} */
          this.words[i] = x << 26 - y | p >>> y;
          /** @type {number} */
          x = p & m;
        }
        return maskedWords && 0 !== x && (maskedWords.words[maskedWords.length++] = x), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
      };
      /**
       * @param {number} bits
       * @param {undefined} hint
       * @param {!Object} extended
       * @return {?}
       */
      BN.prototype.ishrn = function(bits, hint, extended) {
        return assert(0 === this.negative), this.iushrn(bits, hint, extended);
      };
      /**
       * @param {undefined} bits
       * @return {?}
       */
      BN.prototype.shln = function(bits) {
        return this.clone().ishln(bits);
      };
      /**
       * @param {number} value
       * @return {?}
       */
      BN.prototype.ushln = function(value) {
        return this.clone().iushln(value);
      };
      /**
       * @param {number} bits
       * @return {?}
       */
      BN.prototype.shrn = function(bits) {
        return this.clone().ishrn(bits);
      };
      /**
       * @param {number} value
       * @return {?}
       */
      BN.prototype.ushrn = function(value) {
        return this.clone().iushrn(value);
      };
      /**
       * @param {number} bit
       * @return {?}
       */
      BN.prototype.testn = function(bit) {
        assert("number" === typeof bit && bit >= 0);
        /** @type {number} */
        var r = bit % 26;
        /** @type {number} */
        var s = (bit - r) / 26;
        /** @type {number} */
        var num = 1 << r;
        return !(this.length <= s) && !!(this.words[s] & num);
      };
      /**
       * @param {number} val
       * @return {?}
       */
      BN.prototype.imaskn = function(val) {
        assert("number" === typeof val && val >= 0);
        /** @type {number} */
        var valModStep = val % 26;
        /** @type {number} */
        var y = (val - valModStep) / 26;
        if (assert(0 === this.negative, "imaskn works only with positive numbers"), this.length <= y) {
          return this;
        }
        if (0 !== valModStep && y++, this.length = Math.min(y, this.length), 0 !== valModStep) {
          /** @type {number} */
          var mask = 67108863 ^ 67108863 >>> valModStep << valModStep;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      /**
       * @param {undefined} bits
       * @return {?}
       */
      BN.prototype.maskn = function(bits) {
        return this.clone().imaskn(bits);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.iaddn = function(num) {
        return assert("number" === typeof num), assert(num < 67108864), num < 0 ? this.isubn(-num) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < num ? (this.words[0] = num - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(num), this.negative = 1, this) : this._iaddn(num);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype._iaddn = function(num) {
        this.words[0] += num;
        /** @type {number} */
        var i = 0;
        for (; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            /** @type {number} */
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        return this.length = Math.max(this.length, i + 1), this;
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.isubn = function(num) {
        if (assert("number" === typeof num), assert(num < 67108864), num < 0) {
          return this.iaddn(-num);
        }
        if (0 !== this.negative) {
          return this.negative = 0, this.iaddn(num), this.negative = 1, this;
        }
        if (this.words[0] -= num, 1 === this.length && this.words[0] < 0) {
          /** @type {number} */
          this.words[0] = -this.words[0];
          /** @type {number} */
          this.negative = 1;
        } else {
          /** @type {number} */
          var i = 0;
          for (; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.addn = function(num) {
        return this.clone().iaddn(num);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.subn = function(num) {
        return this.clone().isubn(num);
      };
      /**
       * @return {?}
       */
      BN.prototype.iabs = function() {
        return this.negative = 0, this;
      };
      /**
       * @return {?}
       */
      BN.prototype.abs = function() {
        return this.clone().iabs();
      };
      /**
       * @param {!Object} num
       * @param {number} mul
       * @param {number} shift
       * @return {?}
       */
      BN.prototype._ishlnsubmul = function(num, mul, shift) {
        var i;
        var intValue;
        var len = num.length + shift;
        this._expand(len);
        /** @type {number} */
        var sm = 0;
        /** @type {number} */
        i = 0;
        for (; i < num.length; i++) {
          /** @type {number} */
          intValue = (0 | this.words[i + shift]) + sm;
          /** @type {number} */
          var mul3 = (0 | num.words[i]) * mul;
          /** @type {number} */
          sm = ((intValue = intValue - (67108863 & mul3)) >> 26) - (mul3 / 67108864 | 0);
          /** @type {number} */
          this.words[i + shift] = 67108863 & intValue;
        }
        for (; i < this.length - shift; i++) {
          /** @type {number} */
          sm = (intValue = (0 | this.words[i + shift]) + sm) >> 26;
          /** @type {number} */
          this.words[i + shift] = 67108863 & intValue;
        }
        if (0 === sm) {
          return this.strip();
        }
        assert(-1 === sm);
        /** @type {number} */
        sm = 0;
        /** @type {number} */
        i = 0;
        for (; i < this.length; i++) {
          /** @type {number} */
          sm = (intValue = -(0 | this.words[i]) + sm) >> 26;
          /** @type {number} */
          this.words[i] = 67108863 & intValue;
        }
        return this.negative = 1, this.strip();
      };
      /**
       * @param {!Object} num
       * @param {string} undefined
       * @return {?}
       */
      BN.prototype._wordDiv = function(num, undefined) {
        var shift = (this.length, num.length);
        var a = this.clone();
        /** @type {!Object} */
        var b = num;
        /** @type {number} */
        var bhi = 0 | b.words[b.length - 1];
        if (0 !== (shift = 26 - this._countBits(bhi))) {
          b = b.ushln(shift);
          a.iushln(shift);
          /** @type {number} */
          bhi = 0 | b.words[b.length - 1];
        }
        var q;
        /** @type {number} */
        var m = a.length - b.length;
        if ("mod" !== undefined) {
          /** @type {number} */
          (q = new BN(null)).length = m + 1;
          /** @type {!Array} */
          q.words = new Array(q.length);
          /** @type {number} */
          var i = 0;
          for (; i < q.length; i++) {
            /** @type {number} */
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (0 === diff.negative) {
          a = diff;
          if (q) {
            /** @type {number} */
            q.words[m] = 1;
          }
        }
        /** @type {number} */
        var j = m - 1;
        for (; j >= 0; j--) {
          /** @type {number} */
          var qj = 67108864 * (0 | a.words[b.length + j]) + (0 | a.words[b.length + j - 1]);
          /** @type {number} */
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          for (; 0 !== a.negative;) {
            qj--;
            /** @type {number} */
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            /** @type {number} */
            q.words[j] = qj;
          }
        }
        return q && q.strip(), a.strip(), "div" !== undefined && 0 !== shift && a.iushrn(shift), {
          div : q || null,
          mod : a
        };
      };
      /**
       * @param {!Object} num
       * @param {string} mode
       * @param {boolean} positive
       * @return {?}
       */
      BN.prototype.divmod = function(num, mode, positive) {
        return assert(!num.isZero()), this.isZero() ? {
          div : new BN(0),
          mod : new BN(0)
        } : 0 !== this.negative && 0 === num.negative ? (res = this.neg().divmod(num, mode), "mod" !== mode && (div = res.div.neg()), "div" !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.iadd(num)), {
          div : div,
          mod : mod
        }) : 0 === this.negative && 0 !== num.negative ? (res = this.divmod(num.neg(), mode), "mod" !== mode && (div = res.div.neg()), {
          div : div,
          mod : res.mod
        }) : 0 !== (this.negative & num.negative) ? (res = this.neg().divmod(num.neg(), mode), "div" !== mode && (mod = res.mod.neg(), positive && 0 !== mod.negative && mod.isub(num)), {
          div : res.div,
          mod : mod
        }) : num.length > this.length || this.cmp(num) < 0 ? {
          div : new BN(0),
          mod : this
        } : 1 === num.length ? "div" === mode ? {
          div : this.divn(num.words[0]),
          mod : null
        } : "mod" === mode ? {
          div : null,
          mod : new BN(this.modn(num.words[0]))
        } : {
          div : this.divn(num.words[0]),
          mod : new BN(this.modn(num.words[0]))
        } : this._wordDiv(num, mode);
        var div;
        var mod;
        var res;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.div = function(num) {
        return this.divmod(num, "div", false).div;
      };
      /**
       * @param {string} key
       * @return {?}
       */
      BN.prototype.mod = function(key) {
        return this.divmod(key, "mod", false).mod;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.umod = function(num) {
        return this.divmod(num, "mod", true).mod;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.divRound = function(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) {
          return dm.div;
        }
        var r = 0 !== dm.div.negative ? dm.mod.isub(num) : dm.mod;
        var q = num.ushrn(1);
        var FacilitySitePoint_140 = num.andln(1);
        var url = r.cmp(q);
        return url < 0 || 1 === FacilitySitePoint_140 && 0 === url ? dm.div : 0 !== dm.div.negative ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.modn = function(num) {
        assert(num <= 67108863);
        /** @type {number} */
        var p = (1 << 26) % num;
        /** @type {number} */
        var acc = 0;
        /** @type {number} */
        var i = this.length - 1;
        for (; i >= 0; i--) {
          /** @type {number} */
          acc = (p * acc + (0 | this.words[i])) % num;
        }
        return acc;
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.idivn = function(num) {
        assert(num <= 67108863);
        /** @type {number} */
        var carry = 0;
        /** @type {number} */
        var i = this.length - 1;
        for (; i >= 0; i--) {
          /** @type {number} */
          var w = (0 | this.words[i]) + 67108864 * carry;
          /** @type {number} */
          this.words[i] = w / num | 0;
          /** @type {number} */
          carry = w % num;
        }
        return this.strip();
      };
      /**
       * @param {undefined} value
       * @return {?}
       */
      BN.prototype.divn = function(value) {
        return this.clone().idivn(value);
      };
      /**
       * @param {!Object} p
       * @return {?}
       */
      BN.prototype.egcd = function(p) {
        assert(0 === p.negative);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        x = 0 !== x.negative ? x.umod(p) : x.clone();
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        /** @type {number} */
        var g = 0;
        for (; x.isEven() && y.isEven();) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        for (; !x.isZero();) {
          /** @type {number} */
          var i = 0;
          /** @type {number} */
          var res = 1;
          for (; 0 === (x.words[0] & res) && i < 26; ++i, res = res << 1) {
          }
          if (i > 0) {
            x.iushrn(i);
            for (; i-- > 0;) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          /** @type {number} */
          var j = 0;
          /** @type {number} */
          var k = 1;
          for (; 0 === (y.words[0] & k) && j < 26; ++j, k = k << 1) {
          }
          if (j > 0) {
            y.iushrn(j);
            for (; j-- > 0;) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a : C,
          b : D,
          gcd : y.iushln(g)
        };
      };
      /**
       * @param {!Object} p
       * @return {?}
       */
      BN.prototype._invmp = function(p) {
        assert(0 === p.negative);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        a = 0 !== a.negative ? a.umod(p) : a.clone();
        var frame;
        var C = new BN(1);
        var A = new BN(0);
        var yp = b.clone();
        for (; a.cmpn(1) > 0 && b.cmpn(1) > 0;) {
          /** @type {number} */
          var j = 0;
          /** @type {number} */
          var k = 1;
          for (; 0 === (a.words[0] & k) && j < 26; ++j, k = k << 1) {
          }
          if (j > 0) {
            a.iushrn(j);
            for (; j-- > 0;) {
              if (C.isOdd()) {
                C.iadd(yp);
              }
              C.iushrn(1);
            }
          }
          /** @type {number} */
          var i = 0;
          /** @type {number} */
          var res = 1;
          for (; 0 === (b.words[0] & res) && i < 26; ++i, res = res << 1) {
          }
          if (i > 0) {
            b.iushrn(i);
            for (; i-- > 0;) {
              if (A.isOdd()) {
                A.iadd(yp);
              }
              A.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            C.isub(A);
          } else {
            b.isub(a);
            A.isub(C);
          }
        }
        return (frame = 0 === a.cmpn(1) ? C : A).cmpn(0) < 0 && frame.iadd(p), frame;
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.gcd = function(num) {
        if (this.isZero()) {
          return num.abs();
        }
        if (num.isZero()) {
          return this.abs();
        }
        var a = this.clone();
        var b = num.clone();
        /** @type {number} */
        a.negative = 0;
        /** @type {number} */
        b.negative = 0;
        /** @type {number} */
        var shift = 0;
        for (; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        for (;;) {
          for (; a.isEven();) {
            a.iushrn(1);
          }
          for (; b.isEven();) {
            b.iushrn(1);
          }
          var originalB = a.cmp(b);
          if (originalB < 0) {
            var bytes = a;
            a = b;
            b = bytes;
          } else {
            if (0 === originalB || 0 === b.cmpn(1)) {
              break;
            }
          }
          a.isub(b);
        }
        return b.iushln(shift);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.invm = function(num) {
        return this.egcd(num).a.umod(num);
      };
      /**
       * @return {?}
       */
      BN.prototype.isEven = function() {
        return 0 === (1 & this.words[0]);
      };
      /**
       * @return {?}
       */
      BN.prototype.isOdd = function() {
        return 1 === (1 & this.words[0]);
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.andln = function(num) {
        return this.words[0] & num;
      };
      /**
       * @param {number} bit
       * @return {?}
       */
      BN.prototype.bincn = function(bit) {
        assert("number" === typeof bit);
        /** @type {number} */
        var r = bit % 26;
        /** @type {number} */
        var s = (bit - r) / 26;
        /** @type {number} */
        var q = 1 << r;
        if (this.length <= s) {
          return this._expand(s + 1), this.words[s] |= q, this;
        }
        /** @type {number} */
        var carry = q;
        /** @type {number} */
        var i = s;
        for (; 0 !== carry && i < this.length; i++) {
          /** @type {number} */
          var w = 0 | this.words[i];
          /** @type {number} */
          carry = (w = w + carry) >>> 26;
          /** @type {number} */
          w = w & 67108863;
          /** @type {number} */
          this.words[i] = w;
        }
        return 0 !== carry && (this.words[i] = carry, this.length++), this;
      };
      /**
       * @return {?}
       */
      BN.prototype.isZero = function() {
        return 1 === this.length && 0 === this.words[0];
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.cmpn = function(num) {
        var t;
        /** @type {boolean} */
        var neg = num < 0;
        if (0 !== this.negative && !neg) {
          return -1;
        }
        if (0 === this.negative && neg) {
          return 1;
        }
        if (this.strip(), this.length > 1) {
          /** @type {number} */
          t = 1;
        } else {
          if (neg) {
            /** @type {number} */
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          /** @type {number} */
          var i = 0 | this.words[0];
          /** @type {number} */
          t = i === num ? 0 : i < num ? -1 : 1;
        }
        return 0 !== this.negative ? 0 | -t : t;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.cmp = function(num) {
        if (0 !== this.negative && 0 === num.negative) {
          return -1;
        }
        if (0 === this.negative && 0 !== num.negative) {
          return 1;
        }
        var res = this.ucmp(num);
        return 0 !== this.negative ? 0 | -res : res;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.ucmp = function(num) {
        if (this.length > num.length) {
          return 1;
        }
        if (this.length < num.length) {
          return -1;
        }
        /** @type {number} */
        var 1 = 0;
        /** @type {number} */
        var i = this.length - 1;
        for (; i >= 0; i--) {
          /** @type {number} */
          var oldIndex = 0 | this.words[i];
          /** @type {number} */
          var newIndex = 0 | num.words[i];
          if (oldIndex !== newIndex) {
            if (oldIndex < newIndex) {
              /** @type {number} */
              1 = -1;
            } else {
              if (oldIndex > newIndex) {
                /** @type {number} */
                1 = 1;
              }
            }
            break;
          }
        }
        return 1;
      };
      /**
       * @param {number} num
       * @return {?}
       */
      BN.prototype.gtn = function(num) {
        return 1 === this.cmpn(num);
      };
      /**
       * @param {!Object} value
       * @return {?}
       */
      BN.prototype.gt = function(value) {
        return 1 === this.cmp(value);
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.gten = function(num) {
        return this.cmpn(num) >= 0;
      };
      /**
       * @param {!Object} value
       * @return {?}
       */
      BN.prototype.gte = function(value) {
        return this.cmp(value) >= 0;
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.ltn = function(num) {
        return -1 === this.cmpn(num);
      };
      /**
       * @param {!Object} value
       * @return {?}
       */
      BN.prototype.lt = function(value) {
        return -1 === this.cmp(value);
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.lten = function(num) {
        return this.cmpn(num) <= 0;
      };
      /**
       * @param {!Object} value
       * @return {?}
       */
      BN.prototype.lte = function(value) {
        return this.cmp(value) <= 0;
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.eqn = function(num) {
        return 0 === this.cmpn(num);
      };
      /**
       * @param {!Object} value
       * @return {?}
       */
      BN.prototype.eq = function(value) {
        return 0 === this.cmp(value);
      };
      /**
       * @param {?} num
       * @return {?}
       */
      BN.red = function(num) {
        return new Red(num);
      };
      /**
       * @param {!Function} ctx
       * @return {?}
       */
      BN.prototype.toRed = function(ctx) {
        return assert(!this.red, "Already a number in reduction context"), assert(0 === this.negative, "red works only with positives"), ctx.convertTo(this)._forceRed(ctx);
      };
      /**
       * @return {?}
       */
      BN.prototype.fromRed = function() {
        return assert(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      };
      /**
       * @param {number} ctx
       * @return {?}
       */
      BN.prototype._forceRed = function(ctx) {
        return this.red = ctx, this;
      };
      /**
       * @param {undefined} ctx
       * @return {?}
       */
      BN.prototype.forceRed = function(ctx) {
        return assert(!this.red, "Already a number in reduction context"), this._forceRed(ctx);
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.redAdd = function(num) {
        return assert(this.red, "redAdd works only with red numbers"), this.red.add(this, num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.redIAdd = function(num) {
        return assert(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.redSub = function(num) {
        return assert(this.red, "redSub works only with red numbers"), this.red.sub(this, num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.redISub = function(num) {
        return assert(this.red, "redISub works only with red numbers"), this.red.isub(this, num);
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.redShl = function(num) {
        return assert(this.red, "redShl works only with red numbers"), this.red.shl(this, num);
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      BN.prototype.redMul = function(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.mul(this, num);
      };
      /**
       * @param {undefined} num
       * @return {?}
       */
      BN.prototype.redIMul = function(num) {
        return assert(this.red, "redMul works only with red numbers"), this.red._verify2(this, num), this.red.imul(this, num);
      };
      /**
       * @return {?}
       */
      BN.prototype.redSqr = function() {
        return assert(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      };
      /**
       * @return {?}
       */
      BN.prototype.redISqr = function() {
        return assert(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      };
      /**
       * @return {?}
       */
      BN.prototype.redSqrt = function() {
        return assert(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      };
      /**
       * @return {?}
       */
      BN.prototype.redInvm = function() {
        return assert(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      };
      /**
       * @return {?}
       */
      BN.prototype.redNeg = function() {
        return assert(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      };
      /**
       * @param {string} num
       * @return {?}
       */
      BN.prototype.redPow = function(num) {
        return assert(this.red && !num.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, num);
      };
      var primes = {
        k256 : null,
        p224 : null,
        p192 : null,
        p25519 : null
      };
      /**
       * @return {?}
       */
      MPrime.prototype._tmp = function() {
        var c = new BN(null);
        return c.words = new Array(Math.ceil(this.n / 13)), c;
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      MPrime.prototype.ireduce = function(num) {
        var rlen;
        /** @type {!Object} */
        var r = num;
        do {
          this.split(r, this.tmp);
          rlen = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength();
        } while (rlen > this.n);
        var n = rlen < this.n ? -1 : r.ucmp(this.p);
        return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : r.strip(), r;
      };
      /**
       * @param {!Object} input
       * @param {!Object} out
       * @return {undefined}
       */
      MPrime.prototype.split = function(input, out) {
        input.iushrn(this.n, 0, out);
      };
      /**
       * @param {?} num
       * @return {?}
       */
      MPrime.prototype.imulK = function(num) {
        return num.imul(this.k);
      };
      inherits(K256, MPrime);
      /**
       * @param {!Object} arr
       * @param {!Object} options
       * @return {?}
       */
      K256.prototype.split = function(arr, options) {
        /** @type {number} */
        var num = Math.min(arr.length, 9);
        /** @type {number} */
        var i = 0;
        for (; i < num; i++) {
          options.words[i] = arr.words[i];
        }
        if (options.length = num, arr.length <= 9) {
          return arr.words[0] = 0, void(arr.length = 1);
        }
        var offset = arr.words[9];
        /** @type {number} */
        options.words[options.length++] = 4194303 & offset;
        /** @type {number} */
        i = 10;
        for (; i < arr.length; i++) {
          /** @type {number} */
          var dirtyOffset = 0 | arr.words[i];
          /** @type {number} */
          arr.words[i - 10] = (4194303 & dirtyOffset) << 4 | offset >>> 22;
          /** @type {number} */
          offset = dirtyOffset;
        }
        /** @type {number} */
        offset = offset >>> 22;
        arr.words[i - 10] = offset;
        if (0 === offset && arr.length > 10) {
          arr.length -= 10;
        } else {
          arr.length -= 9;
        }
      };
      /**
       * @param {!Object} num
       * @return {?}
       */
      K256.prototype.imulK = function(num) {
        /** @type {number} */
        num.words[num.length] = 0;
        /** @type {number} */
        num.words[num.length + 1] = 0;
        num.length += 2;
        /** @type {number} */
        var maxN = 0;
        /** @type {number} */
        var i = 0;
        for (; i < num.length; i++) {
          /** @type {number} */
          var inc = 0 | num.words[i];
          /** @type {number} */
          maxN = maxN + 977 * inc;
          /** @type {number} */
          num.words[i] = 67108863 & maxN;
          /** @type {number} */
          maxN = 64 * inc + (maxN / 67108864 | 0);
        }
        return 0 === num.words[num.length - 1] && (num.length--, 0 === num.words[num.length - 1] && num.length--), num;
      };
      inherits(P224, MPrime);
      inherits(P192, MPrime);
      inherits(P25519, MPrime);
      /**
       * @param {!Object} num
       * @return {?}
       */
      P25519.prototype.imulK = function(num) {
        /** @type {number} */
        var offsetTop = 0;
        /** @type {number} */
        var i = 0;
        for (; i < num.length; i++) {
          /** @type {number} */
          var offset = 19 * (0 | num.words[i]) + offsetTop;
          /** @type {number} */
          var objectiveF = 67108863 & offset;
          /** @type {number} */
          offset = offset >>> 26;
          /** @type {number} */
          num.words[i] = objectiveF;
          /** @type {number} */
          offsetTop = offset;
        }
        return 0 !== offsetTop && (num.words[num.length++] = offsetTop), num;
      };
      /**
       * @param {!Object} name
       * @return {?}
       */
      BN._prime = function(name) {
        if (primes[name]) {
          return primes[name];
        }
        var prime;
        if ("k256" === name) {
          prime = new K256;
        } else {
          if ("p224" === name) {
            prime = new P224;
          } else {
            if ("p192" === name) {
              prime = new P192;
            } else {
              if ("p25519" !== name) {
                throw new Error("Unknown prime " + name);
              }
              prime = new P25519;
            }
          }
        }
        return primes[name] = prime, prime;
      };
      /**
       * @param {!Object} a
       * @return {undefined}
       */
      Red.prototype._verify1 = function(a) {
        assert(0 === a.negative, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      /**
       * @param {!Object} a
       * @param {!Object} b
       * @return {undefined}
       */
      Red.prototype._verify2 = function(a, b) {
        assert(0 === (a.negative | b.negative), "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      /**
       * @param {!Object} a
       * @return {?}
       */
      Red.prototype.imod = function(a) {
        return this.prime ? this.prime.ireduce(a)._forceRed(this) : a.umod(this.m)._forceRed(this);
      };
      /**
       * @param {?} a
       * @return {?}
       */
      Red.prototype.neg = function(a) {
        return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
      };
      /**
       * @param {!Object} a
       * @param {!Object} b
       * @return {?}
       */
      Red.prototype.add = function(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        return res.cmp(this.m) >= 0 && res.isub(this.m), res._forceRed(this);
      };
      /**
       * @param {!Object} a
       * @param {!Object} b
       * @return {?}
       */
      Red.prototype.iadd = function(a, b) {
        this._verify2(a, b);
        var r = a.iadd(b);
        return r.cmp(this.m) >= 0 && r.isub(this.m), r;
      };
      /**
       * @param {!Object} a
       * @param {!Object} b
       * @return {?}
       */
      Red.prototype.sub = function(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        return res.cmpn(0) < 0 && res.iadd(this.m), res._forceRed(this);
      };
      /**
       * @param {!Object} a
       * @param {!Object} b
       * @return {?}
       */
      Red.prototype.isub = function(a, b) {
        this._verify2(a, b);
        var r = a.isub(b);
        return r.cmpn(0) < 0 && r.iadd(this.m), r;
      };
      /**
       * @param {!Object} a
       * @param {number} num
       * @return {?}
       */
      Red.prototype.shl = function(a, num) {
        return this._verify1(a), this.imod(a.ushln(num));
      };
      /**
       * @param {number} a
       * @param {number} b
       * @return {?}
       */
      Red.prototype.imul = function(a, b) {
        return this._verify2(a, b), this.imod(a.imul(b));
      };
      /**
       * @param {?} a
       * @param {!Array} b
       * @return {?}
       */
      Red.prototype.mul = function(a, b) {
        return this._verify2(a, b), this.imod(a.mul(b));
      };
      /**
       * @param {!Array} a
       * @return {?}
       */
      Red.prototype.isqr = function(a) {
        return this.imul(a, a.clone());
      };
      /**
       * @param {!Array} a
       * @return {?}
       */
      Red.prototype.sqr = function(a) {
        return this.mul(a, a);
      };
      /**
       * @param {?} a
       * @return {?}
       */
      Red.prototype.sqrt = function(a) {
        if (a.isZero()) {
          return a.clone();
        }
        var node = this.m.andln(3);
        if (assert(node % 2 === 1), 3 === node) {
          var lpow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, lpow);
        }
        var q = this.m.subn(1);
        /** @type {number} */
        var listHeight = 0;
        for (; !q.isZero() && 0 === q.andln(1);) {
          listHeight++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = (new BN(1)).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = (new BN(2 * z * z)).toRed(this);
        for (; 0 !== this.pow(z, lpow).cmp(nOne);) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        /** @type {number} */
        var clientHeight = listHeight;
        for (; 0 !== t.cmp(one);) {
          var tmp = t;
          /** @type {number} */
          var targetOffsetHeight = 0;
          for (; 0 !== tmp.cmp(one); targetOffsetHeight++) {
            tmp = tmp.redSqr();
          }
          assert(targetOffsetHeight < clientHeight);
          var b = this.pow(c, (new BN(1)).iushln(clientHeight - targetOffsetHeight - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          /** @type {number} */
          clientHeight = targetOffsetHeight;
        }
        return r;
      };
      /**
       * @param {?} a
       * @return {?}
       */
      Red.prototype.invm = function(a) {
        var inv = a._invmp(this.m);
        return 0 !== inv.negative ? (inv.negative = 0, this.imod(inv).redNeg()) : this.imod(inv);
      };
      /**
       * @param {?} a
       * @param {number} num
       * @return {?}
       */
      Red.prototype.pow = function(a, num) {
        if (num.isZero()) {
          return (new BN(1)).toRed(this);
        }
        if (0 === num.cmpn(1)) {
          return a.clone();
        }
        /** @type {!Array} */
        var wnd = new Array(16);
        wnd[0] = (new BN(1)).toRed(this);
        wnd[1] = a;
        /** @type {number} */
        var i = 2;
        for (; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        /** @type {number} */
        var current = 0;
        /** @type {number} */
        var s = 0;
        /** @type {number} */
        var BOARD_ROWS = num.bitLength() % 26;
        if (0 === BOARD_ROWS) {
          /** @type {number} */
          BOARD_ROWS = 26;
        }
        /** @type {number} */
        i = num.length - 1;
        for (; i >= 0; i--) {
          var k = num.words[i];
          /** @type {number} */
          var j = BOARD_ROWS - 1;
          for (; j >= 0; j--) {
            /** @type {number} */
            var currentBit = k >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (0 !== currentBit || 0 !== current) {
              /** @type {number} */
              current = current << 1;
              /** @type {number} */
              current = current | currentBit;
              if (4 === ++s || 0 === i && 0 === j) {
                res = this.mul(res, wnd[current]);
                /** @type {number} */
                s = 0;
                /** @type {number} */
                current = 0;
              }
            } else {
              /** @type {number} */
              s = 0;
            }
          }
          /** @type {number} */
          BOARD_ROWS = 26;
        }
        return res;
      };
      /**
       * @param {?} num
       * @return {?}
       */
      Red.prototype.convertTo = function(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      /**
       * @param {?} value
       * @return {?}
       */
      Red.prototype.convertFrom = function(value) {
        var justUserEntry = value.clone();
        return justUserEntry.red = null, justUserEntry;
      };
      /**
       * @param {string} num
       * @return {?}
       */
      BN.mont = function(num) {
        return new Mont(num);
      };
      inherits(Mont, Red);
      /**
       * @param {?} num
       * @return {?}
       */
      Mont.prototype.convertTo = function(num) {
        return this.imod(num.ushln(this.shift));
      };
      /**
       * @param {?} num
       * @return {?}
       */
      Mont.prototype.convertFrom = function(num) {
        var r = this.imod(num.mul(this.rinv));
        return r.red = null, r;
      };
      /**
       * @param {number} a
       * @param {number} b
       * @return {?}
       */
      Mont.prototype.imul = function(a, b) {
        if (a.isZero() || b.isZero()) {
          return a.words[0] = 0, a.length = 1, a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);
      };
      /**
       * @param {?} x
       * @param {?} a
       * @return {?}
       */
      Mont.prototype.mul = function(x, a) {
        if (x.isZero() || a.isZero()) {
          return (new BN(0))._forceRed(this);
        }
        var t = x.mul(a);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        return u.cmp(this.m) >= 0 ? res = u.isub(this.m) : u.cmpn(0) < 0 && (res = u.iadd(this.m)), res._forceRed(this);
      };
      /**
       * @param {?} a
       * @return {?}
       */
      Mont.prototype.invm = function(a) {
        return this.imod(a._invmp(this.m).mul(this.r2))._forceRed(this);
      };
    }(moduleTransport, this);
  }).call(this, require(87)(e));
}, function(module, canCreateDiscussions) {
  var g;
  g = function() {
    return this;
  }();
  try {
    g = g || (new Function("return this"))();
  } catch (n) {
    if ("object" === typeof window) {
      /** @type {!Window} */
      g = window;
    }
  }
  module.exports = g;
}, function(module, canCreateDiscussions) {
  /**
   * @param {string} key
   * @param {string} text
   * @return {undefined}
   */
  function test(key, text) {
    if (!key) {
      throw new Error(text || "Assertion failed");
    }
  }
  /** @type {function(string, string): undefined} */
  module.exports = test;
  /**
   * @param {number} a
   * @param {number} b
   * @param {string} msg
   * @return {undefined}
   */
  test.equal = function(a, b, msg) {
    if (a != b) {
      throw new Error(msg || "Assertion failed: " + a + " != " + b);
    }
  };
}, function(canCreateDiscussions, psView, require) {
  /** @type {!Object} */
  var self = psView;
  var BN = require(4);
  var assert = require(6);
  var msg = require(89);
  self.assert = assert;
  self.toArray = msg.toArray;
  self.zero2 = msg.zero2;
  self.toHex = msg.toHex;
  self.encode = msg.encode;
  /**
   * @param {?} n
   * @param {number} op
   * @param {undefined} left
   * @return {?}
   */
  self.getNAF = function(n, op, left) {
    /** @type {!Array} */
    var s = new Array(Math.max(n.bitLength(), left) + 1);
    s.fill(0);
    /** @type {number} */
    var lowColor = 1 << op + 1;
    var num = n.clone();
    /** @type {number} */
    var i = 0;
    for (; i < s.length; i++) {
      var value;
      var r = num.andln(lowColor - 1);
      if (num.isOdd()) {
        value = r > (lowColor >> 1) - 1 ? (lowColor >> 1) - r : r;
        num.isubn(value);
      } else {
        /** @type {number} */
        value = 0;
      }
      s[i] = value;
      num.iushrn(1);
    }
    return s;
  };
  /**
   * @param {string} num
   * @param {string} target
   * @return {?}
   */
  self.getJSF = function(num, target) {
    /** @type {!Array} */
    var allAttachPoints = [[], []];
    num = num.clone();
    target = target.clone();
    /** @type {number} */
    var nump = 0;
    /** @type {number} */
    var value = 0;
    for (; num.cmpn(-nump) > 0 || target.cmpn(-value) > 0;) {
      var min;
      var a;
      var s;
      /** @type {number} */
      var west = num.andln(3) + nump & 3;
      /** @type {number} */
      var previous = target.andln(3) + value & 3;
      if (3 === west && (west = -1), 3 === previous && (previous = -1), 0 === (1 & west)) {
        /** @type {number} */
        min = 0;
      } else {
        /** @type {number} */
        min = 3 !== (s = num.andln(7) + nump & 7) && 5 !== s || 2 !== previous ? west : -west;
      }
      if (allAttachPoints[0].push(min), 0 === (1 & previous)) {
        /** @type {number} */
        a = 0;
      } else {
        /** @type {number} */
        a = 3 !== (s = target.andln(7) + value & 7) && 5 !== s || 2 !== west ? previous : -previous;
      }
      allAttachPoints[1].push(a);
      if (2 * nump === min + 1) {
        /** @type {number} */
        nump = 1 - nump;
      }
      if (2 * value === a + 1) {
        /** @type {number} */
        value = 1 - value;
      }
      num.iushrn(1);
      target.iushrn(1);
    }
    return allAttachPoints;
  };
  /**
   * @param {!Function} type
   * @param {string} key
   * @param {!Function} name
   * @return {undefined}
   */
  self.cachedProperty = function(type, key, name) {
    /** @type {string} */
    var prop = "_" + key;
    /**
     * @return {?}
     */
    type.prototype[key] = function() {
      return void 0 !== this[prop] ? this[prop] : this[prop] = name.call(this);
    };
  };
  /**
   * @param {boolean} value
   * @return {?}
   */
  self.parseBytes = function(value) {
    return "string" === typeof value ? self.toArray(value, "hex") : value;
  };
  /**
   * @param {string} n
   * @return {?}
   */
  self.intFromLE = function(n) {
    return new BN(n, "hex", "le");
  };
}, function(mixin, canCreateDiscussions) {
  /**
   * @return {?}
   */
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  /**
   * @return {?}
   */
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  /**
   * @param {!Function} fun
   * @return {?}
   */
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      return cachedSetTimeout = setTimeout, setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (t) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (t) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  /**
   * @return {undefined}
   */
  function cleanUpNextTick() {
    if (file && currentQueue) {
      /** @type {boolean} */
      file = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        /** @type {number} */
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
  }
  /**
   * @return {undefined}
   */
  function drainQueue() {
    if (!file) {
      var timeout = runTimeout(cleanUpNextTick);
      /** @type {boolean} */
      file = true;
      var len = queue.length;
      for (; len;) {
        currentQueue = queue;
        /** @type {!Array} */
        queue = [];
        for (; ++queueIndex < len;) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        /** @type {number} */
        queueIndex = -1;
        /** @type {number} */
        len = queue.length;
      }
      /** @type {null} */
      currentQueue = null;
      /** @type {boolean} */
      file = false;
      (function(marker) {
        if (cachedClearTimeout === clearTimeout) {
          return clearTimeout(marker);
        }
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          return cachedClearTimeout = clearTimeout, clearTimeout(marker);
        }
        try {
          cachedClearTimeout(marker);
        } catch (t) {
          try {
            return cachedClearTimeout.call(null, marker);
          } catch (t) {
            return cachedClearTimeout.call(this, marker);
          }
        }
      })(timeout);
    }
  }
  /**
   * @param {(Object|string)} fun
   * @param {!Array} array
   * @return {undefined}
   */
  function Item(fun, array) {
    /** @type {(Object|string)} */
    this.fun = fun;
    /** @type {!Array} */
    this.array = array;
  }
  /**
   * @return {undefined}
   */
  function noop() {
  }
  var cachedSetTimeout;
  var cachedClearTimeout;
  var process = mixin.exports = {};
  !function() {
    try {
      /** @type {!Function} */
      cachedSetTimeout = "function" === typeof setTimeout ? setTimeout : defaultSetTimout;
    } catch (e) {
      /** @type {function(): ?} */
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      /** @type {!Function} */
      cachedClearTimeout = "function" === typeof clearTimeout ? clearTimeout : defaultClearTimeout;
    } catch (e) {
      /** @type {function(): ?} */
      cachedClearTimeout = defaultClearTimeout;
    }
  }();
  var currentQueue;
  /** @type {!Array} */
  var queue = [];
  /** @type {boolean} */
  var file = false;
  /** @type {number} */
  var queueIndex = -1;
  /**
   * @param {!Function} callback
   * @return {undefined}
   */
  process.nextTick = function(callback) {
    /** @type {!Array} */
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      /** @type {number} */
      var i = 1;
      for (; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(callback, args));
    if (!(1 !== queue.length || file)) {
      runTimeout(drainQueue);
    }
  };
  /**
   * @return {undefined}
   */
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  /** @type {string} */
  process.title = "browser";
  /** @type {boolean} */
  process.browser = true;
  process.env = {};
  /** @type {!Array} */
  process.argv = [];
  /** @type {string} */
  process.version = "";
  process.versions = {};
  /** @type {function(): undefined} */
  process.on = noop;
  /** @type {function(): undefined} */
  process.addListener = noop;
  /** @type {function(): undefined} */
  process.once = noop;
  /** @type {function(): undefined} */
  process.off = noop;
  /** @type {function(): undefined} */
  process.removeListener = noop;
  /** @type {function(): undefined} */
  process.removeAllListeners = noop;
  /** @type {function(): undefined} */
  process.emit = noop;
  /** @type {function(): undefined} */
  process.prependListener = noop;
  /** @type {function(): undefined} */
  process.prependOnceListener = noop;
  /**
   * @param {string} type
   * @return {?}
   */
  process.listeners = function(type) {
    return [];
  };
  /**
   * @param {?} name
   * @return {?}
   */
  process.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  /**
   * @return {?}
   */
  process.cwd = function() {
    return "/";
  };
  /**
   * @param {?} dir
   * @return {?}
   */
  process.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  /**
   * @return {?}
   */
  process.umask = function() {
    return 0;
  };
}, function(canCreateDiscussions, exports, require) {
  /**
   * @param {string} line
   * @param {number} i
   * @return {?}
   */
  function init(line, i) {
    return 55296 === (64512 & line.charCodeAt(i)) && (!(i < 0 || i + 1 >= line.length) && 56320 === (64512 & line.charCodeAt(i + 1)));
  }
  /**
   * @param {number} data
   * @return {?}
   */
  function formatDatesByMonth(data) {
    return (data >>> 24 | data >>> 8 & 65280 | data << 8 & 16711680 | (255 & data) << 24) >>> 0;
  }
  /**
   * @param {string} errorText
   * @return {?}
   */
  function encode(errorText) {
    return 1 === errorText.length ? "0" + errorText : errorText;
  }
  /**
   * @param {string} options
   * @return {?}
   */
  function Number(options) {
    return 7 === options.length ? "0" + options : 6 === options.length ? "00" + options : 5 === options.length ? "000" + options : 4 === options.length ? "0000" + options : 3 === options.length ? "00000" + options : 2 === options.length ? "000000" + options : 1 === options.length ? "0000000" + options : options;
  }
  var whenDOMReady = require(6);
  var inherits = require(1);
  exports.inherits = inherits;
  /**
   * @param {string} data
   * @param {string} length
   * @return {?}
   */
  exports.toArray = function(data, length) {
    if (Array.isArray(data)) {
      return data.slice();
    }
    if (!data) {
      return [];
    }
    /** @type {!Array} */
    var r = [];
    if ("string" === typeof data) {
      if (length) {
        if ("hex" === length) {
          if ((data = data.replace(/[^a-z0-9]+/gi, "")).length % 2 !== 0) {
            /** @type {string} */
            data = "0" + data;
          }
          /** @type {number} */
          i = 0;
          for (; i < data.length; i = i + 2) {
            r.push(parseInt(data[i] + data[i + 1], 16));
          }
        }
      } else {
        /** @type {number} */
        var u = 0;
        /** @type {number} */
        var i = 0;
        for (; i < data.length; i++) {
          /** @type {number} */
          var item = data.charCodeAt(i);
          if (item < 128) {
            /** @type {number} */
            r[u++] = item;
          } else {
            if (item < 2048) {
              /** @type {number} */
              r[u++] = item >> 6 | 192;
              /** @type {number} */
              r[u++] = 63 & item | 128;
            } else {
              if (init(data, i)) {
                /** @type {number} */
                item = 65536 + ((1023 & item) << 10) + (1023 & data.charCodeAt(++i));
                /** @type {number} */
                r[u++] = item >> 18 | 240;
                /** @type {number} */
                r[u++] = item >> 12 & 63 | 128;
                /** @type {number} */
                r[u++] = item >> 6 & 63 | 128;
                /** @type {number} */
                r[u++] = 63 & item | 128;
              } else {
                /** @type {number} */
                r[u++] = item >> 12 | 224;
                /** @type {number} */
                r[u++] = item >> 6 & 63 | 128;
                /** @type {number} */
                r[u++] = 63 & item | 128;
              }
            }
          }
        }
      }
    } else {
      /** @type {number} */
      i = 0;
      for (; i < data.length; i++) {
        /** @type {number} */
        r[i] = 0 | data[i];
      }
    }
    return r;
  };
  /**
   * @param {!Array} num
   * @return {?}
   */
  exports.toHex = function(num) {
    /** @type {string} */
    var output = "";
    /** @type {number} */
    var offset = 0;
    for (; offset < num.length; offset++) {
      /** @type {string} */
      output = output + encode(num[offset].toString(16));
    }
    return output;
  };
  /** @type {function(number): ?} */
  exports.htonl = formatDatesByMonth;
  /**
   * @param {!NodeList} e
   * @param {string} size
   * @return {?}
   */
  exports.toHex32 = function(e, size) {
    /** @type {string} */
    var pending = "";
    /** @type {number} */
    var g = 0;
    for (; g < e.length; g++) {
      var i = e[g];
      if ("little" === size) {
        i = formatDatesByMonth(i);
      }
      /** @type {string} */
      pending = pending + Number(i.toString(16));
    }
    return pending;
  };
  /** @type {function(string): ?} */
  exports.zero2 = encode;
  /** @type {function(string): ?} */
  exports.zero8 = Number;
  /**
   * @param {!Function} result
   * @param {number} i
   * @param {number} x
   * @param {string} miniBatchSize
   * @return {?}
   */
  exports.join32 = function(result, i, x, miniBatchSize) {
    /** @type {number} */
    var l = x - i;
    whenDOMReady(l % 4 === 0);
    /** @type {!Array} */
    var strSeparatorArray = new Array(l / 4);
    /** @type {number} */
    var intElementNr = 0;
    /** @type {number} */
    var j = i;
    for (; intElementNr < strSeparatorArray.length; intElementNr++, j = j + 4) {
      var integer;
      /** @type {number} */
      integer = "big" === miniBatchSize ? result[j] << 24 | result[j + 1] << 16 | result[j + 2] << 8 | result[j + 3] : result[j + 3] << 24 | result[j + 2] << 16 | result[j + 1] << 8 | result[j];
      /** @type {number} */
      strSeparatorArray[intElementNr] = integer >>> 0;
    }
    return strSeparatorArray;
  };
  /**
   * @param {!NodeList} attrs
   * @param {string} endianess
   * @return {?}
   */
  exports.split32 = function(attrs, endianess) {
    /** @type {!Array} */
    var parts = new Array(4 * attrs.length);
    /** @type {number} */
    var j = 0;
    /** @type {number} */
    var i = 0;
    for (; j < attrs.length; j++, i = i + 4) {
      var mask = attrs[j];
      if ("big" === endianess) {
        /** @type {number} */
        parts[i] = mask >>> 24;
        /** @type {number} */
        parts[i + 1] = mask >>> 16 & 255;
        /** @type {number} */
        parts[i + 2] = mask >>> 8 & 255;
        /** @type {number} */
        parts[i + 3] = 255 & mask;
      } else {
        /** @type {number} */
        parts[i + 3] = mask >>> 24;
        /** @type {number} */
        parts[i + 2] = mask >>> 16 & 255;
        /** @type {number} */
        parts[i + 1] = mask >>> 8 & 255;
        /** @type {number} */
        parts[i] = 255 & mask;
      }
    }
    return parts;
  };
  /**
   * @param {number} x
   * @param {number} n
   * @return {?}
   */
  exports.rotr32 = function(x, n) {
    return x >>> n | x << 32 - n;
  };
  /**
   * @param {number} number
   * @param {number} bits
   * @return {?}
   */
  exports.rotl32 = function(number, bits) {
    return number << bits | number >>> 32 - bits;
  };
  /**
   * @param {(Object|number)} target
   * @param {!Object} value
   * @return {?}
   */
  exports.sum32 = function(target, value) {
    return target + value >>> 0;
  };
  /**
   * @param {(Object|number)} img
   * @param {!Object} type
   * @param {?} key
   * @return {?}
   */
  exports.sum32_3 = function(img, type, key) {
    return img + type + key >>> 0;
  };
  /**
   * @param {(Object|number)} y
   * @param {!Object} h
   * @param {?} r
   * @param {?} g
   * @return {?}
   */
  exports.sum32_4 = function(y, h, r, g) {
    return y + h + r + g >>> 0;
  };
  /**
   * @param {(Object|number)} prefix
   * @param {!Object} name
   * @param {?} m
   * @param {?} n
   * @param {?} s
   * @return {?}
   */
  exports.sum32_5 = function(prefix, name, m, n, s) {
    return prefix + name + m + n + s >>> 0;
  };
  /**
   * @param {!NodeList} buffer
   * @param {number} offset
   * @param {number} id
   * @param {number} x
   * @return {undefined}
   */
  exports.sum64 = function(buffer, offset, id, x) {
    var name = buffer[offset];
    /** @type {number} */
    var y = x + buffer[offset + 1] >>> 0;
    var value = (y < x ? 1 : 0) + id + name;
    /** @type {number} */
    buffer[offset] = value >>> 0;
    /** @type {number} */
    buffer[offset + 1] = y;
  };
  /**
   * @param {number} url
   * @param {number} str
   * @param {?} value
   * @param {number} text
   * @return {?}
   */
  exports.sum64_hi = function(url, str, value, text) {
    return (str + text >>> 0 < str ? 1 : 0) + url + value >>> 0;
  };
  /**
   * @param {?} reg
   * @param {(Object|number)} val
   * @param {?} msg
   * @param {!Object} k
   * @return {?}
   */
  exports.sum64_lo = function(reg, val, msg, k) {
    return val + k >>> 0;
  };
  /**
   * @param {(Object|number)} f
   * @param {number} k
   * @param {!Object} n
   * @param {?} v
   * @param {?} i
   * @param {number} value
   * @param {?} _
   * @param {number} s
   * @return {?}
   */
  exports.sum64_4_hi = function(f, k, n, v, i, value, _, s) {
    /** @type {number} */
    var dataIdCounter = 0;
    /** @type {number} */
    var x = k;
    return dataIdCounter = dataIdCounter + ((x = x + v >>> 0) < k ? 1 : 0), dataIdCounter = dataIdCounter + ((x = x + value >>> 0) < value ? 1 : 0), f + n + i + _ + (dataIdCounter = dataIdCounter + ((x = x + s >>> 0) < s ? 1 : 0)) >>> 0;
  };
  /**
   * @param {?} instance
   * @param {(Object|number)} type
   * @param {?} _
   * @param {!Object} dir
   * @param {?} port
   * @param {?} index
   * @param {?} action
   * @param {?} value
   * @return {?}
   */
  exports.sum64_4_lo = function(instance, type, _, dir, port, index, action, value) {
    return type + dir + index + value >>> 0;
  };
  /**
   * @param {(Object|number)} name
   * @param {number} length
   * @param {!Object} k
   * @param {?} v
   * @param {?} _
   * @param {number} l
   * @param {?} a
   * @param {number} n
   * @param {?} d
   * @param {number} x
   * @return {?}
   */
  exports.sum64_5_hi = function(name, length, k, v, _, l, a, n, d, x) {
    /** @type {number} */
    var s = 0;
    /** @type {number} */
    var i = length;
    return s = s + ((i = i + v >>> 0) < length ? 1 : 0), s = s + ((i = i + l >>> 0) < l ? 1 : 0), s = s + ((i = i + n >>> 0) < n ? 1 : 0), name + k + _ + a + d + (s = s + ((i = i + x >>> 0) < x ? 1 : 0)) >>> 0;
  };
  /**
   * @param {?} tagName
   * @param {(Object|number)} str
   * @param {?} date
   * @param {!Object} n
   * @param {?} result
   * @param {?} i
   * @param {?} username
   * @param {?} _
   * @param {?} text
   * @param {?} status
   * @return {?}
   */
  exports.sum64_5_lo = function(tagName, str, date, n, result, i, username, _, text, status) {
    return str + n + i + _ + status >>> 0;
  };
  /**
   * @param {number} string
   * @param {number} x
   * @param {number} y
   * @return {?}
   */
  exports.rotr64_hi = function(string, x, y) {
    return (x << 32 - y | string >>> y) >>> 0;
  };
  /**
   * @param {number} x
   * @param {number} X
   * @param {number} n
   * @return {?}
   */
  exports.rotr64_lo = function(x, X, n) {
    return (x << 32 - n | X >>> n) >>> 0;
  };
  /**
   * @param {number} b
   * @param {!Object} string
   * @param {number} s
   * @return {?}
   */
  exports.shr64_hi = function(b, string, s) {
    return b >>> s;
  };
  /**
   * @param {number} n
   * @param {number} a
   * @param {number} b
   * @return {?}
   */
  exports.shr64_lo = function(n, a, b) {
    return (n << 32 - b | a >>> b) >>> 0;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function CipherBase(key) {
    transformer.call(this);
    /** @type {boolean} */
    this.hashMode = "string" === typeof key;
    if (this.hashMode) {
      this[key] = this._finalOrDigest;
    } else {
      this.final = this._finalOrDigest;
    }
    if (this._final) {
      this.__final = this._final;
      /** @type {null} */
      this._final = null;
    }
    /** @type {null} */
    this._decoder = null;
    /** @type {null} */
    this._encoding = null;
  }
  var Buffer = require(2).Buffer;
  var transformer = require(38).Transform;
  var StringDecoder = require(42).StringDecoder;
  require(1)(CipherBase, transformer);
  /**
   * @param {?} data
   * @param {!Array} type
   * @param {string} outputEnc
   * @return {?}
   */
  CipherBase.prototype.update = function(data, type, outputEnc) {
    if ("string" === typeof data) {
      data = Buffer.from(data, type);
    }
    var outData = this._update(data);
    return this.hashMode ? this : (outputEnc && (outData = this._toString(outData, outputEnc)), outData);
  };
  /**
   * @return {undefined}
   */
  CipherBase.prototype.setAutoPadding = function() {
  };
  /**
   * @return {?}
   */
  CipherBase.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  };
  /**
   * @return {?}
   */
  CipherBase.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  };
  /**
   * @return {?}
   */
  CipherBase.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  };
  /**
   * @param {!Array} data
   * @param {!Array} _
   * @param {!Array} cb
   * @return {undefined}
   */
  CipherBase.prototype._transform = function(data, _, cb) {
    var n;
    try {
      if (this.hashMode) {
        this._update(data);
      } else {
        this.push(this._update(data));
      }
    } catch (numInternals) {
      n = numInternals;
    } finally {
      cb(n);
    }
  };
  /**
   * @param {!Function} cb
   * @return {undefined}
   */
  CipherBase.prototype._flush = function(cb) {
    var wsFunction;
    try {
      this.push(this.__final());
    } catch (local_mobile_core_user_remove_user_device) {
      wsFunction = local_mobile_core_user_remove_user_device;
    }
    cb(wsFunction);
  };
  /**
   * @param {!Function} outputEnc
   * @return {?}
   */
  CipherBase.prototype._finalOrDigest = function(outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);
    return outputEnc && (outData = this._toString(outData, outputEnc, true)), outData;
  };
  /**
   * @param {undefined} data
   * @param {string} enc
   * @param {boolean} options
   * @return {?}
   */
  CipherBase.prototype._toString = function(data, enc, options) {
    if (this._decoder || (this._decoder = new StringDecoder(enc), this._encoding = enc), this._encoding !== enc) {
      throw new Error("can't switch encodings");
    }
    var tmp = this._decoder.write(data);
    return options && (tmp = tmp + this._decoder.end()), tmp;
  };
  /** @type {function(string): undefined} */
  module.exports = CipherBase;
}, function(canCreateDiscussions, a, r) {
  /**
   * @param {(ArrayBuffer|ArrayBufferView|Blob|string)} options
   * @param {!Function} cb
   * @return {undefined}
   */
  function toDest(options, cb) {
    if (!(options instanceof cb)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  r.d(a, "a", function() {
    return toDest;
  });
}, function(canCreateDiscussions, a, r) {
  /**
   * @param {!Function} d
   * @param {string} props
   * @return {undefined}
   */
  function e(d, props) {
    /** @type {number} */
    var i = 0;
    for (; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      /** @type {boolean} */
      descriptor.configurable = true;
      if ("value" in descriptor) {
        /** @type {boolean} */
        descriptor.writable = true;
      }
      Object.defineProperty(d, descriptor.key, descriptor);
    }
  }
  /**
   * @param {!Function} t
   * @param {!Function} n
   * @param {!Function} a
   * @return {?}
   */
  function right(t, n, a) {
    return n && e(t.prototype, n), a && e(t, a), t;
  }
  r.d(a, "a", function() {
    return right;
  });
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} obj
   * @return {?}
   */
  function Duplex(obj) {
    if (!(this instanceof Duplex)) {
      return new Duplex(obj);
    }
    Event.call(this, obj);
    $.call(this, obj);
    if (obj && false === obj.readable) {
      /** @type {boolean} */
      this.readable = false;
    }
    if (obj && false === obj.writable) {
      /** @type {boolean} */
      this.writable = false;
    }
    /** @type {boolean} */
    this.allowHalfOpen = true;
    if (obj && false === obj.allowHalfOpen) {
      /** @type {boolean} */
      this.allowHalfOpen = false;
    }
    this.once("end", onend);
  }
  /**
   * @return {undefined}
   */
  function onend() {
    if (!(this.allowHalfOpen || this._writableState.ended)) {
      process.nextTick(doNext, this);
    }
  }
  /**
   * @param {!Object} val
   * @return {undefined}
   */
  function doNext(val) {
    val.end();
  }
  var process = require(30);
  /** @type {function(!Object): !Array<string>} */
  var exposeApi = Object.keys || function(obj) {
    /** @type {!Array} */
    var newaxe = [];
    var field;
    for (field in obj) {
      newaxe.push(field);
    }
    return newaxe;
  };
  /** @type {function(!Object): ?} */
  module.exports = Duplex;
  /** @type {!Object} */
  var util = Object.create(require(21));
  util.inherits = require(1);
  var Event = require(66);
  var $ = require(41);
  util.inherits(Duplex, Event);
  /** @type {!Array<string>} */
  var spriteMethods = exposeApi($.prototype);
  /** @type {number} */
  var i = 0;
  for (; i < spriteMethods.length; i++) {
    /** @type {string} */
    var method = spriteMethods[i];
    if (!Duplex.prototype[method]) {
      Duplex.prototype[method] = $.prototype[method];
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable : false,
    get : function() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get : function() {
      return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed);
    },
    set : function(value) {
      if (void 0 !== this._readableState && void 0 !== this._writableState) {
        /** @type {string} */
        this._readableState.destroyed = value;
        /** @type {string} */
        this._writableState.destroyed = value;
      }
    }
  });
  /**
   * @param {string} key
   * @param {(!Function|string)} callback
   * @return {undefined}
   */
  Duplex.prototype._destroy = function(key, callback) {
    this.push(null);
    this.end();
    process.nextTick(callback, key);
  };
}, function(canCreateDiscussions, a, r) {
  /**
   * @param {!Array} notify
   * @return {?}
   */
  function prepare(notify) {
    if (void 0 === notify) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return notify;
  }
  r.d(a, "a", function() {
    return prepare;
  });
}, function(canCreateDiscussions, value, $) {
  /**
   * @param {string} cb
   * @return {?}
   */
  function next(cb) {
    return (next = "function" === typeof Symbol && "symbol" === typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj) {
      return obj && "function" === typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    })(cb);
  }
  /**
   * @param {?} value
   * @param {string} key
   * @return {?}
   */
  function o(value, key) {
    return !key || "object" !== next(key) && "function" !== typeof key ? Object(self.a)(value) : key;
  }
  var self = $(14);
  $.d(value, "a", function() {
    return o;
  });
}, function(mixin, canCreateDiscussions, __webpack_require__) {
  (function(global, $process) {
    var Buffer = __webpack_require__(2).Buffer;
    var _crypto = global.crypto || global.msCrypto;
    if (_crypto && _crypto.getRandomValues) {
      /**
       * @param {string} key
       * @param {string} map
       * @return {?}
       */
      mixin.exports = function(key, map) {
        if (key > 4294967295) {
          throw new RangeError("requested too many random bytes");
        }
        var arr = Buffer.allocUnsafe(key);
        if (key > 0) {
          if (key > 65536) {
            /** @type {number} */
            var i = 0;
            for (; i < key; i = i + 65536) {
              _crypto.getRandomValues(arr.slice(i, i + 65536));
            }
          } else {
            _crypto.getRandomValues(arr);
          }
        }
        if ("function" === typeof map) {
          return $process.nextTick(function() {
            map(null, arr);
          });
        }
        return arr;
      };
    } else {
      /**
       * @return {?}
       */
      mixin.exports = function() {
        throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
      };
    }
  }).call(this, __webpack_require__(5), __webpack_require__(8));
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} value
   * @param {string} object
   * @return {undefined}
   */
  function Hash(value, object) {
    this._block = Buffer.alloc(value);
    /** @type {string} */
    this._finalSize = object;
    /** @type {string} */
    this._blockSize = value;
    /** @type {number} */
    this._len = 0;
  }
  var Buffer = require(2).Buffer;
  /**
   * @param {?} data
   * @param {string} encoding
   * @return {?}
   */
  Hash.prototype.update = function(data, encoding) {
    if ("string" === typeof data) {
      encoding = encoding || "utf8";
      data = Buffer.from(data, encoding);
    }
    var buffer = this._block;
    var height = this._blockSize;
    var bufferLength = data.length;
    var i = this._len;
    /** @type {number} */
    var offset = 0;
    for (; offset < bufferLength;) {
      /** @type {number} */
      var y = i % height;
      /** @type {number} */
      var count = Math.min(bufferLength - offset, height - y);
      /** @type {number} */
      var j = 0;
      for (; j < count; j++) {
        buffer[y + j] = data[offset + j];
      }
      /** @type {number} */
      offset = offset + count;
      if ((i = i + count) % height === 0) {
        this._update(buffer);
      }
    }
    return this._len += bufferLength, this;
  };
  /**
   * @param {?} enc
   * @return {?}
   */
  Hash.prototype.digest = function(enc) {
    /** @type {number} */
    var i = this._len % this._blockSize;
    /** @type {number} */
    this._block[i] = 128;
    this._block.fill(0, i + 1);
    if (i >= this._finalSize) {
      this._update(this._block);
      this._block.fill(0);
    }
    /** @type {number} */
    var l = 8 * this._len;
    if (l <= 4294967295) {
      this._block.writeUInt32BE(l, this._blockSize - 4);
    } else {
      /** @type {number} */
      var i = (4294967295 & l) >>> 0;
      /** @type {number} */
      var object = (l - i) / 4294967296;
      this._block.writeUInt32BE(object, this._blockSize - 8);
      this._block.writeUInt32BE(i, this._blockSize - 4);
    }
    this._update(this._block);
    var r = this._hash();
    return enc ? r.toString(enc) : r;
  };
  /**
   * @return {?}
   */
  Hash.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  };
  /** @type {function(string, string): undefined} */
  module.exports = Hash;
}, , function(mixin, canCreateDiscussions, require) {
  /**
   * @param {string} hash
   * @return {undefined}
   */
  function HashNoConstructor(hash) {
    Base.call(this, "digest");
    /** @type {string} */
    this._hash = hash;
  }
  var inherits = require(1);
  var ElementCreator = require(37);
  var ComponentFileTree = require(43);
  var a = require(44);
  var Base = require(10);
  inherits(HashNoConstructor, Base);
  /**
   * @param {!Array} data
   * @return {undefined}
   */
  HashNoConstructor.prototype._update = function(data) {
    this._hash.update(data);
  };
  /**
   * @return {?}
   */
  HashNoConstructor.prototype._final = function() {
    return this._hash.digest();
  };
  /**
   * @param {string} key
   * @return {?}
   */
  mixin.exports = function(key) {
    return "md5" === (key = key.toLowerCase()) ? new ElementCreator : "rmd160" === key || "ripemd160" === key ? new ComponentFileTree : new HashNoConstructor(a(key));
  };
}, function(block, stream, merge) {
  (stream = block.exports = merge(66)).Stream = stream;
  stream.Readable = stream;
  stream.Writable = merge(41);
  stream.Duplex = merge(13);
  stream.Transform = merge(69);
  stream.PassThrough = merge(126);
}, function(canCreateDiscussions, exports, require) {
  (function(Buffer) {
    /**
     * @param {string} o
     * @return {?}
     */
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    /**
     * @param {string} value
     * @return {?}
     */
    exports.isArray = function(value) {
      return Array.isArray ? Array.isArray(value) : "[object Array]" === objectToString(value);
    };
    /**
     * @param {?} val
     * @return {?}
     */
    exports.isBoolean = function(val) {
      return "boolean" === typeof val;
    };
    /**
     * @param {!Object} val
     * @return {?}
     */
    exports.isNull = function(val) {
      return null === val;
    };
    /**
     * @param {string} val
     * @return {?}
     */
    exports.isNullOrUndefined = function(val) {
      return null == val;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    exports.isNumber = function(value) {
      return "number" === typeof value;
    };
    /**
     * @param {!Object} source
     * @return {?}
     */
    exports.isString = function(source) {
      return "string" === typeof source;
    };
    /**
     * @param {?} propValue
     * @return {?}
     */
    exports.isSymbol = function(propValue) {
      return "symbol" === typeof propValue;
    };
    /**
     * @param {!Array} val
     * @return {?}
     */
    exports.isUndefined = function(val) {
      return void 0 === val;
    };
    /**
     * @param {string} re
     * @return {?}
     */
    exports.isRegExp = function(re) {
      return "[object RegExp]" === objectToString(re);
    };
    /**
     * @param {!Object} value
     * @return {?}
     */
    exports.isObject = function(value) {
      return "object" === typeof value && null !== value;
    };
    /**
     * @param {string} value
     * @return {?}
     */
    exports.isDate = function(value) {
      return "[object Date]" === objectToString(value);
    };
    /**
     * @param {string} obj
     * @return {?}
     */
    exports.isError = function(obj) {
      return "[object Error]" === objectToString(obj) || obj instanceof Error;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    exports.isFunction = function(fn) {
      return "function" === typeof fn;
    };
    /**
     * @param {!Object} value
     * @return {?}
     */
    exports.isPrimitive = function(value) {
      return null === value || "boolean" === typeof value || "number" === typeof value || "string" === typeof value || "symbol" === typeof value || "undefined" === typeof value;
    };
    exports.isBuffer = Buffer.isBuffer;
  }).call(this, require(3).Buffer);
}, function(mixin, canCreateDiscussions, require) {
  (function(F) {
    /**
     * @param {string} value
     * @param {string} state
     * @return {?}
     */
    mixin.exports = function(value, state) {
      /** @type {number} */
      var c2 = Math.min(value.length, state.length);
      var i = new F(c2);
      /** @type {number} */
      var j = 0;
      for (; j < c2; ++j) {
        /** @type {number} */
        i[j] = value[j] ^ state[j];
      }
      return i;
    };
  }).call(this, require(3).Buffer);
}, function(canCreateDiscussions, ownerContext, require) {
  /**
   * @return {undefined}
   */
  function pad() {
    /** @type {null} */
    this.pending = null;
    /** @type {number} */
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    /** @type {number} */
    this.padLength = this.constructor.padLength / 8;
    /** @type {string} */
    this.endian = "big";
    /** @type {number} */
    this._delta8 = this.blockSize / 8;
    /** @type {number} */
    this._delta32 = this.blockSize / 32;
  }
  var utils = require(9);
  var now = require(6);
  /** @type {function(): undefined} */
  ownerContext.BlockHash = pad;
  /**
   * @param {!Object} msg
   * @param {boolean} n
   * @return {?}
   */
  pad.prototype.update = function(msg, n) {
    if (msg = utils.toArray(msg, n), this.pending ? this.pending = this.pending.concat(msg) : this.pending = msg, this.pendingTotal += msg.length, this.pending.length >= this._delta8) {
      /** @type {number} */
      var r = (msg = this.pending).length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (0 === this.pending.length) {
        /** @type {null} */
        this.pending = null;
      }
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      /** @type {number} */
      var i = 0;
      for (; i < msg.length; i = i + this._delta32) {
        this._update(msg, i, i + this._delta32);
      }
    }
    return this;
  };
  /**
   * @param {string} pid_key
   * @return {?}
   */
  pad.prototype.digest = function(pid_key) {
    return this.update(this._pad()), now(null === this.pending), this._digest(pid_key);
  };
  /**
   * @return {?}
   */
  pad.prototype._pad = function() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    /** @type {number} */
    var k = bytes - (len + this.padLength) % bytes;
    /** @type {!Array} */
    var result = new Array(k + this.padLength);
    /** @type {number} */
    result[0] = 128;
    /** @type {number} */
    var j = 1;
    for (; j < k; j++) {
      /** @type {number} */
      result[j] = 0;
    }
    if (len = len << 3, "big" === this.endian) {
      /** @type {number} */
      var t = 8;
      for (; t < this.padLength; t++) {
        /** @type {number} */
        result[j++] = 0;
      }
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = len >>> 24 & 255;
      /** @type {number} */
      result[j++] = len >>> 16 & 255;
      /** @type {number} */
      result[j++] = len >>> 8 & 255;
      /** @type {number} */
      result[j++] = 255 & len;
    } else {
      /** @type {number} */
      result[j++] = 255 & len;
      /** @type {number} */
      result[j++] = len >>> 8 & 255;
      /** @type {number} */
      result[j++] = len >>> 16 & 255;
      /** @type {number} */
      result[j++] = len >>> 24 & 255;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      result[j++] = 0;
      /** @type {number} */
      t = 8;
      for (; t < this.padLength; t++) {
        /** @type {number} */
        result[j++] = 0;
      }
    }
    return result;
  };
}, function(canCreateDiscussions, psView, require) {
  /** @type {!Object} */
  var self = psView;
  self.bignum = require(4);
  self.define = require(179).define;
  self.base = require(25);
  self.constants = require(95);
  self.decoders = require(184);
  self.encoders = require(186);
}, function(isSlidingUp, headB, require) {
  /** @type {!Object} */
  var kityminder = headB;
  kityminder.Reporter = require(181).Reporter;
  kityminder.DecoderBuffer = require(94).DecoderBuffer;
  kityminder.EncoderBuffer = require(94).EncoderBuffer;
  kityminder.Node = require(182);
}, function(canCreateDiscussions, exports, require) {
  /**
   * @return {undefined}
   */
  function Url() {
    /** @type {null} */
    this.protocol = null;
    /** @type {null} */
    this.slashes = null;
    /** @type {null} */
    this.auth = null;
    /** @type {null} */
    this.host = null;
    /** @type {null} */
    this.port = null;
    /** @type {null} */
    this.hostname = null;
    /** @type {null} */
    this.hash = null;
    /** @type {null} */
    this.search = null;
    /** @type {null} */
    this.query = null;
    /** @type {null} */
    this.pathname = null;
    /** @type {null} */
    this.path = null;
    /** @type {null} */
    this.href = null;
  }
  /**
   * @param {string} url
   * @param {boolean} str
   * @param {string} slashesDenoteHost
   * @return {?}
   */
  function urlParse(url, str, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url) {
      return url;
    }
    var u = new Url;
    return u.parse(url, str, slashesDenoteHost), u;
  }
  var punycode = require(202);
  var util = require(203);
  /** @type {function(string, boolean, string): ?} */
  exports.parse = urlParse;
  /**
   * @param {string} url
   * @param {string} relative
   * @return {?}
   */
  exports.resolve = function(url, relative) {
    return urlParse(url, false, true).resolve(relative);
  };
  /**
   * @param {string} source
   * @param {string} key
   * @return {?}
   */
  exports.resolveObject = function(source, key) {
    return source ? urlParse(source, false, true).resolveObject(key) : key;
  };
  /**
   * @param {string} obj
   * @return {?}
   */
  exports.format = function(obj) {
    if (util.isString(obj)) {
      obj = urlParse(obj);
    }
    return obj instanceof Url ? obj.format() : Url.prototype.format.call(obj);
  };
  /** @type {function(): undefined} */
  exports.Url = Url;
  /** @type {!RegExp} */
  var hostPattern = /^([a-z0-9.+-]+:)/i;
  /** @type {!RegExp} */
  var portPattern = /:[0-9]*$/;
  /** @type {!RegExp} */
  var humanMonth = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  /** @type {!Array<?>} */
  var u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]);
  /** @type {!Array<?>} */
  var value = ["'"].concat(u);
  /** @type {!Array<?>} */
  var a = ["%", "/", "?", ";", "#"].concat(value);
  /** @type {!Array} */
  var hostEndingChars = ["/", "?", "#"];
  /** @type {!RegExp} */
  var h = /^[+a-z0-9A-Z_-]{0,63}$/;
  /** @type {!RegExp} */
  var p = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var unsafeProtocol = {
    javascript : true,
    "javascript:" : true
  };
  var hostlessProtocol = {
    javascript : true,
    "javascript:" : true
  };
  var slashedProtocol = {
    http : true,
    https : true,
    ftp : true,
    gopher : true,
    file : true,
    "http:" : true,
    "https:" : true,
    "ftp:" : true,
    "gopher:" : true,
    "file:" : true
  };
  var querystring = require(54);
  /**
   * @param {string} url
   * @param {string} body
   * @param {string} slashesDenoteHost
   * @return {?}
   */
  Url.prototype.parse = function(url, body, slashesDenoteHost) {
    if (!util.isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var colonIndex = url.indexOf("?");
    /** @type {string} */
    var s = -1 !== colonIndex && colonIndex < url.indexOf("#") ? "?" : "#";
    var n = url.split(s);
    n[0] = n[0].replace(/\\/g, "/");
    var rest = url = n.join(s);
    if (rest = rest.trim(), !slashesDenoteHost && 1 === url.split("#").length) {
      /** @type {(Array<string>|null)} */
      var simplePath = humanMonth.exec(rest);
      if (simplePath) {
        return this.path = rest, this.href = rest, this.pathname = simplePath[1], simplePath[2] ? (this.search = simplePath[2], this.query = body ? querystring.parse(this.search.substr(1)) : this.search.substr(1)) : body && (this.search = "", this.query = {}), this;
      }
    }
    /** @type {(Array<string>|null)} */
    var proto = hostPattern.exec(rest);
    if (proto) {
      /** @type {string} */
      var lowerProto = (proto = proto[0]).toLowerCase();
      /** @type {string} */
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      /** @type {boolean} */
      var synthetic = "//" === rest.substr(0, 2);
      if (!(!synthetic || proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        /** @type {boolean} */
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (synthetic || proto && !slashedProtocol[proto])) {
      var auth;
      var atSign;
      /** @type {number} */
      var hostEnd = -1;
      /** @type {number} */
      var i = 0;
      for (; i < hostEndingChars.length; i++) {
        if (-1 !== (hec = rest.indexOf(hostEndingChars[i])) && (-1 === hostEnd || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (-1 !== (atSign = -1 === hostEnd ? rest.lastIndexOf("@") : rest.lastIndexOf("@", hostEnd))) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        /** @type {string} */
        this.auth = decodeURIComponent(auth);
      }
      /** @type {number} */
      hostEnd = -1;
      /** @type {number} */
      i = 0;
      for (; i < a.length; i++) {
        var hec;
        if (-1 !== (hec = rest.indexOf(a[i])) && (-1 === hostEnd || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (-1 === hostEnd) {
        hostEnd = rest.length;
      }
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      /** @type {boolean} */
      var C = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
      if (!C) {
        var data = this.hostname.split(/\./);
        var stringLength = (i = 0, data.length);
        for (; i < stringLength; i++) {
          var val = data[i];
          if (val && !val.match(h)) {
            /** @type {string} */
            var out = "";
            /** @type {number} */
            var i = 0;
            var newPartNum = val.length;
            for (; i < newPartNum; i++) {
              if (val.charCodeAt(i) > 127) {
                /** @type {string} */
                out = out + "x";
              } else {
                out = out + val[i];
              }
            }
            if (!out.match(h)) {
              var dims = data.slice(0, i);
              var ret = data.slice(i + 1);
              var m = val.match(p);
              if (m) {
                dims.push(m[1]);
                ret.unshift(m[2]);
              }
              if (ret.length) {
                /** @type {string} */
                rest = "/" + ret.join(".") + rest;
              }
              this.hostname = dims.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > 255) {
        /** @type {string} */
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!C) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      /** @type {string} */
      var p = this.port ? ":" + this.port : "";
      var h = this.hostname || "";
      /** @type {string} */
      this.host = h + p;
      this.href += this.host;
      if (C) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if ("/" !== rest[0]) {
          /** @type {string} */
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      /** @type {number} */
      i = 0;
      /** @type {number} */
      stringLength = value.length;
      for (; i < stringLength; i++) {
        var url = value[i];
        if (-1 !== rest.indexOf(url)) {
          /** @type {string} */
          var text = encodeURIComponent(url);
          if (text === url) {
            /** @type {string} */
            text = escape(url);
          }
          rest = rest.split(url).join(text);
        }
      }
    }
    var i = rest.indexOf("#");
    if (-1 !== i) {
      this.hash = rest.substr(i);
      rest = rest.slice(0, i);
    }
    var qm = rest.indexOf("?");
    if (-1 !== qm ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), body && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : body && (this.search = "", this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      p = this.pathname || "";
      var s = this.search || "";
      this.path = p + s;
    }
    return this.href = this.format(), this;
  };
  /**
   * @return {?}
   */
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      /** @type {string} */
      auth = (auth = encodeURIComponent(auth)).replace(/%3A/i, ":");
      /** @type {string} */
      auth = auth + "@";
    }
    var protocol = this.protocol || "";
    var c = this.pathname || "";
    var hash = this.hash || "";
    /** @type {boolean} */
    var host = false;
    /** @type {string} */
    var query = "";
    if (this.host) {
      host = auth + this.host;
    } else {
      if (this.hostname) {
        host = auth + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]");
        if (this.port) {
          /** @type {string} */
          host = host + (":" + this.port);
        }
      }
    }
    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var s2 = this.search || query && "?" + query || "";
    return protocol && ":" !== protocol.substr(-1) && (protocol = protocol + ":"), this.slashes || (!protocol || slashedProtocol[protocol]) && false !== host ? (host = "//" + (host || ""), c && "/" !== c.charAt(0) && (c = "/" + c)) : host || (host = ""), hash && "#" !== hash.charAt(0) && (hash = "#" + hash), s2 && "?" !== s2.charAt(0) && (s2 = "?" + s2), protocol + host + (c = c.replace(/[?#]/g, function(qov) {
      return encodeURIComponent(qov);
    })) + (s2 = s2.replace("#", "%23")) + hash;
  };
  /**
   * @param {string} relative
   * @return {?}
   */
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  /**
   * @param {!Object} relative
   * @return {?}
   */
  Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
      var rel = new Url;
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url;
    /** @type {!Array<string>} */
    var crossfilterable_layers = Object.keys(this);
    /** @type {number} */
    var layer_i = 0;
    for (; layer_i < crossfilterable_layers.length; layer_i++) {
      /** @type {string} */
      var proxyOption = crossfilterable_layers[layer_i];
      result[proxyOption] = this[proxyOption];
    }
    if (result.hash = relative.hash, "" === relative.href) {
      return result.href = result.format(), result;
    }
    if (relative.slashes && !relative.protocol) {
      /** @type {!Array<string>} */
      var rkeys = Object.keys(relative);
      /** @type {number} */
      var rk = 0;
      for (; rk < rkeys.length; rk++) {
        /** @type {string} */
        var rkey = rkeys[rk];
        if ("protocol" !== rkey) {
          result[rkey] = relative[rkey];
        }
      }
      return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = "/"), result.href = result.format(), result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        /** @type {!Array<string>} */
        var rkeys = Object.keys(relative);
        /** @type {number} */
        var rk = 0;
        for (; rk < rkeys.length; rk++) {
          /** @type {string} */
          var rkey = rkeys[rk];
          result[rkey] = relative[rkey];
        }
        return result.href = result.format(), result;
      }
      if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol]) {
        result.pathname = relative.pathname;
      } else {
        var relPath = (relative.pathname || "").split("/");
        for (; relPath.length && !(relative.host = relPath.shift());) {
        }
        if (!relative.host) {
          /** @type {string} */
          relative.host = "";
        }
        if (!relative.hostname) {
          /** @type {string} */
          relative.hostname = "";
        }
        if ("" !== relPath[0]) {
          relPath.unshift("");
        }
        if (relPath.length < 2) {
          relPath.unshift("");
        }
        result.pathname = relPath.join("/");
      }
      if (result.search = relative.search, result.query = relative.query, result.host = relative.host || "", result.auth = relative.auth, result.hostname = relative.hostname || relative.host, result.port = relative.port, result.pathname || result.search) {
        var p = result.pathname || "";
        var s = result.search || "";
        result.path = p + s;
      }
      return result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
    }
    var g = result.pathname && "/" === result.pathname.charAt(0);
    var r = relative.host || relative.pathname && "/" === relative.pathname.charAt(0);
    var type = r || g || result.host && relative.pathname;
    var graphTypeBaseName = type;
    var srcPath = result.pathname && result.pathname.split("/") || [];
    var n = (relPath = relative.pathname && relative.pathname.split("/") || [], result.protocol && !slashedProtocol[result.protocol]);
    if (n && (result.hostname = "", result.port = null, result.host && ("" === srcPath[0] ? srcPath[0] = result.host : srcPath.unshift(result.host)), result.host = "", relative.protocol && (relative.hostname = null, relative.port = null, relative.host && ("" === relPath[0] ? relPath[0] = relative.host : relPath.unshift(relative.host)), relative.host = null), type = type && ("" === relPath[0] || "" === srcPath[0])), r) {
      result.host = relative.host || "" === relative.host ? relative.host : result.host;
      result.hostname = relative.hostname || "" === relative.hostname ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else {
      if (relPath.length) {
        if (!srcPath) {
          /** @type {!Array} */
          srcPath = [];
        }
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else {
        if (!util.isNullOrUndefined(relative.search)) {
          if (n) {
            result.hostname = result.host = srcPath.shift();
            if (_sizeAnimateTimeStamps = !!(result.host && result.host.indexOf("@") > 0) && result.host.split("@")) {
              result.auth = _sizeAnimateTimeStamps.shift();
              result.host = result.hostname = _sizeAnimateTimeStamps.shift();
            }
          }
          return result.search = relative.search, result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), result.href = result.format(), result;
        }
      }
    }
    if (!srcPath.length) {
      return result.pathname = null, result.search ? result.path = "/" + result.search : result.path = null, result.href = result.format(), result;
    }
    var value = srcPath.slice(-1)[0];
    var attrOptions = (result.host || relative.host || srcPath.length > 1) && ("." === value || ".." === value) || "" === value;
    /** @type {number} */
    var A = 0;
    var i = srcPath.length;
    for (; i >= 0; i--) {
      if ("." === (value = srcPath[i])) {
        srcPath.splice(i, 1);
      } else {
        if (".." === value) {
          srcPath.splice(i, 1);
          A++;
        } else {
          if (A) {
            srcPath.splice(i, 1);
            A--;
          }
        }
      }
    }
    if (!type && !graphTypeBaseName) {
      for (; A--; A) {
        srcPath.unshift("..");
      }
    }
    if (!(!type || "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0))) {
      srcPath.unshift("");
    }
    if (attrOptions && "/" !== srcPath.join("/").substr(-1)) {
      srcPath.push("");
    }
    var _sizeAnimateTimeStamps;
    var isAbsolute = "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0);
    if (n) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      if (_sizeAnimateTimeStamps = !!(result.host && result.host.indexOf("@") > 0) && result.host.split("@")) {
        result.auth = _sizeAnimateTimeStamps.shift();
        result.host = result.hostname = _sizeAnimateTimeStamps.shift();
      }
    }
    return (type = type || result.host && srcPath.length) && !isAbsolute && srcPath.unshift(""), srcPath.length ? result.pathname = srcPath.join("/") : (result.pathname = null, result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, result.href = result.format(), result;
  };
  /**
   * @return {undefined}
   */
  Url.prototype.parseHost = function() {
    var host = this.host;
    /** @type {(Array<string>|null)} */
    var port = portPattern.exec(host);
    if (port) {
      if (":" !== (port = port[0])) {
        /** @type {string} */
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
}, function(canCreateDiscussions, a, r) {
  /**
   * @param {!Function} obj
   * @return {?}
   */
  function setPrototypeOf(obj) {
    return (setPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(node) {
      return node.__proto__ || Object.getPrototypeOf(node);
    })(obj);
  }
  r.d(a, "a", function() {
    return setPrototypeOf;
  });
}, function(canCreateDiscussions, a, r) {
  /**
   * @param {!Object} obj
   * @param {!Object} proto
   * @return {?}
   */
  function setPrototypeOf(obj, proto) {
    return (setPrototypeOf = Object.setPrototypeOf || function(empty, proto) {
      return empty.__proto__ = proto, empty;
    })(obj, proto);
  }
  /**
   * @param {!Object} subClass
   * @param {!Object} superClass
   * @return {undefined}
   */
  function _inherits(subClass, superClass) {
    if ("function" !== typeof superClass && null !== superClass) {
      throw new TypeError("Super expression must either be null or a function");
    }
    /** @type {!Object} */
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor : {
        value : subClass,
        writable : true,
        configurable : true
      }
    });
    if (superClass) {
      setPrototypeOf(subClass, superClass);
    }
  }
  r.d(a, "a", function() {
    return _inherits;
  });
}, , function(module, canCreateDiscussions, moment) {
  (function($) {
    if ("undefined" === typeof $ || !$.version || 0 === $.version.indexOf("v0.") || 0 === $.version.indexOf("v1.") && 0 !== $.version.indexOf("v1.8.")) {
      module.exports = {
        nextTick : function(callback, fn, x, t) {
          if ("function" !== typeof callback) {
            throw new TypeError('"callback" argument must be a function');
          }
          var args;
          var i;
          /** @type {number} */
          var l = arguments.length;
          switch(l) {
            case 0:
            case 1:
              return $.nextTick(callback);
            case 2:
              return $.nextTick(function() {
                callback.call(null, fn);
              });
            case 3:
              return $.nextTick(function() {
                callback.call(null, fn, x);
              });
            case 4:
              return $.nextTick(function() {
                callback.call(null, fn, x, t);
              });
            default:
              /** @type {!Array} */
              args = new Array(l - 1);
              /** @type {number} */
              i = 0;
              for (; i < args.length;) {
                args[i++] = arguments[i];
              }
              return $.nextTick(function() {
                callback.apply(null, args);
              });
          }
        }
      };
    } else {
      /** @type {!Function} */
      module.exports = $;
    }
  }).call(this, moment(8));
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @param {?} b
   * @return {?}
   */
  function set(b) {
    if (!Buffer.isBuffer(b)) {
      b = Buffer.from(b);
    }
    /** @type {number} */
    var maxLength = b.length / 4 | 0;
    /** @type {!Array} */
    var output = new Array(maxLength);
    /** @type {number} */
    var a = 0;
    for (; a < maxLength; a++) {
      output[a] = b.readUInt32BE(4 * a);
    }
    return output;
  }
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  function pointToOctet(key) {
    for (; 0 < key.length; key++) {
      /** @type {number} */
      key[0] = 0;
    }
  }
  /**
   * @param {!Array} data
   * @param {string} target
   * @param {!Array} keys
   * @param {!Object} e
   * @param {number} i
   * @return {?}
   */
  function split(data, target, keys, e, i) {
    var t;
    var n;
    var num;
    var sum;
    var t0 = keys[0];
    var t1 = keys[1];
    var k = keys[2];
    var key = keys[3];
    /** @type {number} */
    var a = data[0] ^ target[0];
    /** @type {number} */
    var d = data[1] ^ target[1];
    /** @type {number} */
    var b = data[2] ^ target[2];
    /** @type {number} */
    var j = data[3] ^ target[3];
    /** @type {number} */
    var aid = 4;
    /** @type {number} */
    var whichFriend = 1;
    for (; whichFriend < i; whichFriend++) {
      /** @type {number} */
      t = t0[a >>> 24] ^ t1[d >>> 16 & 255] ^ k[b >>> 8 & 255] ^ key[255 & j] ^ target[aid++];
      /** @type {number} */
      n = t0[d >>> 24] ^ t1[b >>> 16 & 255] ^ k[j >>> 8 & 255] ^ key[255 & a] ^ target[aid++];
      /** @type {number} */
      num = t0[b >>> 24] ^ t1[j >>> 16 & 255] ^ k[a >>> 8 & 255] ^ key[255 & d] ^ target[aid++];
      /** @type {number} */
      sum = t0[j >>> 24] ^ t1[a >>> 16 & 255] ^ k[d >>> 8 & 255] ^ key[255 & b] ^ target[aid++];
      /** @type {number} */
      a = t;
      /** @type {number} */
      d = n;
      /** @type {number} */
      b = num;
      /** @type {number} */
      j = sum;
    }
    return t = (e[a >>> 24] << 24 | e[d >>> 16 & 255] << 16 | e[b >>> 8 & 255] << 8 | e[255 & j]) ^ target[aid++], n = (e[d >>> 24] << 24 | e[b >>> 16 & 255] << 16 | e[j >>> 8 & 255] << 8 | e[255 & a]) ^ target[aid++], num = (e[b >>> 24] << 24 | e[j >>> 16 & 255] << 16 | e[a >>> 8 & 255] << 8 | e[255 & d]) ^ target[aid++], sum = (e[j >>> 24] << 24 | e[a >>> 16 & 255] << 16 | e[d >>> 8 & 255] << 8 | e[255 & b]) ^ target[aid++], [t = t >>> 0, n = n >>> 0, num = num >>> 0, sum = sum >>> 0];
  }
  /**
   * @param {?} key
   * @return {undefined}
   */
  function Salsa20Core(key) {
    this._key = set(key);
    this._reset();
  }
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var s = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var indices = function() {
    /** @type {!Array} */
    var d = new Array(256);
    /** @type {number} */
    var search_lemma = 0;
    for (; search_lemma < 256; search_lemma++) {
      /** @type {number} */
      d[search_lemma] = search_lemma < 128 ? search_lemma << 1 : search_lemma << 1 ^ 283;
    }
    /** @type {!Array} */
    var tilerLayerIndex = [];
    /** @type {!Array} */
    var prevToCurrIndex = [];
    /** @type {!Array} */
    var MPermConj = [[], [], [], []];
    /** @type {!Array} */
    var mapLayerCollection = [[], [], [], []];
    /** @type {number} */
    var j = 0;
    /** @type {number} */
    var xi = 0;
    /** @type {number} */
    var f = 0;
    for (; f < 256; ++f) {
      /** @type {number} */
      var i = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      /** @type {number} */
      i = i >>> 8 ^ 255 & i ^ 99;
      /** @type {number} */
      tilerLayerIndex[j] = i;
      /** @type {number} */
      prevToCurrIndex[i] = j;
      var x2 = d[j];
      var x4 = d[x2];
      var x8 = d[x4];
      /** @type {number} */
      var splat = 257 * d[i] ^ 16843008 * i;
      /** @type {number} */
      MPermConj[0][j] = splat << 24 | splat >>> 8;
      /** @type {number} */
      MPermConj[1][j] = splat << 16 | splat >>> 16;
      /** @type {number} */
      MPermConj[2][j] = splat << 8 | splat >>> 24;
      /** @type {number} */
      MPermConj[3][j] = splat;
      /** @type {number} */
      splat = 16843009 * x8 ^ 65537 * x4 ^ 257 * x2 ^ 16843008 * j;
      /** @type {number} */
      mapLayerCollection[0][i] = splat << 24 | splat >>> 8;
      /** @type {number} */
      mapLayerCollection[1][i] = splat << 16 | splat >>> 16;
      /** @type {number} */
      mapLayerCollection[2][i] = splat << 8 | splat >>> 24;
      /** @type {number} */
      mapLayerCollection[3][i] = splat;
      if (0 === j) {
        /** @type {number} */
        j = xi = 1;
      } else {
        /** @type {number} */
        j = x2 ^ d[d[d[x8 ^ x2]]];
        /** @type {number} */
        xi = xi ^ d[d[xi]];
      }
    }
    return {
      SBOX : tilerLayerIndex,
      INV_SBOX : prevToCurrIndex,
      SUB_MIX : MPermConj,
      INV_SUB_MIX : mapLayerCollection
    };
  }();
  /** @type {number} */
  Salsa20Core.blockSize = 16;
  /** @type {number} */
  Salsa20Core.keySize = 32;
  /** @type {number} */
  Salsa20Core.prototype.blockSize = Salsa20Core.blockSize;
  /** @type {number} */
  Salsa20Core.prototype.keySize = Salsa20Core.keySize;
  /**
   * @return {undefined}
   */
  Salsa20Core.prototype._reset = function() {
    var ar = this._key;
    var j = ar.length;
    var nextReplicaIndex = j + 6;
    /** @type {number} */
    var numTiles = 4 * (nextReplicaIndex + 1);
    /** @type {!Array} */
    var a = [];
    /** @type {number} */
    var i = 0;
    for (; i < j; i++) {
      a[i] = ar[i];
    }
    i = j;
    for (; i < numTiles; i++) {
      var key = a[i - 1];
      if (i % j === 0) {
        /** @type {number} */
        key = key << 8 | key >>> 24;
        /** @type {number} */
        key = indices.SBOX[key >>> 24] << 24 | indices.SBOX[key >>> 16 & 255] << 16 | indices.SBOX[key >>> 8 & 255] << 8 | indices.SBOX[255 & key];
        /** @type {number} */
        key = key ^ s[i / j | 0] << 24;
      } else {
        if (j > 6 && i % j === 4) {
          /** @type {number} */
          key = indices.SBOX[key >>> 24] << 24 | indices.SBOX[key >>> 16 & 255] << 16 | indices.SBOX[key >>> 8 & 255] << 8 | indices.SBOX[255 & key];
        }
      }
      /** @type {number} */
      a[i] = a[i - j] ^ key;
    }
    /** @type {!Array} */
    var _insertPointCoords = [];
    /** @type {number} */
    var _axisPosName = 0;
    for (; _axisPosName < numTiles; _axisPosName++) {
      /** @type {number} */
      var missingRects = numTiles - _axisPosName;
      var _axisCenter = a[missingRects - (_axisPosName % 4 ? 0 : 4)];
      _insertPointCoords[_axisPosName] = _axisPosName < 4 || missingRects <= 4 ? _axisCenter : indices.INV_SUB_MIX[0][indices.SBOX[_axisCenter >>> 24]] ^ indices.INV_SUB_MIX[1][indices.SBOX[_axisCenter >>> 16 & 255]] ^ indices.INV_SUB_MIX[2][indices.SBOX[_axisCenter >>> 8 & 255]] ^ indices.INV_SUB_MIX[3][indices.SBOX[255 & _axisCenter]];
    }
    this._nRounds = nextReplicaIndex;
    /** @type {!Array} */
    this._keySchedule = a;
    /** @type {!Array} */
    this._invKeySchedule = _insertPointCoords;
  };
  /**
   * @param {!Array} search
   * @return {?}
   */
  Salsa20Core.prototype.encryptBlockRaw = function(search) {
    return split(search = set(search), this._keySchedule, indices.SUB_MIX, indices.SBOX, this._nRounds);
  };
  /**
   * @param {?} array
   * @return {?}
   */
  Salsa20Core.prototype.encryptBlock = function(array) {
    var out = this.encryptBlockRaw(array);
    var buf = Buffer.allocUnsafe(16);
    return buf.writeUInt32BE(out[0], 0), buf.writeUInt32BE(out[1], 4), buf.writeUInt32BE(out[2], 8), buf.writeUInt32BE(out[3], 12), buf;
  };
  /**
   * @param {!Array} state
   * @return {?}
   */
  Salsa20Core.prototype.decryptBlock = function(state) {
    var startStyles = (state = set(state))[1];
    state[1] = state[3];
    state[3] = startStyles;
    var pair = split(state, this._invKeySchedule, indices.INV_SUB_MIX, indices.INV_SBOX, this._nRounds);
    var buffer = Buffer.allocUnsafe(16);
    return buffer.writeUInt32BE(pair[0], 0), buffer.writeUInt32BE(pair[3], 4), buffer.writeUInt32BE(pair[2], 8), buffer.writeUInt32BE(pair[1], 12), buffer;
  };
  /**
   * @return {undefined}
   */
  Salsa20Core.prototype.scrub = function() {
    pointToOctet(this._keySchedule);
    pointToOctet(this._invKeySchedule);
    pointToOctet(this._key);
  };
  /** @type {function(?): undefined} */
  mixin.exports.AES = Salsa20Core;
}, function(mixin, canCreateDiscussions, require) {
  var Buffer = require(2).Buffer;
  var Md5 = require(37);
  /**
   * @param {!Object} key
   * @param {?} a
   * @param {!Object} b
   * @param {number} size
   * @return {?}
   */
  mixin.exports = function(key, a, b, size) {
    if (Buffer.isBuffer(key) || (key = Buffer.from(key, "binary")), a && (Buffer.isBuffer(a) || (a = Buffer.from(a, "binary")), 8 !== a.length)) {
      throw new RangeError("salt should be Buffer with 8 byte length");
    }
    /** @type {number} */
    var c = b / 8;
    var r = Buffer.alloc(c);
    var result = Buffer.alloc(size || 0);
    var data = Buffer.alloc(0);
    for (; c > 0 || size > 0;) {
      var md5 = new Md5;
      md5.update(data);
      md5.update(key);
      if (a) {
        md5.update(a);
      }
      data = md5.digest();
      /** @type {number} */
      var i = 0;
      if (c > 0) {
        /** @type {number} */
        var m = r.length - c;
        /** @type {number} */
        i = Math.min(c, data.length);
        data.copy(r, m, 0, i);
        /** @type {number} */
        c = c - i;
      }
      if (i < data.length && size > 0) {
        /** @type {number} */
        var pos = result.length - size;
        /** @type {number} */
        var amount = Math.min(size, data.length - i);
        data.copy(result, pos, i, i + amount);
        /** @type {number} */
        size = size - amount;
      }
    }
    return data.fill(0), {
      key : r,
      iv : result
    };
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @param {!Object} conf
   * @return {undefined}
   */
  function test(key, conf) {
    /** @type {string} */
    this.type = key;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = (new BN(0)).toRed(this.red);
    this.one = (new BN(1)).toRed(this.red);
    this.two = (new BN(2)).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    /** @type {!Array} */
    this._wnafT1 = new Array(4);
    /** @type {!Array} */
    this._wnafT2 = new Array(4);
    /** @type {!Array} */
    this._wnafT3 = new Array(4);
    /** @type {!Array} */
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var target = this.n && this.p.div(this.n);
    if (!target || target.cmpn(100) > 0) {
      /** @type {null} */
      this.redN = null;
    } else {
      /** @type {boolean} */
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  /**
   * @param {?} n
   * @param {!Object} a
   * @return {undefined}
   */
  function _(n, a) {
    this.curve = n;
    /** @type {!Object} */
    this.type = a;
    /** @type {null} */
    this.precomputed = null;
  }
  var BN = require(4);
  var utils = require(7);
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  /** @type {function(string, !Object): undefined} */
  module.exports = test;
  /**
   * @return {?}
   */
  test.prototype.point = function() {
    throw new Error("Not implemented");
  };
  /**
   * @return {?}
   */
  test.prototype.validate = function() {
    throw new Error("Not implemented");
  };
  /**
   * @param {?} p
   * @param {number} k
   * @return {?}
   */
  test.prototype._fixedNafMul = function(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    /** @type {number} */
    var time = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    /** @type {number} */
    time = time / 3;
    /** @type {!Array} */
    var vc = [];
    /** @type {number} */
    var j = 0;
    for (; j < naf.length; j = j + doubles.step) {
      /** @type {number} */
      var s = 0;
      /** @type {number} */
      k = j + doubles.step - 1;
      for (; k >= j; k--) {
        s = (s << 1) + naf[k];
      }
      vc.push(s);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    /** @type {number} */
    var x = time;
    for (; x > 0; x--) {
      /** @type {number} */
      j = 0;
      for (; j < vc.length; j++) {
        if ((s = vc[j]) === x) {
          b = b.mixedAdd(doubles.points[j]);
        } else {
          if (s === -x) {
            b = b.mixedAdd(doubles.points[j].neg());
          }
        }
      }
      a = a.add(b);
    }
    return a.toP();
  };
  /**
   * @param {!Object} p
   * @param {number} k
   * @return {?}
   */
  test.prototype._wnafMul = function(p, k) {
    /** @type {number} */
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    /** @type {number} */
    var i = naf.length - 1;
    for (; i >= 0; i--) {
      /** @type {number} */
      k = 0;
      for (; i >= 0 && 0 === naf[i]; i--) {
        k++;
      }
      if (i >= 0 && k++, acc = acc.dblp(k), i < 0) {
        break;
      }
      var testVal = naf[i];
      assert(0 !== testVal);
      acc = "affine" === p.type ? testVal > 0 ? acc.mixedAdd(wnd[testVal - 1 >> 1]) : acc.mixedAdd(wnd[-testVal - 1 >> 1].neg()) : testVal > 0 ? acc.add(wnd[testVal - 1 >> 1]) : acc.add(wnd[-testVal - 1 >> 1].neg());
    }
    return "affine" === p.type ? acc.toP() : acc;
  };
  /**
   * @param {number} w
   * @param {!Array} points
   * @param {!Array} coeffs
   * @param {number} len
   * @param {boolean} err
   * @return {?}
   */
  test.prototype._wnafMulAdd = function(w, points, coeffs, len, err) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    /** @type {number} */
    var max = 0;
    /** @type {number} */
    var i = 0;
    for (; i < len; i++) {
      var nafPoints = (p = points[i])._getNAFPoints(w);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    /** @type {number} */
    i = len - 1;
    for (; i >= 1; i = i - 2) {
      /** @type {number} */
      var a = i - 1;
      /** @type {number} */
      var b = i;
      if (1 === wndWidth[a] && 1 === wndWidth[b]) {
        /** @type {!Array} */
        var comb = [points[a], null, null, points[b]];
        if (0 === points[a].y.cmp(points[b].y)) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else {
          if (0 === points[a].y.cmp(points[b].y.redNeg())) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
        }
        /** @type {!Array} */
        var tmp2Size = [-3, -1, -5, -7, 0, 7, 5, 1, 3];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        /** @type {number} */
        max = Math.max(jsf[0].length, max);
        /** @type {!Array} */
        naf[a] = new Array(max);
        /** @type {!Array} */
        naf[b] = new Array(max);
        /** @type {number} */
        var j = 0;
        for (; j < max; j++) {
          /** @type {number} */
          var g = 0 | jsf[0][j];
          /** @type {number} */
          var w = 0 | jsf[1][j];
          naf[a][j] = tmp2Size[3 * (g + 1) + (w + 1)];
          /** @type {number} */
          naf[b][j] = 0;
          /** @type {!Array} */
          wnd[a] = comb;
        }
      } else {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        /** @type {number} */
        max = Math.max(naf[a].length, max);
        /** @type {number} */
        max = Math.max(naf[b].length, max);
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    /** @type {number} */
    i = max;
    for (; i >= 0; i--) {
      /** @type {number} */
      var k = 0;
      for (; i >= 0;) {
        /** @type {boolean} */
        var E = true;
        /** @type {number} */
        j = 0;
        for (; j < len; j++) {
          /** @type {number} */
          tmp[j] = 0 | naf[j][i];
          if (0 !== tmp[j]) {
            /** @type {boolean} */
            E = false;
          }
        }
        if (!E) {
          break;
        }
        k++;
        i--;
      }
      if (i >= 0 && k++, acc = acc.dblp(k), i < 0) {
        break;
      }
      /** @type {number} */
      j = 0;
      for (; j < len; j++) {
        var p;
        var type = tmp[j];
        if (0 !== type) {
          if (type > 0) {
            p = wnd[j][type - 1 >> 1];
          } else {
            if (type < 0) {
              p = wnd[j][-type - 1 >> 1].neg();
            }
          }
          acc = "affine" === p.type ? acc.mixedAdd(p) : acc.add(p);
        }
      }
    }
    /** @type {number} */
    i = 0;
    for (; i < len; i++) {
      /** @type {null} */
      wnd[i] = null;
    }
    return err ? acc : acc.toP();
  };
  /** @type {function(?, !Object): undefined} */
  test.BasePoint = _;
  /**
   * @return {?}
   */
  _.prototype.eq = function() {
    throw new Error("Not implemented");
  };
  /**
   * @return {?}
   */
  _.prototype.validate = function() {
    return this.curve.validate(this);
  };
  /**
   * @param {string} data
   * @param {string} enc
   * @return {?}
   */
  test.prototype.decodePoint = function(data, enc) {
    data = utils.toArray(data, enc);
    var size = this.p.byteLength();
    if ((4 === data[0] || 6 === data[0] || 7 === data[0]) && data.length - 1 === 2 * size) {
      return 6 === data[0] ? assert(data[data.length - 1] % 2 === 0) : 7 === data[0] && assert(data[data.length - 1] % 2 === 1), this.point(data.slice(1, 1 + size), data.slice(1 + size, 1 + 2 * size));
    }
    if ((2 === data[0] || 3 === data[0]) && data.length - 1 === size) {
      return this.pointFromX(data.slice(1, 1 + size), 3 === data[0]);
    }
    throw new Error("Unknown point format");
  };
  /**
   * @param {!Array} data
   * @return {?}
   */
  _.prototype.encodeCompressed = function(data) {
    return this.encode(data, true);
  };
  /**
   * @param {?} value
   * @return {?}
   */
  _.prototype._encode = function(value) {
    var offset = this.curve.p.byteLength();
    var type = this.getX().toArray("be", offset);
    return value ? [this.getY().isEven() ? 2 : 3].concat(type) : [4].concat(type, this.getY().toArray("be", offset));
  };
  /**
   * @param {!Array} options
   * @param {string} value
   * @return {?}
   */
  _.prototype.encode = function(options, value) {
    return utils.encode(this._encode(value), options);
  };
  /**
   * @param {undefined} power
   * @return {?}
   */
  _.prototype.precompute = function(power) {
    if (this.precomputed) {
      return this;
    }
    var precomputed = {
      doubles : null,
      naf : null,
      beta : null
    };
    return precomputed.naf = this._getNAFPoints(8), precomputed.doubles = this._getDoubles(4, power), precomputed.beta = this._getBeta(), this.precomputed = precomputed, this;
  };
  /**
   * @param {?} k
   * @return {?}
   */
  _.prototype._hasDoubles = function(k) {
    if (!this.precomputed) {
      return false;
    }
    var doubles = this.precomputed.doubles;
    return !!doubles && doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  /**
   * @param {number} step
   * @param {number} power
   * @return {?}
   */
  _.prototype._getDoubles = function(step, power) {
    if (this.precomputed && this.precomputed.doubles) {
      return this.precomputed.doubles;
    }
    /** @type {!Array} */
    var indexes = [this];
    var r = this;
    /** @type {number} */
    var i = 0;
    for (; i < power; i = i + step) {
      /** @type {number} */
      var index = 0;
      for (; index < step; index++) {
        r = r.dbl();
      }
      indexes.push(r);
    }
    return {
      step : step,
      points : indexes
    };
  };
  /**
   * @param {number} wnd
   * @return {?}
   */
  _.prototype._getNAFPoints = function(wnd) {
    if (this.precomputed && this.precomputed.naf) {
      return this.precomputed.naf;
    }
    /** @type {!Array} */
    var points = [this];
    /** @type {number} */
    var cell_amount = (1 << wnd) - 1;
    var l = 1 === cell_amount ? null : this.dbl();
    /** @type {number} */
    var i = 1;
    for (; i < cell_amount; i++) {
      points[i] = points[i - 1].add(l);
    }
    return {
      wnd : wnd,
      points : points
    };
  };
  /**
   * @return {?}
   */
  _.prototype._getBeta = function() {
    return null;
  };
  /**
   * @param {number} k
   * @return {?}
   */
  _.prototype.dblp = function(k) {
    var r = this;
    /** @type {number} */
    var l = 0;
    for (; l < k; l++) {
      r = r.dbl();
    }
    return r;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @return {?}
   */
  function parseKeys(key) {
    var password;
    if (!("object" !== typeof key || Buffer.isBuffer(key))) {
      password = key.passphrase;
      key = key.key;
    }
    if ("string" === typeof key) {
      key = Buffer.from(key);
    }
    var to3;
    var ndata;
    var stripped = fixProc(key, password);
    var type = stripped.tag;
    var data = stripped.data;
    switch(type) {
      case "CERTIFICATE":
        ndata = asn1.certificate.decode(data, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch(ndata || (ndata = asn1.PublicKey.decode(data, "der")), to3 = ndata.algorithm.algorithm.join(".")) {
          case "1.2.840.113549.1.1.1":
            return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return ndata.subjectPrivateKey = ndata.subjectPublicKey, {
              type : "ec",
              data : ndata
            };
          case "1.2.840.10040.4.1":
            return ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, "der"), {
              type : "dsa",
              data : ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + to3);
        }throw new Error("unknown key type " + type);
      case "ENCRYPTED PRIVATE KEY":
        data = function(data, password) {
          var salt = data.algorithm.decrypt.kde.kdeparams.salt;
          /** @type {number} */
          var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
          var mode = config[data.algorithm.decrypt.cipher.algo.join(".")];
          var iv = data.algorithm.decrypt.cipher.iv;
          var message = data.subjectPrivateKey;
          /** @type {number} */
          var keylen = parseInt(mode.split("-")[1], 10) / 8;
          var key = crypto.pbkdf2Sync(password, salt, iters, keylen, "sha1");
          var decipher = ourCrypto.createDecipheriv(mode, key, iv);
          /** @type {!Array} */
          var sub = [];
          return sub.push(decipher.update(message)), sub.push(decipher.final()), Buffer.concat(sub);
        }(data = asn1.EncryptedPrivateKey.decode(data, "der"), password);
      case "PRIVATE KEY":
        switch(to3 = (ndata = asn1.PrivateKey.decode(data, "der")).algorithm.algorithm.join(".")) {
          case "1.2.840.113549.1.1.1":
            return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve : ndata.algorithm.curve,
              privateKey : asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, "der"), {
              type : "dsa",
              params : ndata.algorithm.params
            };
          default:
            throw new Error("unknown key id " + to3);
        }throw new Error("unknown key type " + type);
      case "RSA PUBLIC KEY":
        return asn1.RSAPublicKey.decode(data, "der");
      case "RSA PRIVATE KEY":
        return asn1.RSAPrivateKey.decode(data, "der");
      case "DSA PRIVATE KEY":
        return {
          type : "dsa",
          params : asn1.DSAPrivateKey.decode(data, "der")
        };
      case "EC PRIVATE KEY":
        return {
          curve : (data = asn1.ECPrivateKey.decode(data, "der")).parameters.value,
          privateKey : data.privateKey
        };
      default:
        throw new Error("unknown key type " + type);
    }
  }
  var asn1 = require(178);
  var config = require(189);
  var fixProc = require(190);
  var ourCrypto = require(46);
  var crypto = require(75);
  var Buffer = require(2).Buffer;
  /** @type {function(!Object): ?} */
  module.exports = parseKeys;
  parseKeys.signature = asn1.signature;
}, , function(module, scope, moment) {
  (function(value) {
    var init;
    var args;
    var BinaryBundle;
    /** @type {!Array} */
    args = [];
    if (!(void 0 === (BinaryBundle = "function" === typeof(init = function() {
      /**
       * @param {string} e
       * @param {string} key
       * @param {string} value
       * @return {undefined}
       */
      function next(e, key, value) {
        /** @type {!XMLHttpRequest} */
        var req = new XMLHttpRequest;
        req.open("GET", e);
        /** @type {string} */
        req.responseType = "blob";
        /**
         * @return {undefined}
         */
        req.onload = function() {
          log(req.response, key, value);
        };
        /**
         * @return {undefined}
         */
        req.onerror = function() {
          console.error("could not download file");
        };
        req.send();
      }
      /**
       * @param {string} url
       * @return {?}
       */
      function _getLastModified(url) {
        /** @type {!XMLHttpRequest} */
        var xhr = new XMLHttpRequest;
        xhr.open("HEAD", url, false);
        try {
          xhr.send();
        } catch (e) {
        }
        return 200 <= xhr.status && 299 >= xhr.status;
      }
      /**
       * @param {!Element} node
       * @return {undefined}
       */
      function click(node) {
        try {
          node.dispatchEvent(new MouseEvent("click"));
        } catch (t) {
          /** @type {(Event|null)} */
          var evt = document.createEvent("MouseEvents");
          evt.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);
          node.dispatchEvent(evt);
        }
      }
      var global = "object" == typeof window && window.window === window ? window : "object" == typeof self && self.self === self ? self : "object" == typeof value && value.global === value ? value : void 0;
      var log = global.saveAs || ("object" != typeof window || window !== global ? function() {
      } : "download" in HTMLAnchorElement.prototype ? function(value, name, items) {
        var URL = global.URL || global.webkitURL;
        /** @type {!Element} */
        var obj = document.createElement("a");
        name = name || value.name || "download";
        /** @type {string} */
        obj.download = name;
        /** @type {string} */
        obj.rel = "noopener";
        if ("string" == typeof value) {
          /** @type {string} */
          obj.href = value;
          if (obj.origin === location.origin) {
            click(obj);
          } else {
            if (_getLastModified(obj.href)) {
              next(value, name, items);
            } else {
              click(obj, obj.target = "_blank");
            }
          }
        } else {
          obj.href = URL.createObjectURL(value);
          setTimeout(function() {
            URL.revokeObjectURL(obj.href);
          }, 4E4);
          setTimeout(function() {
            click(obj);
          }, 0);
        }
      } : "msSaveOrOpenBlob" in navigator ? function(value, name, items) {
        if (name = name || value.name || "download", "string" != typeof value) {
          navigator.msSaveOrOpenBlob(function(blob, object) {
            return "undefined" == typeof object ? object = {
              autoBom : false
            } : "object" != typeof object && (console.warn("Deprecated: Expected third argument to be a object"), object = {
              autoBom : !object
            }), object.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type) ? new Blob(["\ufeff", blob], {
              type : blob.type
            }) : blob;
          }(value, items), name);
        } else {
          if (_getLastModified(value)) {
            next(value, name, items);
          } else {
            /** @type {!Element} */
            var target = document.createElement("a");
            /** @type {string} */
            target.href = value;
            /** @type {string} */
            target.target = "_blank";
            setTimeout(function() {
              click(target);
            });
          }
        }
      } : function(value, r, items, root) {
        if ((root = root || open("", "_blank")) && (root.document.title = root.document.body.innerText = "downloading..."), "string" == typeof value) {
          return next(value, r, items);
        }
        /** @type {boolean} */
        var reverseIsSingle = "application/octet-stream" === value.type;
        var reverseValue = /constructor/i.test(global.HTMLElement) || global.safari;
        /** @type {boolean} */
        var onlyLazy = /CriOS\/[\d]+/.test(navigator.userAgent);
        if ((onlyLazy || reverseIsSingle && reverseValue) && "object" == typeof FileReader) {
          /** @type {!FileReader} */
          var r = new FileReader;
          /**
           * @return {undefined}
           */
          r.onloadend = function() {
            /** @type {(ArrayBuffer|Blob|null|string)} */
            var value = r.result;
            /** @type {(ArrayBuffer|Blob|null|string)} */
            value = onlyLazy ? value : value.replace(/^data:[^;]*;/, "data:attachment/file;");
            if (root) {
              /** @type {(ArrayBuffer|Blob|null|string)} */
              root.location.href = value;
            } else {
              /** @type {(ArrayBuffer|Blob|null|string)} */
              location = value;
            }
            /** @type {null} */
            root = null;
          };
          r.readAsDataURL(value);
        } else {
          var URL = global.URL || global.webkitURL;
          var url = URL.createObjectURL(value);
          if (root) {
            root.location = url;
          } else {
            location.href = url;
          }
          /** @type {null} */
          root = null;
          setTimeout(function() {
            URL.revokeObjectURL(url);
          }, 4E4);
        }
      });
      global.saveAs = log.saveAs = log;
      module.exports = log;
    }) ? init.apply(scope, args) : init))) {
      /** @type {(function(): undefined|undefined)} */
      module.exports = BinaryBundle;
    }
  }).call(this, moment(5));
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Filter() {
    renderer.call(this, 64);
    /** @type {number} */
    this._a = 1732584193;
    /** @type {number} */
    this._b = 4023233417;
    /** @type {number} */
    this._c = 2562383102;
    /** @type {number} */
    this._d = 271733878;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {?}
   */
  function push(x, y) {
    return x << y | x >>> 32 - y;
  }
  /**
   * @param {number} t
   * @param {number} d
   * @param {number} a
   * @param {number} b
   * @param {?} i
   * @param {number} k
   * @param {number} n
   * @return {?}
   */
  function g(t, d, a, b, i, k, n) {
    return push(t + (d & a | ~d & b) + i + k | 0, n) + d | 0;
  }
  /**
   * @param {number} v
   * @param {number} t
   * @param {number} a
   * @param {number} b
   * @param {?} n
   * @param {number} x
   * @param {number} i
   * @return {?}
   */
  function e(v, t, a, b, n, x, i) {
    return push(v + (t & b | a & ~b) + n + x | 0, i) + t | 0;
  }
  /**
   * @param {number} x
   * @param {boolean} l
   * @param {boolean} m
   * @param {number} s
   * @param {?} method
   * @param {number} url
   * @param {number} i
   * @return {?}
   */
  function f(x, l, m, s, method, url, i) {
    return push(x + (l ^ m ^ s) + method + url | 0, i) + l | 0;
  }
  /**
   * @param {number} name
   * @param {number} d
   * @param {?} a
   * @param {?} b
   * @param {?} t
   * @param {number} s
   * @param {number} n
   * @return {?}
   */
  function d(name, d, a, b, t, s, n) {
    return push(name + (a ^ (d | ~b)) + t + s | 0, n) + d | 0;
  }
  var EffectChain = require(1);
  var renderer = require(65);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var scratchBArray = new Array(16);
  EffectChain(Filter, renderer);
  /**
   * @return {undefined}
   */
  Filter.prototype._update = function() {
    /** @type {!Array} */
    var b = scratchBArray;
    /** @type {number} */
    var $orderCol = 0;
    for (; $orderCol < 16; ++$orderCol) {
      b[$orderCol] = this._block.readInt32LE(4 * $orderCol);
    }
    var p = this._a;
    var m = this._b;
    var n = this._c;
    var o = this._d;
    p = g(p, m, n, o, b[0], 3614090360, 7);
    o = g(o, p, m, n, b[1], 3905402710, 12);
    n = g(n, o, p, m, b[2], 606105819, 17);
    m = g(m, n, o, p, b[3], 3250441966, 22);
    p = g(p, m, n, o, b[4], 4118548399, 7);
    o = g(o, p, m, n, b[5], 1200080426, 12);
    n = g(n, o, p, m, b[6], 2821735955, 17);
    m = g(m, n, o, p, b[7], 4249261313, 22);
    p = g(p, m, n, o, b[8], 1770035416, 7);
    o = g(o, p, m, n, b[9], 2336552879, 12);
    n = g(n, o, p, m, b[10], 4294925233, 17);
    m = g(m, n, o, p, b[11], 2304563134, 22);
    p = g(p, m, n, o, b[12], 1804603682, 7);
    o = g(o, p, m, n, b[13], 4254626195, 12);
    n = g(n, o, p, m, b[14], 2792965006, 17);
    p = e(p, m = g(m, n, o, p, b[15], 1236535329, 22), n, o, b[1], 4129170786, 5);
    o = e(o, p, m, n, b[6], 3225465664, 9);
    n = e(n, o, p, m, b[11], 643717713, 14);
    m = e(m, n, o, p, b[0], 3921069994, 20);
    p = e(p, m, n, o, b[5], 3593408605, 5);
    o = e(o, p, m, n, b[10], 38016083, 9);
    n = e(n, o, p, m, b[15], 3634488961, 14);
    m = e(m, n, o, p, b[4], 3889429448, 20);
    p = e(p, m, n, o, b[9], 568446438, 5);
    o = e(o, p, m, n, b[14], 3275163606, 9);
    n = e(n, o, p, m, b[3], 4107603335, 14);
    m = e(m, n, o, p, b[8], 1163531501, 20);
    p = e(p, m, n, o, b[13], 2850285829, 5);
    o = e(o, p, m, n, b[2], 4243563512, 9);
    n = e(n, o, p, m, b[7], 1735328473, 14);
    p = f(p, m = e(m, n, o, p, b[12], 2368359562, 20), n, o, b[5], 4294588738, 4);
    o = f(o, p, m, n, b[8], 2272392833, 11);
    n = f(n, o, p, m, b[11], 1839030562, 16);
    m = f(m, n, o, p, b[14], 4259657740, 23);
    p = f(p, m, n, o, b[1], 2763975236, 4);
    o = f(o, p, m, n, b[4], 1272893353, 11);
    n = f(n, o, p, m, b[7], 4139469664, 16);
    m = f(m, n, o, p, b[10], 3200236656, 23);
    p = f(p, m, n, o, b[13], 681279174, 4);
    o = f(o, p, m, n, b[0], 3936430074, 11);
    n = f(n, o, p, m, b[3], 3572445317, 16);
    m = f(m, n, o, p, b[6], 76029189, 23);
    p = f(p, m, n, o, b[9], 3654602809, 4);
    o = f(o, p, m, n, b[12], 3873151461, 11);
    n = f(n, o, p, m, b[15], 530742520, 16);
    p = d(p, m = f(m, n, o, p, b[2], 3299628645, 23), n, o, b[0], 4096336452, 6);
    o = d(o, p, m, n, b[7], 1126891415, 10);
    n = d(n, o, p, m, b[14], 2878612391, 15);
    m = d(m, n, o, p, b[5], 4237533241, 21);
    p = d(p, m, n, o, b[12], 1700485571, 6);
    o = d(o, p, m, n, b[3], 2399980690, 10);
    n = d(n, o, p, m, b[10], 4293915773, 15);
    m = d(m, n, o, p, b[1], 2240044497, 21);
    p = d(p, m, n, o, b[8], 1873313359, 6);
    o = d(o, p, m, n, b[15], 4264355552, 10);
    n = d(n, o, p, m, b[6], 2734768916, 15);
    m = d(m, n, o, p, b[13], 1309151649, 21);
    p = d(p, m, n, o, b[4], 4149444226, 6);
    o = d(o, p, m, n, b[11], 3174756917, 10);
    n = d(n, o, p, m, b[2], 718787259, 15);
    m = d(m, n, o, p, b[9], 3951481745, 21);
    /** @type {number} */
    this._a = this._a + p | 0;
    /** @type {number} */
    this._b = this._b + m | 0;
    /** @type {number} */
    this._c = this._c + n | 0;
    /** @type {number} */
    this._d = this._d + o | 0;
  };
  /**
   * @return {?}
   */
  Filter.prototype._digest = function() {
    /** @type {number} */
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      /** @type {number} */
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var H = Buffer.allocUnsafe(16);
    return H.writeInt32LE(this._a, 0), H.writeInt32LE(this._b, 4), H.writeInt32LE(this._c, 8), H.writeInt32LE(this._d, 12), H;
  };
  /** @type {function(): undefined} */
  module.exports = Filter;
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Stream() {
    EventEmitter.call(this);
  }
  /** @type {function(): undefined} */
  module.exports = Stream;
  var EventEmitter = require(39).EventEmitter;
  require(1)(Stream, EventEmitter);
  Stream.Readable = require(20);
  Stream.Writable = require(127);
  Stream.Duplex = require(128);
  Stream.Transform = require(129);
  Stream.PassThrough = require(130);
  /** @type {function(): undefined} */
  Stream.Stream = Stream;
  /**
   * @param {!Object} dest
   * @param {!Object} src
   * @return {?}
   */
  Stream.prototype.pipe = function(dest, src) {
    /**
     * @param {undefined} input
     * @return {undefined}
     */
    function ondata(input) {
      if (dest.writable && false === dest.write(input) && source.pause) {
        source.pause();
      }
    }
    /**
     * @return {undefined}
     */
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    /**
     * @return {undefined}
     */
    function onend() {
      if (!a) {
        /** @type {boolean} */
        a = true;
        dest.end();
      }
    }
    /**
     * @return {undefined}
     */
    function onclose() {
      if (!a) {
        /** @type {boolean} */
        a = true;
        if ("function" === typeof dest.destroy) {
          dest.destroy();
        }
      }
    }
    /**
     * @param {?} event
     * @return {undefined}
     */
    function onerror(event) {
      if (cleanup(), 0 === EventEmitter.listenerCount(this, "error")) {
        throw event;
      }
    }
    /**
     * @return {undefined}
     */
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    var source = this;
    source.on("data", ondata);
    dest.on("drain", ondrain);
    if (!(dest._isStdio || src && false === src.end)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    /** @type {boolean} */
    var a = false;
    return source.on("error", onerror), dest.on("error", onerror), source.on("end", cleanup), source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), dest;
  };
}, function(module, canCreateDiscussions, isSlidingUp) {
  /**
   * @return {undefined}
   */
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  /**
   * @param {!Object} action
   * @return {undefined}
   */
  function remove(action) {
    if ("function" !== typeof action) {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof action);
    }
  }
  /**
   * @param {!Object} that
   * @return {?}
   */
  function $getMaxListeners(that) {
    return void 0 === that._maxListeners ? EventEmitter.defaultMaxListeners : that._maxListeners;
  }
  /**
   * @param {!Object} target
   * @param {!Object} type
   * @param {!Object} listener
   * @param {string} prepend
   * @return {?}
   */
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    var result;
    if (remove(listener), void 0 === (events = target._events) ? (events = target._events = Object.create(null), target._eventsCount = 0) : (void 0 !== events.newListener && (target.emit("newListener", type, listener.listener ? listener.listener : listener), events = target._events), existing = events[type]), void 0 === existing) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if ("function" === typeof existing ? existing = events[type] = prepend ? [listener, existing] : [existing, listener] : prepend ? existing.unshift(listener) : existing.push(listener), (m = $getMaxListeners(target)) > 0 && existing.length > m && !existing.warned) {
        /** @type {boolean} */
        existing.warned = true;
        /** @type {!Error} */
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        /** @type {string} */
        w.name = "MaxListenersExceededWarning";
        /** @type {!Object} */
        w.emitter = target;
        /** @type {!Object} */
        w.type = type;
        w.count = existing.length;
        /** @type {!Error} */
        result = w;
        if (console && console.warn) {
          console.warn(result);
        }
      }
    }
    return target;
  }
  /**
   * @return {?}
   */
  function handler() {
    if (!this.fired) {
      return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
  }
  /**
   * @param {!Object} target
   * @param {string} type
   * @param {!Object} listener
   * @return {?}
   */
  function _onceWrap(target, type, listener) {
    var state = {
      fired : false,
      wrapFn : void 0,
      target : target,
      type : type,
      listener : listener
    };
    var wrapped = handler.bind(state);
    return wrapped.listener = listener, state.wrapFn = wrapped, wrapped;
  }
  /**
   * @param {?} config
   * @param {string} type
   * @param {string} c
   * @return {?}
   */
  function register(config, type, c) {
    var listeners = config._events;
    if (void 0 === listeners) {
      return [];
    }
    var l = listeners[type];
    return void 0 === l ? [] : "function" === typeof l ? c ? [l.listener || l] : [l] : c ? function(arr) {
      /** @type {!Array} */
      var result = new Array(arr.length);
      /** @type {number} */
      var i = 0;
      for (; i < result.length; ++i) {
        result[i] = arr[i].listener || arr[i];
      }
      return result;
    }(l) : f(l, l.length);
  }
  /**
   * @param {string} type
   * @return {?}
   */
  function listenerCount(type) {
    var events = this._events;
    if (void 0 !== events) {
      var fns = events[type];
      if ("function" === typeof fns) {
        return 1;
      }
      if (void 0 !== fns) {
        return fns.length;
      }
    }
    return 0;
  }
  /**
   * @param {!NodeList} r
   * @param {number} i
   * @return {?}
   */
  function f(r, i) {
    /** @type {!Array} */
    var l = new Array(i);
    /** @type {number} */
    var n = 0;
    for (; n < i; ++n) {
      l[n] = r[n];
    }
    return l;
  }
  var findHandlers;
  /** @type {(null|{apply: function(function(this:THIS, ...?): RESULT, THIS, !Array<?>): RESULT, construct: function(function(...?): ?, !Array<?>, function(new:TARGET, ...?): ?=): TARGET, defineProperty: function(!Object, string, !ObjectPropertyDescriptor): boolean, deleteProperty: function(!Object, string): boolean, get: function(!Object, string, !Object=): *, getOwnPropertyDescriptor: function(!Object, string): (ObjectPropertyDescriptor|null), getPrototypeOf: function(!Object): (Object|null), has: function(!Object, string): boolean, isExtensible: function(!Object): boolean, ownKeys: function(!Object): !Array<?>, preventExtensions: function(!Object): boolean, set: function(!Object, string, *, !Object=): boolean, setPrototypeOf: function(!Object, (Object|null)): boolean})} */
  var overrides = "object" === typeof Reflect ? Reflect : null;
  /** @type {!Function} */
  var callback = overrides && "function" === typeof overrides.apply ? overrides.apply : function(name, arr, value) {
    return Function.prototype.apply.call(name, arr, value);
  };
  /** @type {!Function} */
  findHandlers = overrides && "function" === typeof overrides.ownKeys ? overrides.ownKeys : Object.getOwnPropertySymbols ? function(value) {
    return Object.getOwnPropertyNames(value).concat(Object.getOwnPropertySymbols(value));
  } : function(sourceComponent) {
    return Object.getOwnPropertyNames(sourceComponent);
  };
  /** @type {function(number): boolean} */
  var isNumber = Number.isNaN || function(value) {
    return value !== value;
  };
  /** @type {function(): undefined} */
  module.exports = EventEmitter;
  /** @type {function(): undefined} */
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  /** @type {number} */
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  /** @type {number} */
  var builtinEnabled = 10;
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable : true,
    get : function() {
      return builtinEnabled;
    },
    set : function(value) {
      if ("number" !== typeof value || value < 0 || isNumber(value)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + value + ".");
      }
      /** @type {number} */
      builtinEnabled = value;
    }
  });
  /**
   * @return {undefined}
   */
  EventEmitter.init = function() {
    if (!(void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events)) {
      /** @type {!Object} */
      this._events = Object.create(null);
      /** @type {number} */
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  /**
   * @param {number} value
   * @return {?}
   */
  EventEmitter.prototype.setMaxListeners = function(value) {
    if ("number" !== typeof value || value < 0 || isNumber(value)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + value + ".");
    }
    return this._maxListeners = value, this;
  };
  /**
   * @return {?}
   */
  EventEmitter.prototype.getMaxListeners = function() {
    return $getMaxListeners(this);
  };
  /**
   * @param {string} type
   * @return {?}
   */
  EventEmitter.prototype.emit = function(type) {
    /** @type {!Array} */
    var children = [];
    /** @type {number} */
    var i = 1;
    for (; i < arguments.length; i++) {
      children.push(arguments[i]);
    }
    /** @type {boolean} */
    var valid = "error" === type;
    var events = this._events;
    if (void 0 !== events) {
      /** @type {boolean} */
      valid = valid && void 0 === events.error;
    } else {
      if (!valid) {
        return false;
      }
    }
    if (valid) {
      var a;
      if (children.length > 0 && (a = children[0]), a instanceof Error) {
        throw a;
      }
      /** @type {!Error} */
      var m = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
      throw m.context = a, m;
    }
    var t = events[type];
    if (void 0 === t) {
      return false;
    }
    if ("function" === typeof t) {
      callback(t, this, children);
    } else {
      var k = t.length;
      var e = f(t, k);
      /** @type {number} */
      i = 0;
      for (; i < k; ++i) {
        callback(e[i], this, children);
      }
    }
    return true;
  };
  /**
   * @param {string} type
   * @param {!Object} listener
   * @return {?}
   */
  EventEmitter.prototype.addListener = function(type, listener) {
    return _addListener(this, type, listener, false);
  };
  /** @type {function(string, !Object): ?} */
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  /**
   * @param {string} type
   * @param {!Object} listener
   * @return {?}
   */
  EventEmitter.prototype.prependListener = function(type, listener) {
    return _addListener(this, type, listener, true);
  };
  /**
   * @param {string} type
   * @param {!Object} listener
   * @return {?}
   */
  EventEmitter.prototype.once = function(type, listener) {
    return remove(listener), this.on(type, _onceWrap(this, type, listener)), this;
  };
  /**
   * @param {string} type
   * @param {!Object} listener
   * @return {?}
   */
  EventEmitter.prototype.prependOnceListener = function(type, listener) {
    return remove(listener), this.prependListener(type, _onceWrap(this, type, listener)), this;
  };
  /**
   * @param {string} name
   * @param {!Object} listener
   * @return {?}
   */
  EventEmitter.prototype.removeListener = function(name, listener) {
    var list;
    var events;
    var vistab;
    var i;
    var originalListener;
    if (remove(listener), void 0 === (events = this._events)) {
      return this;
    }
    if (void 0 === (list = events[name])) {
      return this;
    }
    if (list === listener || list.listener === listener) {
      if (0 === --this._eventsCount) {
        /** @type {!Object} */
        this._events = Object.create(null);
      } else {
        delete events[name];
        if (events.removeListener) {
          this.emit("removeListener", name, list.listener || listener);
        }
      }
    } else {
      if ("function" !== typeof list) {
        /** @type {number} */
        vistab = -1;
        /** @type {number} */
        i = list.length - 1;
        for (; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            /** @type {number} */
            vistab = i;
            break;
          }
        }
        if (vistab < 0) {
          return this;
        }
        if (0 === vistab) {
          list.shift();
        } else {
          (function(obj, idx) {
            for (; idx + 1 < obj.length; idx++) {
              obj[idx] = obj[idx + 1];
            }
            obj.pop();
          })(list, vistab);
        }
        if (1 === list.length) {
          events[name] = list[0];
        }
        if (void 0 !== events.removeListener) {
          this.emit("removeListener", name, originalListener || listener);
        }
      }
    }
    return this;
  };
  /** @type {function(string, !Object): ?} */
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  /**
   * @param {string} name
   * @return {?}
   */
  EventEmitter.prototype.removeAllListeners = function(name) {
    var listeners;
    var events;
    var i;
    if (void 0 === (events = this._events)) {
      return this;
    }
    if (void 0 === events.removeListener) {
      return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== events[name] && (0 === --this._eventsCount ? this._events = Object.create(null) : delete events[name]), this;
    }
    if (0 === arguments.length) {
      var event;
      /** @type {!Array<string>} */
      var evts = Object.keys(events);
      /** @type {number} */
      i = 0;
      for (; i < evts.length; ++i) {
        if ("removeListener" !== (event = evts[i])) {
          this.removeAllListeners(event);
        }
      }
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this;
    }
    if ("function" === typeof(listeners = events[name])) {
      this.removeListener(name, listeners);
    } else {
      if (void 0 !== listeners) {
        /** @type {number} */
        i = listeners.length - 1;
        for (; i >= 0; i--) {
          this.removeListener(name, listeners[i]);
        }
      }
    }
    return this;
  };
  /**
   * @param {string} type
   * @return {?}
   */
  EventEmitter.prototype.listeners = function(type) {
    return register(this, type, true);
  };
  /**
   * @param {string} key
   * @return {?}
   */
  EventEmitter.prototype.rawListeners = function(key) {
    return register(this, key, false);
  };
  /**
   * @param {string} emitter
   * @param {string} type
   * @return {?}
   */
  EventEmitter.listenerCount = function(emitter, type) {
    return "function" === typeof emitter.listenerCount ? emitter.listenerCount(type) : listenerCount.call(emitter, type);
  };
  /** @type {function(string): ?} */
  EventEmitter.prototype.listenerCount = listenerCount;
  /**
   * @return {?}
   */
  EventEmitter.prototype.eventNames = function() {
    return this._eventsCount > 0 ? findHandlers(this._events) : [];
  };
}, function(module, global, factory) {
  /**
   * @param {!Object} a
   * @param {!Function} obj
   * @return {undefined}
   */
  function expect(a, obj) {
    var prop;
    for (prop in a) {
      obj[prop] = a[prop];
    }
  }
  /**
   * @param {?} data
   * @param {!Array} callback
   * @param {!Object} name
   * @return {?}
   */
  function Buffer(data, callback, name) {
    return fn(data, callback, name);
  }
  var exports = factory(3);
  var fn = exports.Buffer;
  if (fn.from && fn.alloc && fn.allocUnsafe && fn.allocUnsafeSlow) {
    module.exports = exports;
  } else {
    expect(exports, global);
    /** @type {function(?, !Array, !Object): ?} */
    global.Buffer = Buffer;
  }
  expect(fn, Buffer);
  /**
   * @param {?} data
   * @param {?} str
   * @param {!Object} length
   * @return {?}
   */
  Buffer.from = function(data, str, length) {
    if ("number" === typeof data) {
      throw new TypeError("Argument must not be a number");
    }
    return fn(data, str, length);
  };
  /**
   * @param {?} num
   * @param {number} value
   * @param {undefined} attr
   * @return {?}
   */
  Buffer.alloc = function(num, value, attr) {
    if ("number" !== typeof num) {
      throw new TypeError("Argument must be a number");
    }
    var ret = fn(num);
    return void 0 !== value ? "string" === typeof attr ? ret.fill(value, attr) : ret.fill(value) : ret.fill(0), ret;
  };
  /**
   * @param {?} a
   * @return {?}
   */
  Buffer.allocUnsafe = function(a) {
    if ("number" !== typeof a) {
      throw new TypeError("Argument must be a number");
    }
    return fn(a);
  };
  /**
   * @param {?} a
   * @return {?}
   */
  Buffer.allocUnsafeSlow = function(a) {
    if ("number" !== typeof a) {
      throw new TypeError("Argument must be a number");
    }
    return exports.SlowBuffer(a);
  };
}, function(module, canCreateDiscussions, require) {
  (function(target, ndebug, PL$3) {
    /**
     * @param {?} name
     * @return {undefined}
     */
    function execute(name) {
      var _this3 = this;
      /** @type {null} */
      this.next = null;
      /** @type {null} */
      this.entry = null;
      /**
       * @return {undefined}
       */
      this.finish = function() {
        !function(_this, state, fallbackReleases) {
          var entry = _this.entry;
          /** @type {null} */
          _this.entry = null;
          for (; entry;) {
            var cb = entry.callback;
            state.pendingcb--;
            cb(fallbackReleases);
            entry = entry.next;
          }
          if (state.corkedRequestsFree) {
            /** @type {!Object} */
            state.corkedRequestsFree.next = _this;
          } else {
            /** @type {!Object} */
            state.corkedRequestsFree = _this;
          }
        }(_this3, name);
      };
    }
    /**
     * @return {undefined}
     */
    function killProcess() {
    }
    /**
     * @param {!Object} options
     * @param {?} resource
     * @return {undefined}
     */
    function WritableState(options, resource) {
      Model = Model || require(13);
      options = options || {};
      /** @type {boolean} */
      var isISO = resource instanceof Model;
      /** @type {boolean} */
      this.objectMode = !!options.objectMode;
      if (isISO) {
        /** @type {boolean} */
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      }
      var hwm = options.highWaterMark;
      var tz = options.writableHighWaterMark;
      /** @type {number} */
      var defaultHwm = this.objectMode ? 16 : 16384;
      this.highWaterMark = hwm || 0 === hwm ? hwm : isISO && (tz || 0 === tz) ? tz : defaultHwm;
      /** @type {number} */
      this.highWaterMark = Math.floor(this.highWaterMark);
      /** @type {boolean} */
      this.finalCalled = false;
      /** @type {boolean} */
      this.needDrain = false;
      /** @type {boolean} */
      this.ending = false;
      /** @type {boolean} */
      this.ended = false;
      /** @type {boolean} */
      this.finished = false;
      /** @type {boolean} */
      this.destroyed = false;
      /** @type {boolean} */
      var noDecode = false === options.decodeStrings;
      /** @type {boolean} */
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      /** @type {number} */
      this.length = 0;
      /** @type {boolean} */
      this.writing = false;
      /** @type {number} */
      this.corked = 0;
      /** @type {boolean} */
      this.sync = true;
      /** @type {boolean} */
      this.bufferProcessing = false;
      /**
       * @param {?} e
       * @return {undefined}
       */
      this.onwrite = function(e) {
        !function(self, fn) {
          var state = self._writableState;
          var sync = state.sync;
          var t = state.writecb;
          if (function(state) {
            /** @type {boolean} */
            state.writing = false;
            /** @type {null} */
            state.writecb = null;
            state.length -= state.writelen;
            /** @type {number} */
            state.writelen = 0;
          }(state), fn) {
            !function(stream, state, events, callback, cb) {
              --state.pendingcb;
              if (events) {
                process.nextTick(cb, callback);
                process.nextTick(done, stream, state);
                /** @type {boolean} */
                stream._writableState.errorEmitted = true;
                stream.emit("error", callback);
              } else {
                cb(callback);
                /** @type {boolean} */
                stream._writableState.errorEmitted = true;
                stream.emit("error", callback);
                done(stream, state);
              }
            }(self, state, sync, fn, t);
          } else {
            var value = needFinish(state);
            if (!(value || state.corked || state.bufferProcessing || !state.bufferedRequest)) {
              clearBuffer(self, state);
            }
            if (sync) {
              debug(create, self, state, value, t);
            } else {
              create(self, state, value, t);
            }
          }
        }(resource, e);
      };
      /** @type {null} */
      this.writecb = null;
      /** @type {number} */
      this.writelen = 0;
      /** @type {null} */
      this.bufferedRequest = null;
      /** @type {null} */
      this.lastBufferedRequest = null;
      /** @type {number} */
      this.pendingcb = 0;
      /** @type {boolean} */
      this.prefinished = false;
      /** @type {boolean} */
      this.errorEmitted = false;
      /** @type {number} */
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new execute(this);
    }
    /**
     * @param {!Object} options
     * @return {?}
     */
    function Writable(options) {
      if (Model = Model || require(13), !p.call(Writable, this) && !(this instanceof Model)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      /** @type {boolean} */
      this.writable = true;
      if (options) {
        if ("function" === typeof options.write) {
          /** @type {!Function} */
          this._write = options.write;
        }
        if ("function" === typeof options.writev) {
          /** @type {!Function} */
          this._writev = options.writev;
        }
        if ("function" === typeof options.destroy) {
          /** @type {!Function} */
          this._destroy = options.destroy;
        }
        if ("function" === typeof options.final) {
          /** @type {!Function} */
          this._final = options.final;
        }
      }
      Polling.call(this);
    }
    /**
     * @param {?} stream
     * @param {!Object} state
     * @param {boolean} writev
     * @param {number} len
     * @param {string} chunk
     * @param {?} encoding
     * @param {string} cb
     * @return {undefined}
     */
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      /** @type {number} */
      state.writelen = len;
      /** @type {string} */
      state.writecb = cb;
      /** @type {boolean} */
      state.writing = true;
      /** @type {boolean} */
      state.sync = true;
      if (writev) {
        stream._writev(chunk, state.onwrite);
      } else {
        stream._write(chunk, encoding, state.onwrite);
      }
      /** @type {boolean} */
      state.sync = false;
    }
    /**
     * @param {!Object} stream
     * @param {!Object} state
     * @param {?} template
     * @param {?} cb
     * @return {undefined}
     */
    function create(stream, state, template, cb) {
      if (!template) {
        (function(stream, state) {
          if (0 === state.length && state.needDrain) {
            /** @type {boolean} */
            state.needDrain = false;
            stream.emit("drain");
          }
        })(stream, state);
      }
      state.pendingcb--;
      cb();
      done(stream, state);
    }
    /**
     * @param {?} stream
     * @param {!Object} state
     * @return {undefined}
     */
    function clearBuffer(stream, state) {
      /** @type {boolean} */
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        /** @type {!Array} */
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        /** @type {number} */
        var i = 0;
        /** @type {boolean} */
        var allBuffers = true;
        for (; entry;) {
          buffer[i] = entry;
          if (!entry.isBuf) {
            /** @type {boolean} */
            allBuffers = false;
          }
          entry = entry.next;
          /** @type {number} */
          i = i + 1;
        }
        /** @type {boolean} */
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        /** @type {null} */
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          /** @type {null} */
          holder.next = null;
        } else {
          state.corkedRequestsFree = new execute(state);
        }
        /** @type {number} */
        state.bufferedRequestCount = 0;
      } else {
        for (; entry;) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          if (doWrite(stream, state, false, state.objectMode ? 1 : chunk.length, chunk, encoding, cb), entry = entry.next, state.bufferedRequestCount--, state.writing) {
            break;
          }
        }
        if (null === entry) {
          /** @type {null} */
          state.lastBufferedRequest = null;
        }
      }
      state.bufferedRequest = entry;
      /** @type {boolean} */
      state.bufferProcessing = false;
    }
    /**
     * @param {!Object} state
     * @return {?}
     */
    function needFinish(state) {
      return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing;
    }
    /**
     * @param {!Object} stream
     * @param {!Object} state
     * @return {undefined}
     */
    function onComplete(stream, state) {
      stream._final(function(data) {
        state.pendingcb--;
        if (data) {
          stream.emit("error", data);
        }
        /** @type {boolean} */
        state.prefinished = true;
        stream.emit("prefinish");
        done(stream, state);
      });
    }
    /**
     * @param {!Object} stream
     * @param {!Object} state
     * @return {?}
     */
    function done(stream, state) {
      var finished = needFinish(state);
      return finished && (!function(stream, state) {
        if (!(state.prefinished || state.finalCalled)) {
          if ("function" === typeof stream._final) {
            state.pendingcb++;
            /** @type {boolean} */
            state.finalCalled = true;
            process.nextTick(onComplete, stream, state);
          } else {
            /** @type {boolean} */
            state.prefinished = true;
            stream.emit("prefinish");
          }
        }
      }(stream, state), 0 === state.pendingcb && (state.finished = true, stream.emit("finish"))), finished;
    }
    var process = require(30);
    /** @type {function(!Object): ?} */
    module.exports = Writable;
    var Model;
    var debug = !target.browser && ["v0.10", "v0.9."].indexOf(target.version.slice(0, 5)) > -1 ? ndebug : process.nextTick;
    /** @type {function(!Object, ?): undefined} */
    Writable.WritableState = WritableState;
    /** @type {!Object} */
    var util = Object.create(require(21));
    util.inherits = require(1);
    var exports = {
      deprecate : require(125)
    };
    var Polling = require(67);
    var Buffer = require(40).Buffer;
    var Stream = PL$3.Uint8Array || function() {
    };
    var p;
    var unzip = require(68);
    util.inherits(Writable, Polling);
    /**
     * @return {?}
     */
    WritableState.prototype.getBuffer = function() {
      var current = this.bufferedRequest;
      /** @type {!Array} */
      var out = [];
      for (; current;) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get : exports.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (e) {
      }
    })();
    if ("function" === typeof Symbol && Symbol.hasInstance && "function" === typeof Function.prototype[Symbol.hasInstance]) {
      p = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value : function(value) {
          return !!p.call(this, value) || this === Writable && (value && value._writableState instanceof WritableState);
        }
      });
    } else {
      /**
       * @param {?} args_for_p
       * @return {?}
       */
      p = function(args_for_p) {
        return args_for_p instanceof this;
      };
    }
    /**
     * @return {undefined}
     */
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    /**
     * @param {!Object} name
     * @param {!Object} value
     * @param {!Function} cb
     * @return {?}
     */
    Writable.prototype.write = function(name, value, cb) {
      var data;
      var state = this._writableState;
      /** @type {boolean} */
      var ret = false;
      var isBuf = !state.objectMode && (data = name, Buffer.isBuffer(data) || data instanceof Stream);
      return isBuf && !Buffer.isBuffer(name) && (name = function(e) {
        return Buffer.from(e);
      }(name)), "function" === typeof value && (cb = value, value = null), isBuf ? value = "buffer" : value || (value = state.defaultEncoding), "function" !== typeof cb && (cb = killProcess), state.ended ? function(e, func) {
        /** @type {!Error} */
        var err = new Error("write after end");
        e.emit("error", err);
        process.nextTick(func, err);
      }(this, cb) : (isBuf || function(e, state, type, func) {
        /** @type {boolean} */
        var i = true;
        /** @type {boolean} */
        var err = false;
        return null === type ? err = new TypeError("May not write null values to stream") : "string" === typeof type || void 0 === type || state.objectMode || (err = new TypeError("Invalid non-string/buffer chunk")), err && (e.emit("error", err), process.nextTick(func, err), i = false), i;
      }(this, state, name, cb)) && (state.pendingcb++, ret = function(stream, state, isBuf, chunk, encoding, cb) {
        if (!isBuf) {
          var newChunk = function(state, x, value) {
            if (!(state.objectMode || false === state.decodeStrings || "string" !== typeof x)) {
              x = Buffer.from(x, value);
            }
            return x;
          }(state, chunk, encoding);
          if (chunk !== newChunk) {
            /** @type {boolean} */
            isBuf = true;
            /** @type {string} */
            encoding = "buffer";
            chunk = newChunk;
          }
        }
        var len = state.objectMode ? 1 : chunk.length;
        state.length += len;
        /** @type {boolean} */
        var exists = state.length < state.highWaterMark;
        if (!exists) {
          /** @type {boolean} */
          state.needDrain = true;
        }
        if (state.writing || state.corked) {
          var last = state.lastBufferedRequest;
          state.lastBufferedRequest = {
            chunk : chunk,
            encoding : encoding,
            isBuf : isBuf,
            callback : cb,
            next : null
          };
          if (last) {
            last.next = state.lastBufferedRequest;
          } else {
            state.bufferedRequest = state.lastBufferedRequest;
          }
          state.bufferedRequestCount += 1;
        } else {
          doWrite(stream, state, false, len, chunk, encoding, cb);
        }
        return exists;
      }(this, state, isBuf, name, value, cb)), ret;
    };
    /**
     * @return {undefined}
     */
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    /**
     * @return {undefined}
     */
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!(state.writing || state.corked || state.finished || state.bufferProcessing || !state.bufferedRequest)) {
          clearBuffer(this, state);
        }
      }
    };
    /**
     * @param {string} encoding
     * @return {?}
     */
    Writable.prototype.setDefaultEncoding = function(encoding) {
      if ("string" === typeof encoding && (encoding = encoding.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      return this._writableState.defaultEncoding = encoding, this;
    };
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable : false,
      get : function() {
        return this._writableState.highWaterMark;
      }
    });
    /**
     * @param {!Object} type
     * @param {!Object} value
     * @param {number} callback
     * @return {undefined}
     */
    Writable.prototype._write = function(type, value, callback) {
      callback(new Error("_write() is not implemented"));
    };
    /** @type {null} */
    Writable.prototype._writev = null;
    /**
     * @param {?} value
     * @param {string} data
     * @param {string} instance
     * @return {undefined}
     */
    Writable.prototype.end = function(value, data, instance) {
      var state = this._writableState;
      if ("function" === typeof value) {
        /** @type {!Function} */
        instance = value;
        /** @type {null} */
        value = null;
        /** @type {null} */
        data = null;
      } else {
        if ("function" === typeof data) {
          /** @type {string} */
          instance = data;
          /** @type {null} */
          data = null;
        }
      }
      if (null !== value && void 0 !== value) {
        this.write(value, data);
      }
      if (state.corked) {
        /** @type {number} */
        state.corked = 1;
        this.uncork();
      }
      if (!(state.ending || state.finished)) {
        (function(t, state, func) {
          /** @type {boolean} */
          state.ending = true;
          done(t, state);
          if (func) {
            if (state.finished) {
              process.nextTick(func);
            } else {
              t.once("finish", func);
            }
          }
          /** @type {boolean} */
          state.ended = true;
          /** @type {boolean} */
          t.writable = false;
        })(this, state, instance);
      }
    };
    Object.defineProperty(Writable.prototype, "destroyed", {
      get : function() {
        return void 0 !== this._writableState && this._writableState.destroyed;
      },
      set : function(value) {
        if (this._writableState) {
          /** @type {string} */
          this._writableState.destroyed = value;
        }
      }
    });
    Writable.prototype.destroy = unzip.destroy;
    Writable.prototype._undestroy = unzip.undestroy;
    /**
     * @param {string} key
     * @param {string} callback
     * @return {undefined}
     */
    Writable.prototype._destroy = function(key, callback) {
      this.end();
      callback(key);
    };
  }).call(this, require(8), require(123).setImmediate, require(5));
}, function(canCreateDiscussions, exports, require) {
  /**
   * @param {string} encoding
   * @return {?}
   */
  function write(encoding) {
    var arg1;
    switch(this.encoding = function(type) {
      var msg = function(encoding) {
        if (!encoding) {
          return "utf8";
        }
        var t;
        for (;;) {
          switch(encoding) {
            case "utf8":
            case "utf-8":
              return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return "utf16le";
            case "latin1":
            case "binary":
              return "latin1";
            case "base64":
            case "ascii":
            case "hex":
              return encoding;
            default:
              if (t) {
                return;
              }
              /** @type {string} */
              encoding = ("" + encoding).toLowerCase();
              /** @type {boolean} */
              t = true;
          }
        }
      }(type);
      if ("string" !== typeof msg && (Buffer.isEncoding === isStruct || !isStruct(type))) {
        throw new Error("Unknown encoding: " + type);
      }
      return msg || type;
    }(encoding), this.encoding) {
      case "utf16le":
        /** @type {function(!Object, number): ?} */
        this.text = decodeString;
        /** @type {function(!Object): ?} */
        this.end = toString;
        /** @type {number} */
        arg1 = 4;
        break;
      case "utf8":
        /** @type {function(!Object): ?} */
        this.fillLast = s;
        /** @type {number} */
        arg1 = 4;
        break;
      case "base64":
        /** @type {function(!Object, number): ?} */
        this.text = str;
        /** @type {function(!Object): ?} */
        this.end = e;
        /** @type {number} */
        arg1 = 3;
        break;
      default:
        return this.write = passThroughWrite, void(this.end = v);
    }
    /** @type {number} */
    this.lastNeed = 0;
    /** @type {number} */
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(arg1);
  }
  /**
   * @param {number} text
   * @return {?}
   */
  function parseInt(text) {
    return text <= 127 ? 0 : text >> 5 === 6 ? 2 : text >> 4 === 14 ? 3 : text >> 3 === 30 ? 4 : text >> 6 === 2 ? -1 : -2;
  }
  /**
   * @param {!Object} buf
   * @return {?}
   */
  function s(buf) {
    /** @type {number} */
    var p = this.lastTotal - this.lastNeed;
    var charsWritten = function(self, dst, canCreateDiscussions) {
      if (128 !== (192 & dst[0])) {
        return self.lastNeed = 0, "\ufffd";
      }
      if (self.lastNeed > 1 && dst.length > 1) {
        if (128 !== (192 & dst[1])) {
          return self.lastNeed = 1, "\ufffd";
        }
        if (self.lastNeed > 2 && dst.length > 2 && 128 !== (192 & dst[2])) {
          return self.lastNeed = 2, "\ufffd";
        }
      }
    }(this, buf);
    return void 0 !== charsWritten ? charsWritten : this.lastNeed <= buf.length ? (buf.copy(this.lastChar, p, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (buf.copy(this.lastChar, p, 0, buf.length), void(this.lastNeed -= buf.length));
  }
  /**
   * @param {!Object} buf
   * @param {number} offset
   * @return {?}
   */
  function decodeString(buf, offset) {
    if ((buf.length - offset) % 2 === 0) {
      var match = buf.toString("utf16le", offset);
      if (match) {
        var n = match.charCodeAt(match.length - 1);
        if (n >= 55296 && n <= 56319) {
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1], match.slice(0, -1);
        }
      }
      return match;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], buf.toString("utf16le", offset, buf.length - 1);
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function toString(value) {
    var r = value && value.length ? this.write(value) : "";
    if (this.lastNeed) {
      /** @type {number} */
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  /**
   * @param {!Object} buf
   * @param {number} i
   * @return {?}
   */
  function str(buf, i) {
    /** @type {number} */
    var n = (buf.length - i) % 3;
    return 0 === n ? buf.toString("base64", i) : (this.lastNeed = 3 - n, this.lastTotal = 3, 1 === n ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], this.lastChar[1] = buf[buf.length - 1]), buf.toString("base64", i, buf.length - n));
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function e(value) {
    var dataUrl = value && value.length ? this.write(value) : "";
    return this.lastNeed ? dataUrl + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : dataUrl;
  }
  /**
   * @param {!Object} data
   * @return {?}
   */
  function passThroughWrite(data) {
    return data.toString(this.encoding);
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function v(value) {
    return value && value.length ? this.write(value) : "";
  }
  var Buffer = require(2).Buffer;
  var isStruct = Buffer.isEncoding || function(value) {
    switch((value = "" + value) && value.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  /** @type {function(string): ?} */
  exports.StringDecoder = write;
  /**
   * @param {!Object} buf
   * @return {?}
   */
  write.prototype.write = function(buf) {
    if (0 === buf.length) {
      return "";
    }
    var r;
    var i;
    if (this.lastNeed) {
      if (void 0 === (r = this.fillLast(buf))) {
        return "";
      }
      i = this.lastNeed;
      /** @type {number} */
      this.lastNeed = 0;
    } else {
      /** @type {number} */
      i = 0;
    }
    return i < buf.length ? r ? r + this.text(buf, i) : this.text(buf, i) : r || "";
  };
  /**
   * @param {!Object} value
   * @return {?}
   */
  write.prototype.end = function(value) {
    var opt_by = value && value.length ? this.write(value) : "";
    return this.lastNeed ? opt_by + "\ufffd" : opt_by;
  };
  /**
   * @param {!Object} buf
   * @param {number} i
   * @return {?}
   */
  write.prototype.text = function(buf, i) {
    var total = function(self, p, i) {
      /** @type {number} */
      var j = p.length - 1;
      if (j < i) {
        return 0;
      }
      var nb = parseInt(p[j]);
      if (nb >= 0) {
        return nb > 0 && (self.lastNeed = nb - 1), nb;
      }
      if (--j < i || -2 === nb) {
        return 0;
      }
      if ((nb = parseInt(p[j])) >= 0) {
        return nb > 0 && (self.lastNeed = nb - 2), nb;
      }
      if (--j < i || -2 === nb) {
        return 0;
      }
      if ((nb = parseInt(p[j])) >= 0) {
        return nb > 0 && (2 === nb ? nb = 0 : self.lastNeed = nb - 3), nb;
      }
      return 0;
    }(this, buf, i);
    if (!this.lastNeed) {
      return buf.toString("utf8", i);
    }
    this.lastTotal = total;
    /** @type {number} */
    var index = buf.length - (total - this.lastNeed);
    return buf.copy(this.lastChar, 0, index), buf.toString("utf8", i, index);
  };
  /**
   * @param {!Object} buf
   * @return {?}
   */
  write.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Filter() {
    Duplex.call(this, 64);
    /** @type {number} */
    this._a = 1732584193;
    /** @type {number} */
    this._b = 4023233417;
    /** @type {number} */
    this._c = 2562383102;
    /** @type {number} */
    this._d = 271733878;
    /** @type {number} */
    this._e = 3285377520;
  }
  /**
   * @param {number} a
   * @param {number} s
   * @return {?}
   */
  function $(a, s) {
    return a << s | a >>> 32 - s;
  }
  /**
   * @param {number} n
   * @param {number} c
   * @param {number} d
   * @param {number} e
   * @param {number} t
   * @param {?} event
   * @param {?} callback
   * @param {undefined} start
   * @return {?}
   */
  function fn(n, c, d, e, t, event, callback, start) {
    return $(n + (c ^ d ^ e) + event + callback | 0, start) + t | 0;
  }
  /**
   * @param {number} str
   * @param {number} c
   * @param {number} b
   * @param {number} a
   * @param {number} _
   * @param {?} v
   * @param {?} n
   * @param {undefined} i
   * @return {?}
   */
  function format(str, c, b, a, _, v, n, i) {
    return $(str + (c & b | ~c & a) + v + n | 0, i) + _ | 0;
  }
  /**
   * @param {number} n
   * @param {number} c
   * @param {number} a
   * @param {number} v
   * @param {number} _
   * @param {?} s
   * @param {?} t
   * @param {undefined} i
   * @return {?}
   */
  function func(n, c, a, v, _, s, t, i) {
    return $(n + ((c | ~a) ^ v) + s + t | 0, i) + _ | 0;
  }
  /**
   * @param {number} msg
   * @param {number} c
   * @param {number} d
   * @param {number} e
   * @param {number} result
   * @param {?} url
   * @param {?} query
   * @param {undefined} start
   * @return {?}
   */
  function callback(msg, c, d, e, result, url, query, start) {
    return $(msg + (c & e | d & ~e) + url + query | 0, start) + result | 0;
  }
  /**
   * @param {number} str
   * @param {number} e
   * @param {number} c
   * @param {number} d
   * @param {number} _
   * @param {?} p
   * @param {?} i
   * @param {undefined} j
   * @return {?}
   */
  function f(str, e, c, d, _, p, i, j) {
    return $(str + (e ^ (c | ~d)) + p + i | 0, j) + _ | 0;
  }
  var Buffer = require(3).Buffer;
  var inherits = require(1);
  var Duplex = require(65);
  /** @type {!Array} */
  var y2 = new Array(16);
  /** @type {!Array} */
  var aRadio = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  /** @type {!Array} */
  var attrSpecial = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  /** @type {!Array} */
  var args = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  /** @type {!Array} */
  var newObserved = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  /** @type {!Array} */
  var cave = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  /** @type {!Array} */
  var xCords = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  inherits(Filter, Duplex);
  /**
   * @return {undefined}
   */
  Filter.prototype._update = function() {
    /** @type {!Array} */
    var updatedRadios = y2;
    /** @type {number} */
    var indexLookupKey = 0;
    for (; indexLookupKey < 16; ++indexLookupKey) {
      updatedRadios[indexLookupKey] = this._block.readInt32LE(4 * indexLookupKey);
    }
    /** @type {number} */
    var e = 0 | this._a;
    /** @type {number} */
    var a = 0 | this._b;
    /** @type {number} */
    var b = 0 | this._c;
    /** @type {number} */
    var c = 0 | this._d;
    /** @type {number} */
    var t = 0 | this._e;
    /** @type {number} */
    var s = 0 | this._a;
    /** @type {number} */
    var code = 0 | this._b;
    /** @type {number} */
    var d = 0 | this._c;
    /** @type {number} */
    var data = 0 | this._d;
    /** @type {number} */
    var i = 0 | this._e;
    /** @type {number} */
    var name = 0;
    for (; name < 80; name = name + 1) {
      var ret;
      var result;
      if (name < 16) {
        ret = fn(e, a, b, c, t, updatedRadios[aRadio[name]], cave[0], args[name]);
        result = f(s, code, d, data, i, updatedRadios[attrSpecial[name]], xCords[0], newObserved[name]);
      } else {
        if (name < 32) {
          ret = format(e, a, b, c, t, updatedRadios[aRadio[name]], cave[1], args[name]);
          result = callback(s, code, d, data, i, updatedRadios[attrSpecial[name]], xCords[1], newObserved[name]);
        } else {
          if (name < 48) {
            ret = func(e, a, b, c, t, updatedRadios[aRadio[name]], cave[2], args[name]);
            result = func(s, code, d, data, i, updatedRadios[attrSpecial[name]], xCords[2], newObserved[name]);
          } else {
            if (name < 64) {
              ret = callback(e, a, b, c, t, updatedRadios[aRadio[name]], cave[3], args[name]);
              result = format(s, code, d, data, i, updatedRadios[attrSpecial[name]], xCords[3], newObserved[name]);
            } else {
              ret = f(e, a, b, c, t, updatedRadios[aRadio[name]], cave[4], args[name]);
              result = fn(s, code, d, data, i, updatedRadios[attrSpecial[name]], xCords[4], newObserved[name]);
            }
          }
        }
      }
      e = t;
      t = c;
      c = $(b, 10);
      /** @type {(number|undefined)} */
      b = a;
      a = ret;
      s = i;
      i = data;
      data = $(d, 10);
      /** @type {(number|undefined)} */
      d = code;
      code = result;
    }
    /** @type {number} */
    var newA = this._b + b + data | 0;
    /** @type {number} */
    this._b = this._c + c + i | 0;
    /** @type {number} */
    this._c = this._d + t + s | 0;
    /** @type {number} */
    this._d = this._e + e + code | 0;
    /** @type {number} */
    this._e = this._a + a + d | 0;
    /** @type {number} */
    this._a = newA;
  };
  /**
   * @return {?}
   */
  Filter.prototype._digest = function() {
    /** @type {number} */
    this._block[this._blockOffset++] = 128;
    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);
      this._update();
      /** @type {number} */
      this._blockOffset = 0;
    }
    this._block.fill(0, this._blockOffset, 56);
    this._block.writeUInt32LE(this._length[0], 56);
    this._block.writeUInt32LE(this._length[1], 60);
    this._update();
    var H = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
    return H.writeInt32LE(this._a, 0), H.writeInt32LE(this._b, 4), H.writeInt32LE(this._c, 8), H.writeInt32LE(this._d, 12), H.writeInt32LE(this._e, 16), H;
  };
  /** @type {function(): undefined} */
  module.exports = Filter;
}, function(mixin, hash_fns, objectHash) {
  (hash_fns = mixin.exports = function(key) {
    key = key.toLowerCase();
    var Class = hash_fns[key];
    if (!Class) {
      throw new Error(key + " is not supported (we accept pull requests)");
    }
    return new Class;
  }).sha = objectHash(131);
  hash_fns.sha1 = objectHash(132);
  hash_fns.sha224 = objectHash(133);
  hash_fns.sha256 = objectHash(70);
  hash_fns.sha384 = objectHash(134);
  hash_fns.sha512 = objectHash(71);
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function Cipher(key) {
    /** @type {string} */
    this.options = key;
    this.type = this.options.type;
    /** @type {number} */
    this.blockSize = 8;
    this._init();
    /** @type {!Array} */
    this.buffer = new Array(this.blockSize);
    /** @type {number} */
    this.bufferOff = 0;
  }
  var assert = require(6);
  /** @type {function(string): undefined} */
  module.exports = Cipher;
  /**
   * @return {undefined}
   */
  Cipher.prototype._init = function() {
  };
  /**
   * @param {!Object} data
   * @return {?}
   */
  Cipher.prototype.update = function(data) {
    return 0 === data.length ? [] : "decrypt" === this.type ? this._updateDecrypt(data) : this._updateEncrypt(data);
  };
  /**
   * @param {!Object} data
   * @param {number} off
   * @return {?}
   */
  Cipher.prototype._buffer = function(data, off) {
    /** @type {number} */
    var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
    /** @type {number} */
    var i = 0;
    for (; i < min; i++) {
      this.buffer[this.bufferOff + i] = data[off + i];
    }
    return this.bufferOff += min, min;
  };
  /**
   * @param {!Array} out
   * @param {number} off
   * @return {?}
   */
  Cipher.prototype._flushBuffer = function(out, off) {
    return this._update(this.buffer, 0, out, off), this.bufferOff = 0, this.blockSize;
  };
  /**
   * @param {!Array} data
   * @return {?}
   */
  Cipher.prototype._updateEncrypt = function(data) {
    /** @type {number} */
    var inputOff = 0;
    /** @type {number} */
    var outputOff = 0;
    /** @type {number} */
    var count = (this.bufferOff + data.length) / this.blockSize | 0;
    /** @type {!Array} */
    var out = new Array(count * this.blockSize);
    if (0 !== this.bufferOff) {
      inputOff = inputOff + this._buffer(data, inputOff);
      if (this.bufferOff === this.buffer.length) {
        outputOff = outputOff + this._flushBuffer(out, outputOff);
      }
    }
    /** @type {number} */
    var max = data.length - (data.length - inputOff) % this.blockSize;
    for (; inputOff < max; inputOff = inputOff + this.blockSize) {
      this._update(data, inputOff, out, outputOff);
      outputOff = outputOff + this.blockSize;
    }
    for (; inputOff < data.length; inputOff++, this.bufferOff++) {
      this.buffer[this.bufferOff] = data[inputOff];
    }
    return out;
  };
  /**
   * @param {!Object} data
   * @return {?}
   */
  Cipher.prototype._updateDecrypt = function(data) {
    /** @type {number} */
    var inputOff = 0;
    /** @type {number} */
    var outputOff = 0;
    /** @type {number} */
    var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
    /** @type {!Array} */
    var out = new Array(count * this.blockSize);
    for (; count > 0; count--) {
      inputOff = inputOff + this._buffer(data, inputOff);
      outputOff = outputOff + this._flushBuffer(out, outputOff);
    }
    return inputOff = inputOff + this._buffer(data, inputOff), out;
  };
  /**
   * @param {?} next
   * @return {?}
   */
  Cipher.prototype.final = function(next) {
    var result;
    var array;
    return next && (result = this.update(next)), array = "encrypt" === this.type ? this._finalEncrypt() : this._finalDecrypt(), result ? result.concat(array) : array;
  };
  /**
   * @param {!Object} buffer
   * @param {string} off
   * @return {?}
   */
  Cipher.prototype._pad = function(buffer, off) {
    if (0 === off) {
      return false;
    }
    for (; off < buffer.length;) {
      /** @type {number} */
      buffer[off++] = 0;
    }
    return true;
  };
  /**
   * @return {?}
   */
  Cipher.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff)) {
      return [];
    }
    /** @type {!Array} */
    var out = new Array(this.blockSize);
    return this._update(this.buffer, 0, out, 0), out;
  };
  /**
   * @param {!Array} buffer
   * @return {?}
   */
  Cipher.prototype._unpad = function(buffer) {
    return buffer;
  };
  /**
   * @return {?}
   */
  Cipher.prototype._finalDecrypt = function() {
    assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    /** @type {!Array} */
    var out = new Array(this.blockSize);
    return this._flushBuffer(out, 0), this._unpad(out);
  };
}, function(canCreateDiscussions, crypto, require) {
  var ourCrypto = require(143);
  var ciphers = require(151);
  var thisParcelBundles = require(83);
  crypto.createCipher = crypto.Cipher = ourCrypto.createCipher;
  crypto.createCipheriv = crypto.Cipheriv = ourCrypto.createCipheriv;
  crypto.createDecipher = crypto.Decipher = ciphers.createDecipher;
  crypto.createDecipheriv = crypto.Decipheriv = ciphers.createDecipheriv;
  /** @type {function(): ?} */
  crypto.listCiphers = crypto.getCiphers = function() {
    return Object.keys(thisParcelBundles);
  };
}, function(m, canCreateDiscussions, matchMedia) {
  var modelist = {
    ECB : matchMedia(144),
    CBC : matchMedia(145),
    CFB : matchMedia(146),
    CFB8 : matchMedia(147),
    CFB1 : matchMedia(148),
    OFB : matchMedia(149),
    CTR : matchMedia(81),
    GCM : matchMedia(81)
  };
  var q = matchMedia(83);
  var i;
  for (i in q) {
    q[i].module = modelist[q[i].mode];
  }
  m.exports = q;
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @param {string} destinationCoordinates
   * @return {undefined}
   */
  function Map(destinationCoordinates) {
    /** @type {string} */
    this.rand = destinationCoordinates;
  }
  var attrs;
  if (mixin.exports = function(value) {
    return attrs || (attrs = new Map(null)), attrs.generate(value);
  }, mixin.exports.Rand = Map, Map.prototype.generate = function(src) {
    return this._rand(src);
  }, Map.prototype._rand = function(count) {
    if (this.rand.getBytes) {
      return this.rand.getBytes(count);
    }
    /** @type {!Uint8Array} */
    var arr = new Uint8Array(count);
    /** @type {number} */
    var i = 0;
    for (; i < arr.length; i++) {
      arr[i] = this.rand.getByte();
    }
    return arr;
  }, "object" === typeof self) {
    if (self.crypto && self.crypto.getRandomValues) {
      /**
       * @param {!Object} max
       * @return {?}
       */
      Map.prototype._rand = function(max) {
        /** @type {!Uint8Array} */
        var array = new Uint8Array(max);
        return self.crypto.getRandomValues(array), array;
      };
    } else {
      if (self.msCrypto && self.msCrypto.getRandomValues) {
        /**
         * @param {!Object} max
         * @return {?}
         */
        Map.prototype._rand = function(max) {
          /** @type {!Uint8Array} */
          var array = new Uint8Array(max);
          return self.msCrypto.getRandomValues(array), array;
        };
      } else {
        if ("object" === typeof window) {
          /**
           * @return {?}
           */
          Map.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      }
    }
  } else {
    try {
      var crypto = require(155);
      if ("function" !== typeof crypto.randomBytes) {
        throw new Error("Not supported");
      }
      /**
       * @param {!Object} arr
       * @return {?}
       */
      Map.prototype._rand = function(arr) {
        return crypto.randomBytes(arr);
      };
    } catch (a) {
    }
  }
}, function(module, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {string} key
     * @param {!Object} priv
     * @return {?}
     */
    function crt(key, priv) {
      var blinds = function(priv) {
        var r = getr(priv);
        return {
          blinder : r.toRed(bn.mont(priv.modulus)).redPow(new bn(priv.publicExponent)).fromRed(),
          unblinder : r.invm(priv.modulus)
        };
      }(priv);
      var bytes = priv.modulus.byteLength();
      var y = (bn.mont(priv.modulus), (new bn(key)).mul(blinds.blinder).umod(priv.modulus));
      var c1 = y.toRed(bn.mont(priv.prime1));
      var c2 = y.toRed(bn.mont(priv.prime2));
      var al9 = priv.coefficient;
      var p = priv.prime1;
      var q = priv.prime2;
      var m1 = c1.redPow(priv.exponent1);
      var m2 = c2.redPow(priv.exponent2);
      m1 = m1.fromRed();
      m2 = m2.fromRed();
      var h = m1.isub(m2).imul(al9).umod(p);
      return h.imul(q), m2.iadd(h), new Buffer(m2.imul(blinds.unblinder).umod(priv.modulus).toArray(false, bytes));
    }
    /**
     * @param {?} priv
     * @return {?}
     */
    function getr(priv) {
      var len = priv.modulus.byteLength();
      var r = new bn(randomBytes(len));
      for (; r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2);) {
        r = new bn(randomBytes(len));
      }
      return r;
    }
    var bn = require(4);
    var randomBytes = require(16);
    /** @type {function(string, !Object): ?} */
    module.exports = crt;
    /** @type {function(?): ?} */
    crt.getr = getr;
  }).call(this, require(3).Buffer);
}, function(canCreateDiscussions, li_sub, require) {
  /** @type {!Object} */
  var self = li_sub;
  self.version = require(160).version;
  self.utils = require(7);
  self.rand = require(48);
  self.curve = require(90);
  self.curves = require(51);
  self.ec = require(171);
  self.eddsa = require(175);
}, function(canCreateDiscussions, psView, require) {
  /**
   * @param {!Object} options
   * @return {undefined}
   */
  function sign(options) {
    if ("short" === options.type) {
      this.curve = new BN.short(options);
    } else {
      if ("edwards" === options.type) {
        this.curve = new BN.edwards(options);
      } else {
        this.curve = new BN.mont(options);
      }
    }
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  /**
   * @param {string} name
   * @param {?} result
   * @return {undefined}
   */
  function test(name, result) {
    Object.defineProperty(self, name, {
      configurable : true,
      enumerable : true,
      get : function() {
        var commandResult = new sign(result);
        return Object.defineProperty(self, name, {
          configurable : true,
          enumerable : true,
          value : commandResult
        }), commandResult;
      }
    });
  }
  var HeadlessApi;
  var self = psView;
  var hash = require(52);
  var BN = require(90);
  var assert = require(7).assert;
  /** @type {function(!Object): undefined} */
  self.PresetCurve = sign;
  test("p192", {
    type : "short",
    prime : "p192",
    p : "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a : "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b : "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n : "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash : hash.sha256,
    gRed : false,
    g : ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
  });
  test("p224", {
    type : "short",
    prime : "p224",
    p : "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a : "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b : "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n : "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash : hash.sha256,
    gRed : false,
    g : ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
  });
  test("p256", {
    type : "short",
    prime : null,
    p : "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a : "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b : "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n : "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash : hash.sha256,
    gRed : false,
    g : ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
  });
  test("p384", {
    type : "short",
    prime : null,
    p : "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a : "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b : "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n : "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash : hash.sha384,
    gRed : false,
    g : ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
  });
  test("p521", {
    type : "short",
    prime : null,
    p : "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a : "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b : "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n : "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash : hash.sha512,
    gRed : false,
    g : ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
  });
  test("curve25519", {
    type : "mont",
    prime : "p25519",
    p : "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a : "76d06",
    b : "1",
    n : "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash : hash.sha256,
    gRed : false,
    g : ["9"]
  });
  test("ed25519", {
    type : "edwards",
    prime : "p25519",
    p : "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a : "-1",
    c : "1",
    d : "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n : "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash : hash.sha256,
    gRed : false,
    g : ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
  });
  try {
    HeadlessApi = require(170);
  } catch (c) {
    HeadlessApi = void 0;
  }
  test("secp256k1", {
    type : "short",
    prime : "k256",
    p : "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a : "0",
    b : "7",
    n : "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h : "1",
    hash : hash.sha256,
    beta : "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda : "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis : [{
      a : "3086d221a7d46bcde86c90e49284eb15",
      b : "-e4437ed6010e88286f547fa90abfe4c3"
    }, {
      a : "114ca50f7a8e2f3f657c1108d9d44cfd8",
      b : "3086d221a7d46bcde86c90e49284eb15"
    }],
    gRed : false,
    g : ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", HeadlessApi]
  });
}, function(isSlidingUp, canCreateDiscussions, require) {
  /** @type {!Object} */
  var forge = canCreateDiscussions;
  forge.utils = require(9);
  forge.common = require(23);
  forge.sha = require(164);
  forge.ripemd = require(168);
  forge.hmac = require(169);
  forge.sha1 = forge.sha.sha1;
  forge.sha256 = forge.sha.sha256;
  forge.sha224 = forge.sha.sha224;
  forge.sha384 = forge.sha.sha384;
  forge.sha512 = forge.sha.sha512;
  forge.ripemd160 = forge.ripemd.ripemd160;
}, function(canCreateDiscussions, https, require) {
  (function(global) {
    var Request = require(198);
    var Resilient = require(103);
    var buildRequestParams = require(200);
    var fn = require(201);
    var s = require(26);
    /** @type {!Object} */
    var http = https;
    /**
     * @param {!Object} options
     * @param {!Object} success
     * @return {?}
     */
    http.request = function(options, success) {
      options = "string" === typeof options ? s.parse(options) : buildRequestParams(options);
      /** @type {string} */
      var title = -1 === global.location.protocol.search(/^https?:$/) ? "http:" : "";
      var key = options.protocol || title;
      var i = options.hostname || options.host;
      var path = options.port;
      var qs = options.path || "/";
      if (i && -1 !== i.indexOf(":")) {
        /** @type {string} */
        i = "[" + i + "]";
      }
      /** @type {string} */
      options.url = (i ? key + "//" + i : "") + (path ? ":" + path : "") + qs;
      options.method = (options.method || "GET").toUpperCase();
      options.headers = options.headers || {};
      var request = new Request(options);
      return success && request.on("response", success), request;
    };
    /**
     * @param {string} args
     * @param {!Object} data
     * @return {?}
     */
    http.get = function(args, data) {
      var b = http.request(args, data);
      return b.end(), b;
    };
    http.ClientRequest = Request;
    http.IncomingMessage = Resilient.IncomingMessage;
    /**
     * @return {undefined}
     */
    http.Agent = function() {
    };
    /** @type {number} */
    http.Agent.defaultMaxSockets = 4;
    http.globalAgent = new http.Agent;
    http.STATUS_CODES = fn;
    /** @type {!Array} */
    http.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"];
  }).call(this, require(5));
}, function(canCreateDiscussions, exports, require) {
  exports.decode = exports.parse = require(204);
  exports.encode = exports.stringify = require(205);
}, function(m, canCreateDiscussions, kvFn) {
  /**
   * @param {string} val
   * @return {?}
   */
  function emit(val) {
    if ("string" === typeof val && (val = QuickBase.parse(val)), val.protocol || (val.protocol = "https:"), "https:" !== val.protocol) {
      throw new Error('Protocol "' + val.protocol + '" not supported. Expected "https:"');
    }
    return val;
  }
  var r = kvFn(53);
  var QuickBase = kvFn(26);
  var a = m.exports;
  var i;
  for (i in r) {
    if (r.hasOwnProperty(i)) {
      a[i] = r[i];
    }
  }
  /**
   * @param {string} e
   * @param {!Object} i
   * @return {?}
   */
  a.request = function(e, i) {
    return e = emit(e), r.request.call(this, e, i);
  };
  /**
   * @param {string} e
   * @param {?} i
   * @return {?}
   */
  a.get = function(e, i) {
    return e = emit(e), r.get.call(this, e, i);
  };
}, , function(exports, canCreateDiscussions, isSlidingUp) {
  /** @type {function(this:Object, *): boolean} */
  var has = Object.prototype.hasOwnProperty;
  /** @type {function(*): boolean} */
  var isArray = Array.isArray;
  var hexTable = function() {
    /** @type {!Array} */
    var newNodeLists = [];
    /** @type {number} */
    var alpha255 = 0;
    for (; alpha255 < 256; ++alpha255) {
      newNodeLists.push("%" + ((alpha255 < 16 ? "0" : "") + alpha255.toString(16)).toUpperCase());
    }
    return newNodeLists;
  }();
  /**
   * @param {string} val
   * @param {string} options
   * @return {?}
   */
  var parseObject = function(val, options) {
    /** @type {!Object} */
    var ret = options && options.plainObjects ? Object.create(null) : {};
    /** @type {number} */
    var i = 0;
    for (; i < val.length; ++i) {
      if ("undefined" !== typeof val[i]) {
        ret[i] = val[i];
      }
    }
    return ret;
  };
  exports.exports = {
    arrayToObject : parseObject,
    assign : function(value, obj) {
      return Object.keys(obj).reduce(function(variables, i) {
        return variables[i] = obj[i], variables;
      }, value);
    },
    combine : function(t, n) {
      return [].concat(t, n);
    },
    compact : function(object) {
      /** @type {!Array} */
      var subjects = [{
        obj : {
          o : object
        },
        prop : "o"
      }];
      /** @type {!Array} */
      var r = [];
      /** @type {number} */
      var i = 0;
      for (; i < subjects.length; ++i) {
        var subj = subjects[i];
        var input = subj.obj[subj.prop];
        /** @type {!Array<string>} */
        var keyArray = Object.keys(input);
        /** @type {number} */
        var ii = 0;
        for (; ii < keyArray.length; ++ii) {
          /** @type {string} */
          var p = keyArray[ii];
          var a = input[p];
          if ("object" === typeof a && null !== a && -1 === r.indexOf(a)) {
            subjects.push({
              obj : input,
              prop : p
            });
            r.push(a);
          }
        }
      }
      return function(array) {
        for (; array.length > 1;) {
          var subj = array.pop();
          var a = subj.obj[subj.prop];
          if (isArray(a)) {
            /** @type {!Array} */
            var reorderMap = [];
            /** @type {number} */
            var i = 0;
            for (; i < a.length; ++i) {
              if ("undefined" !== typeof a[i]) {
                reorderMap.push(a[i]);
              }
            }
            /** @type {!Array} */
            subj.obj[subj.prop] = reorderMap;
          }
        }
      }(subjects), object;
    },
    decode : function(string, options, json) {
      var body = string.replace(/\+/g, " ");
      if ("iso-8859-1" === json) {
        return body.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(body);
      } catch (i) {
        return body;
      }
    },
    encode : function(data, options, errors) {
      if (0 === data.length) {
        return data;
      }
      /** @type {!Array} */
      var n = data;
      if ("symbol" === typeof data ? n = Symbol.prototype.toString.call(data) : "string" !== typeof data && (n = String(data)), "iso-8859-1" === errors) {
        return escape(n).replace(/%u[0-9a-f]{4}/gi, function(headerPlusSegments) {
          return "%26%23" + parseInt(headerPlusSegments.slice(2), 16) + "%3B";
        });
      }
      /** @type {string} */
      var out = "";
      /** @type {number} */
      var i = 0;
      for (; i < n.length; ++i) {
        var c = n.charCodeAt(i);
        if (45 === c || 46 === c || 95 === c || 126 === c || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122) {
          out = out + n.charAt(i);
        } else {
          if (c < 128) {
            out = out + hexTable[c];
          } else {
            if (c < 2048) {
              /** @type {string} */
              out = out + (hexTable[192 | c >> 6] + hexTable[128 | 63 & c]);
            } else {
              if (c < 55296 || c >= 57344) {
                /** @type {string} */
                out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);
              } else {
                /** @type {number} */
                i = i + 1;
                /** @type {number} */
                c = 65536 + ((1023 & c) << 10 | 1023 & n.charCodeAt(i));
                /** @type {string} */
                out = out + (hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | 63 & c]);
              }
            }
          }
        }
      }
      return out;
    },
    isBuffer : function(obj) {
      return !(!obj || "object" !== typeof obj) && !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    },
    isRegExp : function(re) {
      return "[object RegExp]" === Object.prototype.toString.call(re);
    },
    merge : function parse(data, value, options) {
      if (!value) {
        return data;
      }
      if ("object" !== typeof value) {
        if (isArray(data)) {
          data.push(value);
        } else {
          if (!data || "object" !== typeof data) {
            return [data, value];
          }
          if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, value)) {
            /** @type {boolean} */
            data[value] = true;
          }
        }
        return data;
      }
      if (!data || "object" !== typeof data) {
        return [data].concat(value);
      }
      /** @type {string} */
      var result = data;
      return isArray(data) && !isArray(value) && (result = parseObject(data, options)), isArray(data) && isArray(value) ? (value.forEach(function(a, i) {
        if (has.call(data, i)) {
          var b = data[i];
          if (b && "object" === typeof b && a && "object" === typeof a) {
            data[i] = parse(b, a, options);
          } else {
            data.push(a);
          }
        } else {
          /** @type {string} */
          data[i] = a;
        }
      }), data) : Object.keys(value).reduce(function(obj, key) {
        var source = value[key];
        return has.call(obj, key) ? obj[key] = parse(obj[key], source, options) : obj[key] = source, obj;
      }, result);
    }
  };
}, , , , function(mixin, canCreateDiscussions, isSlidingUp) {
  /**
   * @param {?} it
   * @return {?}
   */
  function toObject(it) {
    if (null === it || void 0 === it) {
      throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(it);
  }
  /** @type {function(!Object): !Array<?>} */
  var ownSymbols = Object.getOwnPropertySymbols;
  /** @type {function(this:Object, *): boolean} */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  /** @type {function(this:Object, string): boolean} */
  var fn = Object.prototype.propertyIsEnumerable;
  /** @type {!Function} */
  mixin.exports = function() {
    try {
      if (!Object.assign) {
        return false;
      }
      /** @type {!String} */
      var test1 = new String("abc");
      if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) {
        return false;
      }
      var map = {};
      /** @type {number} */
      var i = 0;
      for (; i < 10; i++) {
        /** @type {number} */
        map["_" + String.fromCharCode(i)] = i;
      }
      if ("0123456789" !== Object.getOwnPropertyNames(map).map(function(oldOrient) {
        return map[oldOrient];
      }).join("")) {
        return false;
      }
      var key = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(y) {
        /** @type {string} */
        key[y] = y;
      }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, key)).join("");
    } catch (i) {
      return false;
    }
  }() ? Object.assign : function(key, allowStale) {
    var obj;
    var keys;
    var items = toObject(key);
    /** @type {number} */
    var i = 1;
    for (; i < arguments.length; i++) {
      var key;
      for (key in obj = Object(arguments[i])) {
        if (hasOwnProperty.call(obj, key)) {
          items[key] = obj[key];
        }
      }
      if (ownSymbols) {
        /** @type {!Array<?>} */
        keys = ownSymbols(obj);
        /** @type {number} */
        var i = 0;
        for (; i < keys.length; i++) {
          if (fn.call(obj, keys[i])) {
            items[keys[i]] = obj[keys[i]];
          }
        }
      }
    }
    return items;
  };
}, function(canCreateDiscussions, Backbone, require) {
  (function(Buffer) {
    var crypto = require(64);
    var sha1 = require(197);
    var http = require(53);
    var https = require(55);
    var s = require(26);
    var querystring = require(54);
    var util = require(104);
    /**
     * @param {?} requestUrl
     * @param {?} accessUrl
     * @param {!Date} consumerKey
     * @param {string} consumerSecret
     * @param {string} version
     * @param {?} authorize_callback
     * @param {string} signatureMethod
     * @param {number} nonceSize
     * @param {string} customHeaders
     * @return {undefined}
     */
    Backbone.OAuth = function(requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {
      if (this._isEcho = false, this._requestUrl = requestUrl, this._accessUrl = accessUrl, this._consumerKey = consumerKey, this._consumerSecret = this._encodeData(consumerSecret), "RSA-SHA1" == signatureMethod && (this._privateKey = consumerSecret), this._version = version, this._authorize_callback = void 0 === authorize_callback ? "oob" : authorize_callback, "PLAINTEXT" != signatureMethod && "HMAC-SHA1" != signatureMethod && "RSA-SHA1" != signatureMethod) {
        throw new Error("Un-supported signature method: " + signatureMethod);
      }
      /** @type {string} */
      this._signatureMethod = signatureMethod;
      this._nonceSize = nonceSize || 32;
      this._headers = customHeaders || {
        Accept : "*/*",
        Connection : "close",
        "User-Agent" : "Node authentication"
      };
      this._clientOptions = this._defaultClientOptions = {
        requestTokenHttpMethod : "POST",
        accessTokenHttpMethod : "POST",
        followRedirects : true
      };
      /** @type {string} */
      this._oauthParameterSeperator = ",";
    };
    /**
     * @param {string} realm
     * @param {?} verify_credentials
     * @param {!Date} consumerKey
     * @param {string} consumerSecret
     * @param {string} version
     * @param {string} signatureMethod
     * @param {number} nonceSize
     * @param {string} customHeaders
     * @return {undefined}
     */
    Backbone.OAuthEcho = function(realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {
      if (this._isEcho = true, this._realm = realm, this._verifyCredentials = verify_credentials, this._consumerKey = consumerKey, this._consumerSecret = this._encodeData(consumerSecret), "RSA-SHA1" == signatureMethod && (this._privateKey = consumerSecret), this._version = version, "PLAINTEXT" != signatureMethod && "HMAC-SHA1" != signatureMethod && "RSA-SHA1" != signatureMethod) {
        throw new Error("Un-supported signature method: " + signatureMethod);
      }
      /** @type {string} */
      this._signatureMethod = signatureMethod;
      this._nonceSize = nonceSize || 32;
      this._headers = customHeaders || {
        Accept : "*/*",
        Connection : "close",
        "User-Agent" : "Node authentication"
      };
      /** @type {string} */
      this._oauthParameterSeperator = ",";
    };
    Backbone.OAuthEcho.prototype = Backbone.OAuth.prototype;
    /**
     * @return {?}
     */
    Backbone.OAuth.prototype._getTimestamp = function() {
      return Math.floor((new Date).getTime() / 1E3);
    };
    /**
     * @param {string} str
     * @return {?}
     */
    Backbone.OAuth.prototype._encodeData = function(str) {
      return null == str || "" == str ? "" : encodeURIComponent(str).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    };
    /**
     * @param {string} data
     * @return {?}
     */
    Backbone.OAuth.prototype._decodeData = function(data) {
      return null != data && (data = data.replace(/\+/g, " ")), decodeURIComponent(data);
    };
    /**
     * @param {string} method
     * @param {string} url
     * @param {string} parameters
     * @param {number} tokenSecret
     * @return {?}
     */
    Backbone.OAuth.prototype._getSignature = function(method, url, parameters, tokenSecret) {
      var signatureBase = this._createSignatureBase(method, url, parameters);
      return this._createSignature(signatureBase, tokenSecret);
    };
    /**
     * @param {string} url
     * @return {?}
     */
    Backbone.OAuth.prototype._normalizeUrl = function(url) {
      var obj = s.parse(url, true);
      /** @type {string} */
      var port = "";
      return obj.port && ("http:" == obj.protocol && "80" != obj.port || "https:" == obj.protocol && "443" != obj.port) && (port = ":" + obj.port), obj.pathname && "" != obj.pathname || (obj.pathname = "/"), obj.protocol + "//" + obj.hostname + port + obj.pathname;
    };
    /**
     * @param {string} parameter
     * @return {?}
     */
    Backbone.OAuth.prototype._isParameterNameAnOAuthParameter = function(parameter) {
      var t = parameter.match("^oauth_");
      return !(!t || "oauth_" !== t[0]);
    };
    /**
     * @param {!NodeList} orderedParameters
     * @return {?}
     */
    Backbone.OAuth.prototype._buildAuthorizationHeaders = function(orderedParameters) {
      /** @type {string} */
      var authHeader = "OAuth ";
      if (this._isEcho) {
        /** @type {string} */
        authHeader = authHeader + ('realm="' + this._realm + '",');
      }
      /** @type {number} */
      var i = 0;
      for (; i < orderedParameters.length; i++) {
        if (this._isParameterNameAnOAuthParameter(orderedParameters[i][0])) {
          /** @type {string} */
          authHeader = authHeader + (this._encodeData(orderedParameters[i][0]) + '="' + this._encodeData(orderedParameters[i][1]) + '"' + this._oauthParameterSeperator);
        }
      }
      return authHeader = authHeader.substring(0, authHeader.length - this._oauthParameterSeperator.length);
    };
    /**
     * @param {!Object} args
     * @return {?}
     */
    Backbone.OAuth.prototype._makeArrayOfArgumentsHash = function(args) {
      /** @type {!Array} */
      var argument_pairs = [];
      var key;
      for (key in args) {
        if (args.hasOwnProperty(key)) {
          var value = args[key];
          if (Array.isArray(value)) {
            /** @type {number} */
            var i = 0;
            for (; i < value.length; i++) {
              /** @type {!Array} */
              argument_pairs[argument_pairs.length] = [key, value[i]];
            }
          } else {
            /** @type {!Array} */
            argument_pairs[argument_pairs.length] = [key, value];
          }
        }
      }
      return argument_pairs;
    };
    /**
     * @param {!Array} argument_pairs
     * @return {?}
     */
    Backbone.OAuth.prototype._sortRequestParams = function(argument_pairs) {
      return argument_pairs.sort(function(aid1, aid2) {
        return aid1[0] == aid2[0] ? aid1[1] < aid2[1] ? -1 : 1 : aid1[0] < aid2[0] ? -1 : 1;
      }), argument_pairs;
    };
    /**
     * @param {string} args
     * @return {?}
     */
    Backbone.OAuth.prototype._normaliseRequestParams = function(args) {
      var argument_pairs = this._makeArrayOfArgumentsHash(args);
      /** @type {number} */
      var i = 0;
      for (; i < argument_pairs.length; i++) {
        argument_pairs[i][0] = this._encodeData(argument_pairs[i][0]);
        argument_pairs[i][1] = this._encodeData(argument_pairs[i][1]);
      }
      argument_pairs = this._sortRequestParams(argument_pairs);
      /** @type {string} */
      args = "";
      /** @type {number} */
      i = 0;
      for (; i < argument_pairs.length; i++) {
        args = args + argument_pairs[i][0];
        /** @type {string} */
        args = args + "=";
        args = args + argument_pairs[i][1];
        if (i < argument_pairs.length - 1) {
          /** @type {string} */
          args = args + "&";
        }
      }
      return args;
    };
    /**
     * @param {string} method
     * @param {string} url
     * @param {string} parameters
     * @return {?}
     */
    Backbone.OAuth.prototype._createSignatureBase = function(method, url, parameters) {
      return url = this._encodeData(this._normalizeUrl(url)), parameters = this._encodeData(parameters), method.toUpperCase() + "&" + url + "&" + parameters;
    };
    /**
     * @param {?} signatureBase
     * @param {number} tokenSecret
     * @return {?}
     */
    Backbone.OAuth.prototype._createSignature = function(signatureBase, tokenSecret) {
      if (void 0 === tokenSecret) {
        /** @type {string} */
        tokenSecret = "";
      } else {
        tokenSecret = this._encodeData(tokenSecret);
      }
      /** @type {string} */
      var key = this._consumerSecret + "&" + tokenSecret;
      /** @type {string} */
      var hash = "";
      return "PLAINTEXT" == this._signatureMethod ? hash = key : "RSA-SHA1" == this._signatureMethod ? (key = this._privateKey || "", hash = crypto.createSign("RSA-SHA1").update(signatureBase).sign(key, "base64")) : hash = crypto.Hmac ? crypto.createHmac("sha1", key).update(signatureBase).digest("base64") : sha1.HMACSHA1(key, signatureBase), hash;
    };
    /** @type {!Array} */
    Backbone.OAuth.prototype.NONCE_CHARS = ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    /**
     * @param {number} nonceSize
     * @return {?}
     */
    Backbone.OAuth.prototype._getNonce = function(nonceSize) {
      var j;
      /** @type {!Array} */
      var output = [];
      var chars = this.NONCE_CHARS;
      var charsLength = chars.length;
      /** @type {number} */
      var i = 0;
      for (; i < nonceSize; i++) {
        /** @type {number} */
        j = Math.floor(Math.random() * charsLength);
        output[i] = chars[j];
      }
      return output.join("");
    };
    /**
     * @param {string} url
     * @param {!Object} version
     * @param {string} method
     * @param {string} type
     * @param {!Object} headers
     * @param {boolean} options
     * @return {?}
     */
    Backbone.OAuth.prototype._createClient = function(url, version, method, type, headers, options) {
      var obj = {
        host : version,
        port : url,
        path : type,
        method : method,
        headers : headers
      };
      return (options ? https : http).request(obj);
    };
    /**
     * @param {string} oauth_token
     * @param {number} oauth_token_secret
     * @param {string} method
     * @param {string} url
     * @param {!Object} extra_params
     * @return {?}
     */
    Backbone.OAuth.prototype._prepareParameters = function(oauth_token, oauth_token_secret, method, url, extra_params) {
      var sig;
      var oauthParameters = {
        oauth_timestamp : this._getTimestamp(),
        oauth_nonce : this._getNonce(this._nonceSize),
        oauth_version : this._version,
        oauth_signature_method : this._signatureMethod,
        oauth_consumer_key : this._consumerKey
      };
      if (oauth_token && (oauthParameters.oauth_token = oauth_token), this._isEcho) {
        sig = this._getSignature("GET", this._verifyCredentials, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
      } else {
        if (extra_params) {
          var key;
          for (key in extra_params) {
            if (extra_params.hasOwnProperty(key)) {
              oauthParameters[key] = extra_params[key];
            }
          }
        }
        var urlobj = s.parse(url, false);
        if (urlobj.query) {
          var key2;
          var argumentsHash = querystring.parse(urlobj.query);
          for (key in argumentsHash) {
            var value = argumentsHash[key];
            if ("object" == typeof value) {
              for (key2 in value) {
                oauthParameters[key + "[" + key2 + "]"] = value[key2];
              }
            } else {
              oauthParameters[key] = value;
            }
          }
        }
        sig = this._getSignature(method, url, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
      }
      var orderedParameters = this._sortRequestParams(this._makeArrayOfArgumentsHash(oauthParameters));
      return orderedParameters[orderedParameters.length] = ["oauth_signature", sig], orderedParameters;
    };
    /**
     * @param {string} oauth_token
     * @param {number} oauth_token_secret
     * @param {string} method
     * @param {string} url
     * @param {!Object} extra_params
     * @param {string} content
     * @param {string} post_content_type
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype._performSecureRequest = function(oauth_token, oauth_token_secret, method, url, extra_params, content, post_content_type, callback) {
      var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);
      if (!post_content_type) {
        /** @type {string} */
        post_content_type = "application/x-www-form-urlencoded";
      }
      var options = s.parse(url, false);
      if (!("http:" != options.protocol || options.port)) {
        /** @type {number} */
        options.port = 80;
      }
      if (!("https:" != options.protocol || options.port)) {
        /** @type {number} */
        options.port = 443;
      }
      var path;
      var voiceRequest;
      var headers = {};
      var authorization = this._buildAuthorizationHeaders(orderedParameters);
      var key;
      for (key in this._isEcho ? headers["X-Verify-Credentials-Authorization"] = authorization : headers.Authorization = authorization, headers.Host = options.host, this._headers) {
        if (this._headers.hasOwnProperty(key)) {
          headers[key] = this._headers[key];
        }
      }
      for (key in extra_params) {
        if (this._isParameterNameAnOAuthParameter(key)) {
          delete extra_params[key];
        }
      }
      if (!("POST" != method && "PUT" != method || null != content || null == extra_params)) {
        content = querystring.stringify(extra_params).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
      }
      if (content) {
        if (Buffer.isBuffer(content)) {
          headers["Content-length"] = content.length;
        } else {
          headers["Content-length"] = Buffer.byteLength(content);
        }
      } else {
        /** @type {number} */
        headers["Content-length"] = 0;
      }
      /** @type {string} */
      headers["Content-Type"] = post_content_type;
      if (!(options.pathname && "" != options.pathname)) {
        /** @type {string} */
        options.pathname = "/";
      }
      path = options.query ? options.pathname + "?" + options.query : options.pathname;
      voiceRequest = "https:" == options.protocol ? this._createClient(options.port, options.hostname, method, path, headers, true) : this._createClient(options.port, options.hostname, method, path, headers);
      var clientOptions = this._clientOptions;
      if (!callback) {
        return "POST" != method && "PUT" != method || null == content || "" == content || voiceRequest.write(content), voiceRequest;
      }
      /** @type {string} */
      var output = "";
      var self = this;
      var S = util.isAnEarlyCloseHost(options.hostname);
      /** @type {boolean} */
      var k = false;
      /**
       * @param {!Object} response
       * @return {undefined}
       */
      var passBackControl = function(response) {
        if (!k) {
          /** @type {boolean} */
          k = true;
          if (response.statusCode >= 200 && response.statusCode <= 299) {
            callback(null, output, response);
          } else {
            if ((301 == response.statusCode || 302 == response.statusCode) && clientOptions.followRedirects && response.headers && response.headers.location) {
              self._performSecureRequest(oauth_token, oauth_token_secret, method, response.headers.location, extra_params, content, post_content_type, callback);
            } else {
              callback({
                statusCode : response.statusCode,
                data : output
              }, output, response);
            }
          }
        }
      };
      voiceRequest.on("response", function(response) {
        response.setEncoding("utf8");
        response.on("data", function(icons) {
          output = output + icons;
        });
        response.on("end", function() {
          passBackControl(response);
        });
        response.on("close", function() {
          if (S) {
            passBackControl(response);
          }
        });
      });
      voiceRequest.on("error", function(identifierPositions) {
        if (!k) {
          /** @type {boolean} */
          k = true;
          callback(identifierPositions);
        }
      });
      if (!("POST" != method && "PUT" != method || null == content || "" == content)) {
        voiceRequest.write(content);
      }
      voiceRequest.end();
    };
    /**
     * @param {!Array} options
     * @return {undefined}
     */
    Backbone.OAuth.prototype.setClientOptions = function(options) {
      var key;
      var mergedOptions = {};
      /** @type {function(this:Object, *): boolean} */
      var __hasProp = Object.prototype.hasOwnProperty;
      for (key in this._defaultClientOptions) {
        if (__hasProp.call(options, key)) {
          mergedOptions[key] = options[key];
        } else {
          mergedOptions[key] = this._defaultClientOptions[key];
        }
      }
      this._clientOptions = mergedOptions;
    };
    /**
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} oauth_verifier
     * @param {string} callback
     * @return {undefined}
     */
    Backbone.OAuth.prototype.getOAuthAccessToken = function(oauth_token, oauth_token_secret, oauth_verifier, callback) {
      var extraParams = {};
      if ("function" == typeof oauth_verifier) {
        /** @type {string} */
        callback = oauth_verifier;
      } else {
        /** @type {string} */
        extraParams.oauth_verifier = oauth_verifier;
      }
      this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function(identifierPositions, request, canCreateDiscussions) {
        if (identifierPositions) {
          callback(identifierPositions);
        } else {
          var token = querystring.parse(request);
          var accessToken = token.oauth_token;
          delete token.oauth_token;
          var refreshToken = token.oauth_token_secret;
          delete token.oauth_token_secret;
          callback(null, accessToken, refreshToken, token);
        }
      });
    };
    /**
     * @param {string} url
     * @param {string} method
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} callback
     * @return {undefined}
     */
    Backbone.OAuth.prototype.getProtectedResource = function(url, method, oauth_token, oauth_token_secret, callback) {
      this._performSecureRequest(oauth_token, oauth_token_secret, method, url, null, "", null, callback);
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype.delete = function(url, oauth_token, oauth_token_secret, callback) {
      return this._performSecureRequest(oauth_token, oauth_token_secret, "DELETE", url, null, "", null, callback);
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype.get = function(url, oauth_token, oauth_token_secret, callback) {
      return this._performSecureRequest(oauth_token, oauth_token_secret, "GET", url, null, "", null, callback);
    };
    /**
     * @param {string} method
     * @param {string} url
     * @param {string} oauth_token
     * @param {number} oauth_token_secret
     * @param {!Object} body
     * @param {string} post_content_type
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype._putOrPost = function(method, url, oauth_token, oauth_token_secret, body, post_content_type, callback) {
      /** @type {null} */
      var extraParams = null;
      return "function" == typeof post_content_type && (callback = post_content_type, post_content_type = null), "string" == typeof body || Buffer.isBuffer(body) || (post_content_type = "application/x-www-form-urlencoded", extraParams = body, body = null), this._performSecureRequest(oauth_token, oauth_token_secret, method, url, extraParams, body, post_content_type, callback);
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {!Object} post_body
     * @param {string} post_content_type
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype.put = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
      return this._putOrPost("PUT", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {!Object} post_body
     * @param {string} post_content_type
     * @param {string} callback
     * @return {?}
     */
    Backbone.OAuth.prototype.post = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
      return this._putOrPost("POST", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
    };
    /**
     * @param {!Object} params
     * @param {!Object} callback
     * @return {undefined}
     */
    Backbone.OAuth.prototype.getOAuthRequestToken = function(params, callback) {
      if ("function" == typeof params) {
        /** @type {!Object} */
        callback = params;
        params = {};
      }
      if (this._authorize_callback) {
        params.oauth_callback = this._authorize_callback;
      }
      this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, params, null, null, function(identifierPositions, request, n) {
        if (identifierPositions) {
          callback(identifierPositions);
        } else {
          var token = querystring.parse(request);
          var accessToken = token.oauth_token;
          var refreshToken = token.oauth_token_secret;
          delete token.oauth_token;
          delete token.oauth_token_secret;
          callback(null, accessToken, refreshToken, token);
        }
      });
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} method
     * @return {?}
     */
    Backbone.OAuth.prototype.signUrl = function(url, oauth_token, oauth_token_secret, method) {
      if (void 0 === method) {
        /** @type {string} */
        method = "GET";
      }
      var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
      var o = s.parse(url, false);
      /** @type {string} */
      var reverse_search_string = "";
      /** @type {number} */
      var i = 0;
      for (; i < orderedParameters.length; i++) {
        /** @type {string} */
        reverse_search_string = reverse_search_string + (orderedParameters[i][0] + "=" + this._encodeData(orderedParameters[i][1]) + "&");
      }
      return reverse_search_string = reverse_search_string.substring(0, reverse_search_string.length - 1), o.protocol + "//" + o.host + o.pathname + "?" + reverse_search_string;
    };
    /**
     * @param {string} url
     * @param {string} oauth_token
     * @param {undefined} oauth_token_secret
     * @param {string} method
     * @return {?}
     */
    Backbone.OAuth.prototype.authHeader = function(url, oauth_token, oauth_token_secret, method) {
      if (void 0 === method) {
        /** @type {string} */
        method = "GET";
      }
      var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
      return this._buildAuthorizationHeaders(orderedParameters);
    };
  }).call(this, require(3).Buffer);
}, function(mixin, canCreateDiscussions) {
  /** @type {function(this:*): string} */
  var k = {}.toString;
  /** @type {function(*): boolean} */
  mixin.exports = Array.isArray || function(key) {
    return "[object Array]" == k.call(key);
  };
}, function(canCreateDiscussions, crypto, require) {
  crypto.randomBytes = crypto.rng = crypto.pseudoRandomBytes = crypto.prng = require(16);
  crypto.createHash = crypto.Hash = require(19);
  crypto.createHmac = crypto.Hmac = require(72);
  var times = require(136);
  /** @type {!Array<string>} */
  var n = Object.keys(times);
  /** @type {!Array<?>} */
  var h = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(n);
  /**
   * @return {?}
   */
  crypto.getHashes = function() {
    return h;
  };
  var p = require(75);
  crypto.pbkdf2 = p.pbkdf2;
  crypto.pbkdf2Sync = p.pbkdf2Sync;
  var ourCrypto = require(138);
  crypto.Cipher = ourCrypto.Cipher;
  crypto.createCipher = ourCrypto.createCipher;
  crypto.Cipheriv = ourCrypto.Cipheriv;
  crypto.createCipheriv = ourCrypto.createCipheriv;
  crypto.Decipher = ourCrypto.Decipher;
  crypto.createDecipher = ourCrypto.createDecipher;
  crypto.Decipheriv = ourCrypto.Decipheriv;
  crypto.createDecipheriv = ourCrypto.createDecipheriv;
  crypto.getCiphers = ourCrypto.getCiphers;
  crypto.listCiphers = ourCrypto.listCiphers;
  var TagHourlyStat = require(153);
  crypto.DiffieHellmanGroup = TagHourlyStat.DiffieHellmanGroup;
  crypto.createDiffieHellmanGroup = TagHourlyStat.createDiffieHellmanGroup;
  crypto.getDiffieHellman = TagHourlyStat.getDiffieHellman;
  crypto.createDiffieHellman = TagHourlyStat.createDiffieHellman;
  crypto.DiffieHellman = TagHourlyStat.DiffieHellman;
  var exports = require(158);
  crypto.createSign = exports.createSign;
  crypto.Sign = exports.Sign;
  crypto.createVerify = exports.createVerify;
  crypto.Verify = exports.Verify;
  crypto.createECDH = require(192);
  var myCrypto = require(193);
  crypto.publicEncrypt = myCrypto.publicEncrypt;
  crypto.privateEncrypt = myCrypto.privateEncrypt;
  crypto.publicDecrypt = myCrypto.publicDecrypt;
  crypto.privateDecrypt = myCrypto.privateDecrypt;
  var CheckDailyStat = require(196);
  crypto.randomFill = CheckDailyStat.randomFill;
  crypto.randomFillSync = CheckDailyStat.randomFillSync;
  /**
   * @return {?}
   */
  crypto.createCredentials = function() {
    throw new Error(["sorry, createCredentials is not implemented yet", "we accept pull requests", "https://github.com/crypto-browserify/crypto-browserify"].join("\n"));
  };
  crypto.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME : 2,
    DH_CHECK_P_NOT_PRIME : 1,
    DH_UNABLE_TO_CHECK_GENERATOR : 4,
    DH_NOT_SUITABLE_GENERATOR : 8,
    NPN_ENABLED : 1,
    ALPN_ENABLED : 1,
    RSA_PKCS1_PADDING : 1,
    RSA_SSLV23_PADDING : 2,
    RSA_NO_PADDING : 3,
    RSA_PKCS1_OAEP_PADDING : 4,
    RSA_X931_PADDING : 5,
    RSA_PKCS1_PSS_PADDING : 6,
    POINT_CONVERSION_COMPRESSED : 2,
    POINT_CONVERSION_UNCOMPRESSED : 4,
    POINT_CONVERSION_HYBRID : 6
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function self(key) {
    transformer.call(this);
    this._block = Buffer.allocUnsafe(key);
    /** @type {string} */
    this._blockSize = key;
    /** @type {number} */
    this._blockOffset = 0;
    /** @type {!Array} */
    this._length = [0, 0, 0, 0];
    /** @type {boolean} */
    this._finalized = false;
  }
  var Buffer = require(2).Buffer;
  var transformer = require(38).Transform;
  require(1)(self, transformer);
  /**
   * @param {?} data
   * @param {!Array} cb
   * @param {!Array} next
   * @return {undefined}
   */
  self.prototype._transform = function(data, cb, next) {
    /** @type {null} */
    var n = null;
    try {
      this.update(data, cb);
    } catch (numInternals) {
      n = numInternals;
    }
    next(n);
  };
  /**
   * @param {!Function} cb
   * @return {undefined}
   */
  self.prototype._flush = function(cb) {
    /** @type {null} */
    var wsFunction = null;
    try {
      this.push(this.digest());
    } catch (local_mobile_core_user_remove_user_device) {
      wsFunction = local_mobile_core_user_remove_user_device;
    }
    cb(wsFunction);
  };
  /**
   * @param {?} name
   * @param {!Array} type
   * @return {?}
   */
  self.prototype.update = function(name, type) {
    if (function(value, object) {
      if (!Buffer.isBuffer(value) && "string" !== typeof value) {
        throw new TypeError(object + " must be a string or a buffer");
      }
    }(name, "Data"), this._finalized) {
      throw new Error("Digest already called");
    }
    if (!Buffer.isBuffer(name)) {
      name = Buffer.from(name, type);
    }
    var fns = this._block;
    /** @type {number} */
    var curPos = 0;
    for (; this._blockOffset + name.length - curPos >= this._blockSize;) {
      var i = this._blockOffset;
      for (; i < this._blockSize;) {
        fns[i++] = name[curPos++];
      }
      this._update();
      /** @type {number} */
      this._blockOffset = 0;
    }
    for (; curPos < name.length;) {
      fns[this._blockOffset++] = name[curPos++];
    }
    /** @type {number} */
    var i = 0;
    /** @type {number} */
    var strength = 8 * name.length;
    for (; strength > 0; ++i) {
      this._length[i] += strength;
      if ((strength = this._length[i] / 4294967296 | 0) > 0) {
        this._length[i] -= 4294967296 * strength;
      }
    }
    return this;
  };
  /**
   * @return {?}
   */
  self.prototype._update = function() {
    throw new Error("_update is not implemented");
  };
  /**
   * @param {?} enc
   * @return {?}
   */
  self.prototype.digest = function(enc) {
    if (this._finalized) {
      throw new Error("Digest already called");
    }
    /** @type {boolean} */
    this._finalized = true;
    var outData = this._digest();
    if (void 0 !== enc) {
      outData = outData.toString(enc);
    }
    this._block.fill(0);
    /** @type {number} */
    this._blockOffset = 0;
    /** @type {number} */
    var m = 0;
    for (; m < 4; ++m) {
      /** @type {number} */
      this._length[m] = 0;
    }
    return outData;
  };
  /**
   * @return {?}
   */
  self.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  };
  /** @type {function(string): undefined} */
  module.exports = self;
}, function(module, canCreateDiscussions, require) {
  (function(PL$3, process) {
    /**
     * @param {!Object} options
     * @param {?} stream
     * @return {undefined}
     */
    function ReadableState(options, stream) {
      options = options || {};
      /** @type {boolean} */
      var isISO = stream instanceof (connectionFn = connectionFn || require(13));
      /** @type {boolean} */
      this.objectMode = !!options.objectMode;
      if (isISO) {
        /** @type {boolean} */
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      }
      var hwm = options.highWaterMark;
      var tz = options.readableHighWaterMark;
      /** @type {number} */
      var defaultHwm = this.objectMode ? 16 : 16384;
      this.highWaterMark = hwm || 0 === hwm ? hwm : isISO && (tz || 0 === tz) ? tz : defaultHwm;
      /** @type {number} */
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new type;
      /** @type {number} */
      this.length = 0;
      /** @type {null} */
      this.pipes = null;
      /** @type {number} */
      this.pipesCount = 0;
      /** @type {null} */
      this.flowing = null;
      /** @type {boolean} */
      this.ended = false;
      /** @type {boolean} */
      this.endEmitted = false;
      /** @type {boolean} */
      this.reading = false;
      /** @type {boolean} */
      this.sync = true;
      /** @type {boolean} */
      this.needReadable = false;
      /** @type {boolean} */
      this.emittedReadable = false;
      /** @type {boolean} */
      this.readableListening = false;
      /** @type {boolean} */
      this.resumeScheduled = false;
      /** @type {boolean} */
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      /** @type {number} */
      this.awaitDrain = 0;
      /** @type {boolean} */
      this.readingMore = false;
      /** @type {null} */
      this.decoder = null;
      /** @type {null} */
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) {
          StringDecoder = require(42).StringDecoder;
        }
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    /**
     * @param {!Object} key
     * @return {?}
     */
    function Readable(key) {
      if (connectionFn = connectionFn || require(13), !(this instanceof Readable)) {
        return new Readable(key);
      }
      this._readableState = new ReadableState(key, this);
      /** @type {boolean} */
      this.readable = true;
      if (key) {
        if ("function" === typeof key.read) {
          /** @type {!Function} */
          this._read = key.read;
        }
        if ("function" === typeof key.destroy) {
          /** @type {!Function} */
          this._destroy = key.destroy;
        }
      }
      Transport.call(this);
    }
    /**
     * @param {!Object} stream
     * @param {!Object} data
     * @param {?} encoding
     * @param {boolean} mode
     * @param {string} id
     * @return {?}
     */
    function read(stream, data, encoding, mode, id) {
      var o;
      var state = stream._readableState;
      if (null === data) {
        /** @type {boolean} */
        state.reading = false;
        (function(stream, state) {
          if (state.ended) {
            return;
          }
          if (state.decoder) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length) {
              state.buffer.push(chunk);
              state.length += state.objectMode ? 1 : chunk.length;
            }
          }
          /** @type {boolean} */
          state.ended = true;
          emitReadable(stream);
        })(stream, state);
      } else {
        if (!id) {
          o = function(state, l) {
            var error;
            /** @type {!Array} */
            b = l;
            if (!(Buffer.isBuffer(b) || b instanceof CJSEvent || "string" === typeof l || void 0 === l || state.objectMode)) {
              /** @type {!TypeError} */
              error = new TypeError("Invalid non-string/buffer chunk");
            }
            var b;
            return error;
          }(state, data);
        }
        if (o) {
          stream.emit("error", o);
        } else {
          if (state.objectMode || data && data.length > 0) {
            if (!("string" === typeof data || state.objectMode || Object.getPrototypeOf(data) === Buffer.prototype)) {
              data = function(e) {
                return Buffer.from(e);
              }(data);
            }
            if (mode) {
              if (state.endEmitted) {
                stream.emit("error", new Error("stream.unshift() after end event"));
              } else {
                readableAddChunk(stream, state, data, true);
              }
            } else {
              if (state.ended) {
                stream.emit("error", new Error("stream.push() after EOF"));
              } else {
                /** @type {boolean} */
                state.reading = false;
                if (state.decoder && !encoding) {
                  data = state.decoder.write(data);
                  if (state.objectMode || 0 !== data.length) {
                    readableAddChunk(stream, state, data, false);
                  } else {
                    maybeReadMore(stream, state);
                  }
                } else {
                  readableAddChunk(stream, state, data, false);
                }
              }
            }
          } else {
            if (!mode) {
              /** @type {boolean} */
              state.reading = false;
            }
          }
        }
      }
      return function(state) {
        return !state.ended && (state.needReadable || state.length < state.highWaterMark || 0 === state.length);
      }(state);
    }
    /**
     * @param {!Object} stream
     * @param {!Object} state
     * @param {!Object} e
     * @param {boolean} noSize
     * @return {undefined}
     */
    function readableAddChunk(stream, state, e, noSize) {
      if (state.flowing && 0 === state.length && !state.sync) {
        stream.emit("data", e);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : e.length;
        if (noSize) {
          state.buffer.unshift(e);
        } else {
          state.buffer.push(e);
        }
        if (state.needReadable) {
          emitReadable(stream);
        }
      }
      maybeReadMore(stream, state);
    }
    /**
     * @param {!Object} n
     * @param {!Object} state
     * @return {?}
     */
    function howMuchToRead(n, state) {
      return n <= 0 || 0 === state.length && state.ended ? 0 : state.objectMode ? 1 : n !== n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = function(n) {
        return n >= 8388608 ? n = 8388608 : (n--, n = n | n >>> 1, n = n | n >>> 2, n = n | n >>> 4, n = n | n >>> 8, n = n | n >>> 16, n++), n;
      }(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = true, 0));
    }
    /**
     * @param {!Object} stream
     * @return {undefined}
     */
    function emitReadable(stream) {
      var state = stream._readableState;
      /** @type {boolean} */
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        /** @type {boolean} */
        state.emittedReadable = true;
        if (state.sync) {
          process.nextTick(start, stream);
        } else {
          start(stream);
        }
      }
    }
    /**
     * @param {!Object} stream
     * @return {undefined}
     */
    function start(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    /**
     * @param {(Object|string)} stream
     * @param {!Object} state
     * @return {undefined}
     */
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        /** @type {boolean} */
        state.readingMore = true;
        process.nextTick(end, stream, state);
      }
    }
    /**
     * @param {!Object} options
     * @param {!Object} state
     * @return {undefined}
     */
    function end(options, state) {
      var i = state.length;
      for (; !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark && (debug("maybeReadMore read 0"), options.read(0), i !== state.length);) {
        i = state.length;
      }
      /** @type {boolean} */
      state.readingMore = false;
    }
    /**
     * @param {!Object} state
     * @return {undefined}
     */
    function checkWorkers(state) {
      debug("readable nexttick read 0");
      state.read(0);
    }
    /**
     * @param {!Object} stream
     * @param {?} state
     * @return {undefined}
     */
    function resume(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      /** @type {boolean} */
      state.resumeScheduled = false;
      /** @type {number} */
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) {
        stream.read(0);
      }
    }
    /**
     * @param {!Object} stream
     * @return {undefined}
     */
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      for (; state.flowing && null !== stream.read();) {
      }
    }
    /**
     * @param {number} value
     * @param {!Object} options
     * @return {?}
     */
    function write(value, options) {
      return 0 === options.length ? null : (options.objectMode ? path = options.buffer.shift() : !value || value >= options.length ? (path = options.decoder ? options.buffer.join("") : 1 === options.buffer.length ? options.buffer.head.data : options.buffer.concat(options.length), options.buffer.clear()) : path = function(e, c, b) {
        var result;
        if (e < c.head.data.length) {
          result = c.head.data.slice(0, e);
          c.head.data = c.head.data.slice(e);
        } else {
          result = e === c.head.data.length ? c.shift() : b ? function(n, data) {
            var p = data.head;
            /** @type {number} */
            var count = 1;
            var str = p.data;
            /** @type {number} */
            n = n - str.length;
            for (; p = p.next;) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              if (nb === buf.length ? str = str + buf : str = str + buf.slice(0, n), 0 === (n = n - nb)) {
                if (nb === buf.length) {
                  ++count;
                  if (p.next) {
                    data.head = p.next;
                  } else {
                    /** @type {null} */
                    data.head = data.tail = null;
                  }
                } else {
                  data.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++count;
            }
            return data.length -= count, str;
          }(e, c) : function(i, current) {
            var a = Buffer.allocUnsafe(i);
            var node = current.head;
            /** @type {number} */
            var count = 1;
            node.data.copy(a);
            /** @type {number} */
            i = i - node.data.length;
            for (; node = node.next;) {
              var result = node.data;
              var length = i > result.length ? result.length : i;
              if (result.copy(a, a.length - i, 0, length), 0 === (i = i - length)) {
                if (length === result.length) {
                  ++count;
                  if (node.next) {
                    current.head = node.next;
                  } else {
                    /** @type {null} */
                    current.head = current.tail = null;
                  }
                } else {
                  current.head = node;
                  node.data = result.slice(length);
                }
                break;
              }
              ++count;
            }
            return current.length -= count, a;
          }(e, c);
        }
        return result;
      }(value, options.buffer, options.decoder), path);
      var path;
    }
    /**
     * @param {!Object} stream
     * @return {undefined}
     */
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) {
        throw new Error('"endReadable()" called on non-empty stream');
      }
      if (!state.endEmitted) {
        /** @type {boolean} */
        state.ended = true;
        process.nextTick(parse, state, stream);
      }
    }
    /**
     * @param {!NodeList} state
     * @param {!Object} messages
     * @return {undefined}
     */
    function parse(state, messages) {
      if (!(state.endEmitted || 0 !== state.length)) {
        /** @type {boolean} */
        state.endEmitted = true;
        /** @type {boolean} */
        messages.readable = false;
        messages.emit("end");
      }
    }
    /**
     * @param {!NodeList} array
     * @param {!Object} elem
     * @return {?}
     */
    function indexOf(array, elem) {
      /** @type {number} */
      var i = 0;
      var length = array.length;
      for (; i < length; i++) {
        if (array[i] === elem) {
          return i;
        }
      }
      return -1;
    }
    var process = require(30);
    /** @type {function(!Object): ?} */
    module.exports = Readable;
    var connectionFn;
    var resolve = require(63);
    /** @type {function(!Object, ?): undefined} */
    Readable.ReadableState = ReadableState;
    require(39).EventEmitter;
    /**
     * @param {!Object} elem
     * @param {string} type
     * @return {?}
     */
    var error = function(elem, type) {
      return elem.listeners(type).length;
    };
    var Transport = require(67);
    var Buffer = require(40).Buffer;
    var CJSEvent = PL$3.Uint8Array || function() {
    };
    /** @type {!Object} */
    var util = Object.create(require(21));
    util.inherits = require(1);
    var options = require(120);
    var debug = void 0;
    debug = options && options.debuglog ? options.debuglog("stream") : function() {
    };
    var StringDecoder;
    var type = require(121);
    var unzip = require(68);
    util.inherits(Readable, Transport);
    /** @type {!Array} */
    var events = ["error", "close", "destroy", "pause", "resume"];
    Object.defineProperty(Readable.prototype, "destroyed", {
      get : function() {
        return void 0 !== this._readableState && this._readableState.destroyed;
      },
      set : function(value) {
        if (this._readableState) {
          /** @type {string} */
          this._readableState.destroyed = value;
        }
      }
    });
    Readable.prototype.destroy = unzip.destroy;
    Readable.prototype._undestroy = unzip.undestroy;
    /**
     * @param {string} key
     * @param {string} callback
     * @return {undefined}
     */
    Readable.prototype._destroy = function(key, callback) {
      this.push(null);
      callback(key);
    };
    /**
     * @param {!Object} name
     * @param {number} value
     * @return {?}
     */
    Readable.prototype.push = function(name, value) {
      var path;
      var options = this._readableState;
      return options.objectMode ? path = true : "string" === typeof name && ((value = value || options.defaultEncoding) !== options.encoding && (name = Buffer.from(name, value), value = ""), path = true), read(this, name, value, false, path);
    };
    /**
     * @param {!Object} key
     * @return {?}
     */
    Readable.prototype.unshift = function(key) {
      return read(this, key, null, true, false);
    };
    /**
     * @return {?}
     */
    Readable.prototype.isPaused = function() {
      return false === this._readableState.flowing;
    };
    /**
     * @param {string} enc
     * @return {?}
     */
    Readable.prototype.setEncoding = function(enc) {
      return StringDecoder || (StringDecoder = require(42).StringDecoder), this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, this;
    };
    /**
     * @param {number} n
     * @return {?}
     */
    Readable.prototype.read = function(n) {
      debug("read", n);
      /** @type {number} */
      n = parseInt(n, 10);
      var state = this._readableState;
      /** @type {number} */
      var nOrig = n;
      if (0 !== n && (state.emittedReadable = false), 0 === n && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        return debug("read: emitReadable", state.length, state.ended), 0 === state.length && state.ended ? endReadable(this) : emitReadable(this), null;
      }
      if (0 === (n = howMuchToRead(n, state)) && state.ended) {
        return 0 === state.length && endReadable(this), null;
      }
      var ribbonHTML;
      var doRead = state.needReadable;
      return debug("need readable", doRead), (0 === state.length || state.length - n < state.highWaterMark) && debug("length less than watermark", doRead = true), state.ended || state.reading ? debug("reading or ended", doRead = false) : doRead && (debug("do read"), state.reading = true, state.sync = true, 0 === state.length && (state.needReadable = true), this._read(state.highWaterMark), state.sync = false, state.reading || (n = howMuchToRead(nOrig, state))), null === (ribbonHTML = n > 0 ? write(n, 
      state) : null) ? (state.needReadable = true, n = 0) : state.length -= n, 0 === state.length && (state.ended || (state.needReadable = true), nOrig !== n && state.ended && endReadable(this)), null !== ribbonHTML && this.emit("data", ribbonHTML), ribbonHTML;
    };
    /**
     * @param {number} type
     * @return {undefined}
     */
    Readable.prototype._read = function(type) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    /**
     * @param {!Object} dest
     * @param {!Object} pipeOpts
     * @return {?}
     */
    Readable.prototype.pipe = function(dest, pipeOpts) {
      /**
       * @param {?} i
       * @param {boolean} parent
       * @return {undefined}
       */
      function cleanup(i, parent) {
        debug("onunpipe");
        if (i === source && parent && false === parent.hasUnpiped) {
          /** @type {boolean} */
          parent.hasUnpiped = true;
          debug("cleanup");
          dest.removeListener("close", onclose);
          dest.removeListener("finish", onError);
          dest.removeListener("drain", callback);
          dest.removeListener("error", onerror);
          dest.removeListener("unpipe", cleanup);
          source.removeListener("end", onend);
          source.removeListener("end", end);
          source.removeListener("data", ondata);
          /** @type {boolean} */
          d = true;
          if (!(!state.awaitDrain || dest._writableState && !dest._writableState.needDrain)) {
            callback();
          }
        }
      }
      /**
       * @return {undefined}
       */
      function onend() {
        debug("onend");
        dest.end();
      }
      /**
       * @param {undefined} input
       * @return {undefined}
       */
      function ondata(input) {
        debug("ondata");
        /** @type {boolean} */
        p = false;
        if (!(false !== dest.write(input) || p)) {
          if ((1 === state.pipesCount && state.pipes === dest || state.pipesCount > 1 && -1 !== indexOf(state.pipes, dest)) && !d) {
            debug("false write response, pause", source._readableState.awaitDrain);
            source._readableState.awaitDrain++;
            /** @type {boolean} */
            p = true;
          }
          source.pause();
        }
      }
      /**
       * @param {!Object} link
       * @return {undefined}
       */
      function onerror(link) {
        debug("onerror", link);
        end();
        dest.removeListener("error", onerror);
        if (0 === error(dest, "error")) {
          dest.emit("error", link);
        }
      }
      /**
       * @return {undefined}
       */
      function onclose() {
        dest.removeListener("finish", onError);
        end();
      }
      /**
       * @return {undefined}
       */
      function onError() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        end();
      }
      /**
       * @return {undefined}
       */
      function end() {
        debug("unpipe");
        source.unpipe(dest);
      }
      var source = this;
      var state = this._readableState;
      switch(state.pipesCount) {
        case 0:
          /** @type {!Object} */
          state.pipes = dest;
          break;
        case 1:
          /** @type {!Array} */
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      /** @type {function(): undefined} */
      var cb = (!pipeOpts || false !== pipeOpts.end) && dest !== process.stdout && dest !== process.stderr ? onend : end;
      if (state.endEmitted) {
        process.nextTick(cb);
      } else {
        source.once("end", cb);
      }
      dest.on("unpipe", cleanup);
      var callback = function(src) {
        return function() {
          var state = src._readableState;
          debug("pipeOnDrain", state.awaitDrain);
          if (state.awaitDrain) {
            state.awaitDrain--;
          }
          if (0 === state.awaitDrain && error(src, "data")) {
            /** @type {boolean} */
            state.flowing = true;
            flow(src);
          }
        };
      }(source);
      dest.on("drain", callback);
      /** @type {boolean} */
      var d = false;
      /** @type {boolean} */
      var p = false;
      return source.on("data", ondata), function(emitter, type, fn) {
        if ("function" === typeof emitter.prependListener) {
          return emitter.prependListener(type, fn);
        }
        if (emitter._events && emitter._events[type]) {
          if (resolve(emitter._events[type])) {
            emitter._events[type].unshift(fn);
          } else {
            /** @type {!Array} */
            emitter._events[type] = [fn, emitter._events[type]];
          }
        } else {
          emitter.on(type, fn);
        }
      }(dest, "error", onerror), dest.once("close", onclose), dest.once("finish", onError), dest.emit("pipe", source), state.flowing || (debug("pipe resume"), source.resume()), dest;
    };
    /**
     * @param {!Object} dest
     * @return {?}
     */
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped : false
      };
      if (0 === state.pipesCount) {
        return this;
      }
      if (1 === state.pipesCount) {
        return dest && dest !== state.pipes || (dest || (dest = state.pipes), state.pipes = null, state.pipesCount = 0, state.flowing = false, dest && dest.emit("unpipe", this, unpipeInfo)), this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        /** @type {null} */
        state.pipes = null;
        /** @type {number} */
        state.pipesCount = 0;
        /** @type {boolean} */
        state.flowing = false;
        /** @type {number} */
        var i = 0;
        for (; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      return -1 === index || (state.pipes.splice(index, 1), state.pipesCount -= 1, 1 === state.pipesCount && (state.pipes = state.pipes[0]), dest.emit("unpipe", this, unpipeInfo)), this;
    };
    /**
     * @param {string} type
     * @param {!Object} listener
     * @return {?}
     */
    Readable.prototype.on = function(type, listener) {
      var signal = Transport.prototype.on.call(this, type, listener);
      if ("data" === type) {
        if (false !== this._readableState.flowing) {
          this.resume();
        }
      } else {
        if ("readable" === type) {
          var state = this._readableState;
          if (!(state.endEmitted || state.readableListening)) {
            /** @type {boolean} */
            state.readableListening = state.needReadable = true;
            /** @type {boolean} */
            state.emittedReadable = false;
            if (state.reading) {
              if (state.length) {
                emitReadable(this);
              }
            } else {
              process.nextTick(checkWorkers, this);
            }
          }
        }
      }
      return signal;
    };
    /** @type {function(string, !Object): ?} */
    Readable.prototype.addListener = Readable.prototype.on;
    /**
     * @return {?}
     */
    Readable.prototype.resume = function() {
      var state = this._readableState;
      return state.flowing || (debug("resume"), state.flowing = true, function(key, state) {
        if (!state.resumeScheduled) {
          /** @type {boolean} */
          state.resumeScheduled = true;
          process.nextTick(resume, key, state);
        }
      }(this, state)), this;
    };
    /**
     * @return {?}
     */
    Readable.prototype.pause = function() {
      return debug("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (debug("pause"), this._readableState.flowing = false, this.emit("pause")), this;
    };
    /**
     * @param {!Object} self
     * @return {?}
     */
    Readable.prototype.wrap = function(self) {
      var levitatingBlocks = this;
      var state = this._readableState;
      /** @type {boolean} */
      var n = false;
      var method_name;
      for (method_name in self.on("end", function() {
        if (debug("wrapped end"), state.decoder && !state.ended) {
          var block = state.decoder.end();
          if (block && block.length) {
            levitatingBlocks.push(block);
          }
        }
        levitatingBlocks.push(null);
      }), self.on("data", function(i) {
        if (debug("wrapped data"), state.decoder && (i = state.decoder.write(i)), !state.objectMode || null !== i && void 0 !== i) {
          if (state.objectMode || i && i.length) {
            if (!levitatingBlocks.push(i)) {
              /** @type {boolean} */
              n = true;
              self.pause();
            }
          }
        }
      }), self) {
        if (void 0 === this[method_name] && "function" === typeof self[method_name]) {
          this[method_name] = function(method_name) {
            return function() {
              return self[method_name].apply(self, arguments);
            };
          }(method_name);
        }
      }
      /** @type {number} */
      var i = 0;
      for (; i < events.length; i++) {
        self.on(events[i], this.emit.bind(this, events[i]));
      }
      return this._read = function(type) {
        debug("wrapped _read", type);
        if (n) {
          /** @type {boolean} */
          n = false;
          self.resume();
        }
      }, this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable : false,
      get : function() {
        return this._readableState.highWaterMark;
      }
    });
    /** @type {function(number, !Object): ?} */
    Readable._fromList = write;
  }).call(this, require(5), require(8));
}, function(exports, canCreateDiscussions, require) {
  exports.exports = require(39).EventEmitter;
}, function(page, canCreateDiscussions, require) {
  /**
   * @param {!Object} port
   * @param {!Object} success
   * @return {undefined}
   */
  function onComplete(port, success) {
    port.emit("error", success);
  }
  var process = require(30);
  page.exports = {
    destroy : function(key, value) {
      var self = this;
      var o = this._readableState && this._readableState.destroyed;
      var Post = this._writableState && this._writableState.destroyed;
      return o || Post ? (value ? value(key) : !key || this._writableState && this._writableState.errorEmitted || process.nextTick(onComplete, this, key), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(key || null, function(key) {
        if (!value && key) {
          process.nextTick(onComplete, self, key);
          if (self._writableState) {
            /** @type {boolean} */
            self._writableState.errorEmitted = true;
          }
        } else {
          if (value) {
            value(key);
          }
        }
      }), this);
    },
    undestroy : function() {
      if (this._readableState) {
        /** @type {boolean} */
        this._readableState.destroyed = false;
        /** @type {boolean} */
        this._readableState.reading = false;
        /** @type {boolean} */
        this._readableState.ended = false;
        /** @type {boolean} */
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        /** @type {boolean} */
        this._writableState.destroyed = false;
        /** @type {boolean} */
        this._writableState.ended = false;
        /** @type {boolean} */
        this._writableState.ending = false;
        /** @type {boolean} */
        this._writableState.finished = false;
        /** @type {boolean} */
        this._writableState.errorEmitted = false;
      }
    }
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {?} data
   * @param {!Object} type
   * @return {?}
   */
  function run(data, type) {
    var ts = this._transformState;
    /** @type {boolean} */
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    /** @type {null} */
    ts.writechunk = null;
    /** @type {null} */
    ts.writecb = null;
    if (null != type) {
      this.push(type);
    }
    cb(data);
    var rs = this._readableState;
    /** @type {boolean} */
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function Model(value) {
    if (!(this instanceof Model)) {
      return new Model(value);
    }
    API.call(this, value);
    this._transformState = {
      afterTransform : run.bind(this),
      needTransform : false,
      transforming : false,
      writecb : null,
      writechunk : null,
      writeencoding : null
    };
    /** @type {boolean} */
    this._readableState.needReadable = true;
    /** @type {boolean} */
    this._readableState.sync = false;
    if (value) {
      if ("function" === typeof value.transform) {
        /** @type {!Function} */
        this._transform = value.transform;
      }
      if ("function" === typeof value.flush) {
        /** @type {!Function} */
        this._flush = value.flush;
      }
    }
    this.on("prefinish", done);
  }
  /**
   * @return {undefined}
   */
  function done() {
    var t = this;
    if ("function" === typeof this._flush) {
      this._flush(function(child, resultin) {
        flush(t, child, resultin);
      });
    } else {
      flush(this, null, null);
    }
  }
  /**
   * @param {?} stream
   * @param {!Object} doc
   * @param {!Object} r
   * @return {?}
   */
  function flush(stream, doc, r) {
    if (doc) {
      return stream.emit("error", doc);
    }
    if (null != r && stream.push(r), stream._writableState.length) {
      throw new Error("Calling transform done when ws.length != 0");
    }
    if (stream._transformState.transforming) {
      throw new Error("Calling transform done when still transforming");
    }
    return stream.push(null);
  }
  /** @type {function(!Object): ?} */
  module.exports = Model;
  var API = require(13);
  /** @type {!Object} */
  var _ = Object.create(require(21));
  _.inherits = require(1);
  _.inherits(Model, API);
  /**
   * @param {!Object} type
   * @param {?} obj
   * @return {?}
   */
  Model.prototype.push = function(type, obj) {
    return this._transformState.needTransform = false, API.prototype.push.call(this, type, obj);
  };
  /**
   * @param {!Array} rws
   * @param {!Array} iws
   * @param {!Array} rtws
   * @return {?}
   */
  Model.prototype._transform = function(rws, iws, rtws) {
    throw new Error("_transform() is not implemented");
  };
  /**
   * @param {!Object} id
   * @param {!Object} value
   * @param {number} cb
   * @return {undefined}
   */
  Model.prototype._write = function(id, value, cb) {
    var ts = this._transformState;
    if (ts.writecb = cb, ts.writechunk = id, ts.writeencoding = value, !ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
  };
  /**
   * @param {number} type
   * @return {undefined}
   */
  Model.prototype._read = function(type) {
    var ts = this._transformState;
    if (null !== ts.writechunk && ts.writecb && !ts.transforming) {
      /** @type {boolean} */
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      /** @type {boolean} */
      ts.needTransform = true;
    }
  };
  /**
   * @param {string} key
   * @param {string} callback
   * @return {undefined}
   */
  Model.prototype._destroy = function(key, callback) {
    var notificationWindow = this;
    API.prototype._destroy.call(this, key, function(identifierPositions) {
      callback(identifierPositions);
      notificationWindow.emit("close");
    });
  };
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha512() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    Duplex.call(this, 64, 56);
  }
  /**
   * @param {number} e
   * @param {number} f
   * @param {number} g
   * @return {?}
   */
  function filter(e, f, g) {
    return g ^ e & (f ^ g);
  }
  /**
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @return {?}
   */
  function interpolateQuartic(b, c, d) {
    return b & c | d & (b | c);
  }
  /**
   * @param {number} x
   * @return {?}
   */
  function Sigma0256(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  /**
   * @param {number} x
   * @return {?}
   */
  function Sigma1256(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  /**
   * @param {number} x
   * @return {?}
   */
  function Gamma1256(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  var inherits = require(1);
  var Duplex = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var siblingsToAdd = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 
  2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  /** @type {!Array} */
  var w = new Array(64);
  inherits(Sha512, Duplex);
  /**
   * @return {?}
   */
  Sha512.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  /**
   * @param {!Object} buffer
   * @return {undefined}
   */
  Sha512.prototype._update = function(buffer) {
    var x;
    var W = this._w;
    /** @type {number} */
    var a = 0 | this._a;
    /** @type {number} */
    var b = 0 | this._b;
    /** @type {number} */
    var c = 0 | this._c;
    /** @type {number} */
    var d = 0 | this._d;
    /** @type {number} */
    var e = 0 | this._e;
    /** @type {number} */
    var f = 0 | this._f;
    /** @type {number} */
    var g = 0 | this._g;
    /** @type {number} */
    var h = 0 | this._h;
    /** @type {number} */
    var j = 0;
    for (; j < 16; ++j) {
      W[j] = buffer.readInt32BE(4 * j);
    }
    for (; j < 64; ++j) {
      /** @type {number} */
      W[j] = 0 | (((x = W[j - 2]) >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10) + W[j - 7] + Gamma1256(W[j - 15]) + W[j - 16];
    }
    /** @type {number} */
    var i = 0;
    for (; i < 64; ++i) {
      /** @type {number} */
      var managementcommandsdns = h + Sigma1256(e) + filter(e, f, g) + siblingsToAdd[i] + W[i] | 0;
      /** @type {number} */
      var siteName = Sigma0256(a) + interpolateQuartic(a, b, c) | 0;
      /** @type {number} */
      h = g;
      /** @type {number} */
      g = f;
      /** @type {number} */
      f = e;
      /** @type {number} */
      e = d + managementcommandsdns | 0;
      /** @type {number} */
      d = c;
      /** @type {number} */
      c = b;
      /** @type {number} */
      b = a;
      /** @type {number} */
      a = managementcommandsdns + siteName | 0;
    }
    /** @type {number} */
    this._a = a + this._a | 0;
    /** @type {number} */
    this._b = b + this._b | 0;
    /** @type {number} */
    this._c = c + this._c | 0;
    /** @type {number} */
    this._d = d + this._d | 0;
    /** @type {number} */
    this._e = e + this._e | 0;
    /** @type {number} */
    this._f = f + this._f | 0;
    /** @type {number} */
    this._g = g + this._g | 0;
    /** @type {number} */
    this._h = h + this._h | 0;
  };
  /**
   * @return {?}
   */
  Sha512.prototype._hash = function() {
    var H = Buffer.allocUnsafe(32);
    return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H.writeInt32BE(this._h, 28), H;
  };
  /** @type {function(): undefined} */
  mixin.exports = Sha512;
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha512() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    Duplex.call(this, 128, 112);
  }
  /**
   * @param {number} e
   * @param {number} f
   * @param {number} g
   * @return {?}
   */
  function Ch(e, f, g) {
    return g ^ e & (f ^ g);
  }
  /**
   * @param {number} x
   * @param {number} m
   * @param {number} y
   * @return {?}
   */
  function max(x, m, y) {
    return x & m | y & (x | m);
  }
  /**
   * @param {number} value
   * @param {number} doc
   * @return {?}
   */
  function cb(value, doc) {
    return (value >>> 28 | doc << 4) ^ (doc >>> 2 | value << 30) ^ (doc >>> 7 | value << 25);
  }
  /**
   * @param {number} e
   * @param {number} element
   * @return {?}
   */
  function $(e, element) {
    return (e >>> 14 | element << 18) ^ (e >>> 18 | element << 14) ^ (element >>> 9 | e << 23);
  }
  /**
   * @param {number} id
   * @param {number} name
   * @return {?}
   */
  function defined(id, name) {
    return (id >>> 1 | name << 31) ^ (id >>> 8 | name << 24) ^ id >>> 7;
  }
  /**
   * @param {number} value
   * @param {number} stylesheet
   * @return {?}
   */
  function add(value, stylesheet) {
    return (value >>> 1 | stylesheet << 31) ^ (value >>> 8 | stylesheet << 24) ^ (value >>> 7 | stylesheet << 25);
  }
  /**
   * @param {number} lo
   * @param {number} hi
   * @return {?}
   */
  function update(lo, hi) {
    return (lo >>> 19 | hi << 13) ^ (hi >>> 29 | lo << 3) ^ lo >>> 6;
  }
  /**
   * @param {number} lo
   * @param {number} hi
   * @return {?}
   */
  function done(lo, hi) {
    return (lo >>> 19 | hi << 13) ^ (hi >>> 29 | lo << 3) ^ (lo >>> 6 | hi << 26);
  }
  /**
   * @param {number} y
   * @param {number} val
   * @return {?}
   */
  function callback(y, val) {
    return y >>> 0 < val >>> 0 ? 1 : 0;
  }
  var inherits = require(1);
  var Duplex = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var items = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 
  1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 
  3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 
  3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  /** @type {!Array} */
  var w = new Array(160);
  inherits(Sha512, Duplex);
  /**
   * @return {?}
   */
  Sha512.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  /**
   * @param {!Object} data
   * @return {undefined}
   */
  Sha512.prototype._update = function(data) {
    var args = this._w;
    /** @type {number} */
    var value = 0 | this._ah;
    /** @type {number} */
    var y = 0 | this._bh;
    /** @type {number} */
    var t = 0 | this._ch;
    /** @type {number} */
    var text = 0 | this._dh;
    /** @type {number} */
    var e = 0 | this._eh;
    /** @type {number} */
    var f = 0 | this._fh;
    /** @type {number} */
    var g = 0 | this._gh;
    /** @type {number} */
    var a = 0 | this._hh;
    /** @type {number} */
    var data = 0 | this._al;
    /** @type {number} */
    var b = 0 | this._bl;
    /** @type {number} */
    var c = 0 | this._cl;
    /** @type {number} */
    var group = 0 | this._dl;
    /** @type {number} */
    var el = 0 | this._el;
    /** @type {number} */
    var fl = 0 | this._fl;
    /** @type {number} */
    var gl = 0 | this._gl;
    /** @type {number} */
    var hl = 0 | this._hl;
    /** @type {number} */
    var i = 0;
    for (; i < 32; i = i + 2) {
      args[i] = data.readInt32BE(4 * i);
      args[i + 1] = data.readInt32BE(4 * i + 4);
    }
    for (; i < 160; i = i + 2) {
      var obj = args[i - 30];
      var name = args[i - 30 + 1];
      var n = defined(obj, name);
      var options = add(name, obj);
      var a = update(obj = args[i - 4], name = args[i - 4 + 1]);
      var result = done(name, obj);
      var _ = args[i - 14];
      var val = args[i - 14 + 1];
      var ttyname = args[i - 32];
      var date = args[i - 32 + 1];
      /** @type {number} */
      var v = options + val | 0;
      /** @type {number} */
      var output = n + _ + callback(v, options) | 0;
      /** @type {number} */
      output = (output = output + a + callback(v = v + result | 0, result) | 0) + ttyname + callback(v = v + date | 0, date) | 0;
      /** @type {number} */
      args[i] = output;
      /** @type {number} */
      args[i + 1] = v;
    }
    /** @type {number} */
    var index = 0;
    for (; index < 160; index = index + 2) {
      output = args[index];
      v = args[index + 1];
      var result = max(value, y, t);
      var m = max(data, b, c);
      var name = cb(value, data);
      var ret = cb(data, value);
      var x = $(e, el);
      var placeholder = $(el, e);
      var constructor = items[index];
      var last = items[index + 1];
      var ch = Ch(e, f, g);
      var width = Ch(el, fl, gl);
      /** @type {number} */
      var i = hl + placeholder | 0;
      /** @type {number} */
      var prefix = a + x + callback(i, hl) | 0;
      /** @type {number} */
      prefix = (prefix = (prefix = prefix + ch + callback(i = i + width | 0, width) | 0) + constructor + callback(i = i + last | 0, last) | 0) + output + callback(i = i + v | 0, v) | 0;
      /** @type {number} */
      var s = ret + m | 0;
      /** @type {number} */
      var _ = name + result + callback(s, ret) | 0;
      /** @type {number} */
      a = g;
      /** @type {number} */
      hl = gl;
      /** @type {number} */
      g = f;
      /** @type {number} */
      gl = fl;
      /** @type {number} */
      f = e;
      /** @type {number} */
      fl = el;
      /** @type {number} */
      e = text + prefix + callback(el = group + i | 0, group) | 0;
      /** @type {number} */
      text = t;
      /** @type {number} */
      group = c;
      /** @type {number} */
      t = y;
      /** @type {number} */
      c = b;
      /** @type {number} */
      y = value;
      /** @type {number} */
      b = data;
      /** @type {number} */
      value = prefix + _ + callback(data = i + s | 0, i) | 0;
    }
    /** @type {number} */
    this._al = this._al + data | 0;
    /** @type {number} */
    this._bl = this._bl + b | 0;
    /** @type {number} */
    this._cl = this._cl + c | 0;
    /** @type {number} */
    this._dl = this._dl + group | 0;
    /** @type {number} */
    this._el = this._el + el | 0;
    /** @type {number} */
    this._fl = this._fl + fl | 0;
    /** @type {number} */
    this._gl = this._gl + gl | 0;
    /** @type {number} */
    this._hl = this._hl + hl | 0;
    /** @type {number} */
    this._ah = this._ah + value + callback(this._al, data) | 0;
    /** @type {number} */
    this._bh = this._bh + y + callback(this._bl, b) | 0;
    /** @type {number} */
    this._ch = this._ch + t + callback(this._cl, c) | 0;
    /** @type {number} */
    this._dh = this._dh + text + callback(this._dl, group) | 0;
    /** @type {number} */
    this._eh = this._eh + e + callback(this._el, el) | 0;
    /** @type {number} */
    this._fh = this._fh + f + callback(this._fl, fl) | 0;
    /** @type {number} */
    this._gh = this._gh + g + callback(this._gl, gl) | 0;
    /** @type {number} */
    this._hh = this._hh + a + callback(this._hl, hl) | 0;
  };
  /**
   * @return {?}
   */
  Sha512.prototype._hash = function() {
    /**
     * @param {undefined} val
     * @param {undefined} num
     * @param {number} offset
     * @return {undefined}
     */
    function writeInt64BE(val, num, offset) {
      buff.writeInt32BE(val, offset);
      buff.writeInt32BE(num, offset + 4);
    }
    var buff = Buffer.allocUnsafe(64);
    return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), writeInt64BE(this._gh, this._gl, 48), writeInt64BE(this._hh, this._hl, 56), buff;
  };
  /** @type {function(): undefined} */
  mixin.exports = Sha512;
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @param {string} alg
   * @param {number} data
   * @return {undefined}
   */
  function Hmac(alg, data) {
    Base.call(this, "digest");
    if ("string" === typeof data) {
      data = Buffer.from(data);
    }
    /** @type {number} */
    var size = "sha512" === alg || "sha384" === alg ? 128 : 64;
    if (this._alg = alg, this._key = data, data.length > size) {
      data = ("rmd160" === alg ? new CheckDailyStat : createHash(alg)).update(data).digest();
    } else {
      if (data.length < size) {
        data = Buffer.concat([data, decFinal], size);
      }
    }
    var str = this._ipad = Buffer.allocUnsafe(size);
    var opad = this._opad = Buffer.allocUnsafe(size);
    /** @type {number} */
    var i = 0;
    for (; i < size; i++) {
      /** @type {number} */
      str[i] = 54 ^ data[i];
      /** @type {number} */
      opad[i] = 92 ^ data[i];
    }
    this._hash = "rmd160" === alg ? new CheckDailyStat : createHash(alg);
    this._hash.update(str);
  }
  var inherits = require(1);
  var EnhancedModule = require(135);
  var Base = require(10);
  var Buffer = require(2).Buffer;
  var request = require(73);
  var CheckDailyStat = require(43);
  var createHash = require(44);
  var decFinal = Buffer.alloc(128);
  inherits(Hmac, Base);
  /**
   * @param {!Array} data
   * @return {undefined}
   */
  Hmac.prototype._update = function(data) {
    this._hash.update(data);
  };
  /**
   * @return {?}
   */
  Hmac.prototype._final = function() {
    var U = this._hash.digest();
    return ("rmd160" === this._alg ? new CheckDailyStat : createHash(this._alg)).update(this._opad).update(U).digest();
  };
  /**
   * @param {string} key
   * @param {string} parent
   * @return {?}
   */
  mixin.exports = function(key, parent) {
    return "rmd160" === (key = key.toLowerCase()) || "ripemd160" === key ? new Hmac("rmd160", parent) : "md5" === key ? new EnhancedModule(request, parent) : new Hmac(key, parent);
  };
}, function(mixin, canCreateDiscussions, require) {
  var Md5 = require(37);
  /**
   * @param {!Object} key
   * @return {?}
   */
  mixin.exports = function(key) {
    return (new Md5).update(key).digest();
  };
}, function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"sha224WithRSAEncryption":{"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"RSA-SHA224":{"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},"sha256WithRSAEncryption":{"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"RSA-SHA256":{"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},"sha384WithRSAEncryption":{"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"RSA-SHA384":{"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},"sha512WithRSAEncryption":{"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA512":{"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},"RSA-SHA1":{"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{"sign":"ecdsa","hash":"sha1","id":""},"sha256":{"sign":"ecdsa","hash":"sha256","id":""},"sha224":{"sign":"ecdsa","hash":"sha224","id":""},"sha384":{"sign":"ecdsa","hash":"sha384","id":""},"sha512":{"sign":"ecdsa","hash":"sha512","id":""},"DSA-SHA":{"sign":"dsa","hash":"sha1","id":""},"DSA-SHA1":{"sign":"dsa","hash":"sha1","id":""},"DSA":{"sign":"dsa","hash":"sha1","id":""},"DSA-WITH-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-SHA224":{"sign":"dsa","hash":"sha224","id":""},"DSA-WITH-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-SHA256":{"sign":"dsa","hash":"sha256","id":""},"DSA-WITH-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-SHA384":{"sign":"dsa","hash":"sha384","id":""},"DSA-WITH-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-SHA512":{"sign":"dsa","hash":"sha512","id":""},"DSA-RIPEMD160":{"sign":"dsa","hash":"rmd160","id":""},"ripemd160WithRSA":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"RSA-RIPEMD160":{"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},"md5WithRSAEncryption":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},"RSA-MD5":{"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"}}');
}, function(canCreateDiscussions, compat, saveNotifs) {
  compat.pbkdf2 = saveNotifs(137);
  compat.pbkdf2Sync = saveNotifs(78);
}, function(mixin, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {!Object} value
     * @param {string} text
     * @return {undefined}
     */
    function y(value, text) {
      if ("string" !== typeof value && !Buffer.isBuffer(value)) {
        throw new TypeError(text + " must be a buffer or string");
      }
    }
    /** @type {number} */
    var maxConstraint = Math.pow(2, 30) - 1;
    /**
     * @param {string} value
     * @param {string} e
     * @param {?} id
     * @param {number} val
     * @return {undefined}
     */
    mixin.exports = function(value, e, id, val) {
      if (y(value, "Password"), y(e, "Salt"), "number" !== typeof id) {
        throw new TypeError("Iterations not a number");
      }
      if (id < 0) {
        throw new TypeError("Bad iterations");
      }
      if ("number" !== typeof val) {
        throw new TypeError("Key length not a number");
      }
      if (val < 0 || val > maxConstraint || val !== val) {
        throw new TypeError("Bad key length");
      }
    };
  }).call(this, require(3).Buffer);
}, function(blob, canCreateDiscussions, moment) {
  (function(process) {
    var encoding;
    if (process.browser) {
      /** @type {string} */
      encoding = "utf-8";
    } else {
      /** @type {string} */
      encoding = parseInt(process.version.split(".")[0].slice(1), 10) >= 6 ? "utf-8" : "binary";
    }
    blob.exports = encoding;
  }).call(this, moment(8));
}, function(mixin, canCreateDiscussions, __webpack_require__) {
  /**
   * @param {string} key
   * @param {string} value
   * @param {number} type
   * @return {undefined}
   */
  function init(key, value, type) {
    var hash = function(alg) {
      /**
       * @param {?} str
       * @return {?}
       */
      function makeDxsyncHash(str) {
        return createHash(alg).update(str).digest();
      }
      return "rmd160" === alg || "ripemd160" === alg ? function(U) {
        return (new Element).update(U).digest();
      } : "md5" === alg ? _UiIcon : makeDxsyncHash;
    }(key);
    /** @type {number} */
    var size = "sha512" === key || "sha384" === key ? 128 : 64;
    if (value.length > size) {
      value = hash(value);
    } else {
      if (value.length < size) {
        value = Buffer.concat([value, decFinal], size);
      }
    }
    var buffer = Buffer.allocUnsafe(size + data[key]);
    var augmentedMethods = Buffer.allocUnsafe(size + data[key]);
    /** @type {number} */
    var s = 0;
    for (; s < size; s++) {
      /** @type {number} */
      buffer[s] = 54 ^ value[s];
      /** @type {number} */
      augmentedMethods[s] = 92 ^ value[s];
    }
    var p = Buffer.allocUnsafe(size + type + 4);
    buffer.copy(p, 0, 0, size);
    this.ipad1 = p;
    this.ipad2 = buffer;
    this.opad = augmentedMethods;
    /** @type {string} */
    this.alg = key;
    /** @type {number} */
    this.blocksize = size;
    this.hash = hash;
    this.size = data[key];
  }
  var _UiIcon = __webpack_require__(73);
  var Element = __webpack_require__(43);
  var createHash = __webpack_require__(44);
  var a = __webpack_require__(76);
  var value = __webpack_require__(77);
  var Buffer = __webpack_require__(2).Buffer;
  var decFinal = Buffer.alloc(128);
  var data = {
    md5 : 16,
    sha1 : 20,
    sha224 : 28,
    sha256 : 32,
    sha384 : 48,
    sha512 : 64,
    rmd160 : 20,
    ripemd160 : 20
  };
  /**
   * @param {!Request} type
   * @param {undefined} data
   * @return {?}
   */
  init.prototype.run = function(type, data) {
    return type.copy(data, this.blocksize), this.hash(data).copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  /**
   * @param {!Object} key
   * @param {string} d
   * @param {number} n
   * @param {?} s
   * @param {string} hash
   * @return {?}
   */
  mixin.exports = function(key, d, n, s, hash) {
    a(key, d, n, s);
    if (!Buffer.isBuffer(key)) {
      key = Buffer.from(key, value);
    }
    if (!Buffer.isBuffer(d)) {
      d = Buffer.from(d, value);
    }
    var item = new init(hash = hash || "sha1", key, d.length);
    var r = Buffer.allocUnsafe(s);
    var source = Buffer.allocUnsafe(d.length + 4);
    d.copy(source, 0, 0, d.length);
    /** @type {number} */
    var m = 0;
    var w = data[hash];
    /** @type {number} */
    var resizeCount = Math.ceil(s / w);
    /** @type {number} */
    var i = 1;
    for (; i <= resizeCount; i++) {
      source.writeUInt32BE(i, d.length);
      var state = item.run(source, item.ipad1);
      var key = state;
      /** @type {number} */
      var hits = 1;
      for (; hits < n; hits++) {
        key = item.run(key, item.ipad2);
        /** @type {number} */
        var j = 0;
        for (; j < w; j++) {
          state[j] ^= key[j];
        }
      }
      state.copy(r, m);
      m = m + w;
    }
    return r;
  };
}, function(canCreateDiscussions, message, isSlidingUp) {
  /**
   * @param {number} bytes
   * @param {number} off
   * @return {?}
   */
  message.readUInt32BE = function(bytes, off) {
    return (bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off]) >>> 0;
  };
  /**
   * @param {number} data
   * @param {number} value
   * @param {number} offset
   * @return {undefined}
   */
  message.writeUInt32BE = function(data, value, offset) {
    /** @type {number} */
    data[0 + offset] = value >>> 24;
    /** @type {number} */
    data[1 + offset] = value >>> 16 & 255;
    /** @type {number} */
    data[2 + offset] = value >>> 8 & 255;
    /** @type {number} */
    data[3 + offset] = 255 & value;
  };
  /**
   * @param {number} inL
   * @param {number} inR
   * @param {?} out
   * @param {number} off
   * @return {undefined}
   */
  message.ip = function(inL, inR, out, off) {
    /** @type {number} */
    var outL = 0;
    /** @type {number} */
    var outR = 0;
    /** @type {number} */
    var i = 6;
    for (; i >= 0; i = i - 2) {
      /** @type {number} */
      var j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inR >>> j + i & 1;
      }
      /** @type {number} */
      j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inL >>> j + i & 1;
      }
    }
    /** @type {number} */
    i = 6;
    for (; i >= 0; i = i - 2) {
      /** @type {number} */
      j = 1;
      for (; j <= 25; j = j + 8) {
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inR >>> j + i & 1;
      }
      /** @type {number} */
      j = 1;
      for (; j <= 25; j = j + 8) {
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inL >>> j + i & 1;
      }
    }
    /** @type {number} */
    out[off + 0] = outL >>> 0;
    /** @type {number} */
    out[off + 1] = outR >>> 0;
  };
  /**
   * @param {number} inL
   * @param {number} inR
   * @param {?} out
   * @param {number} off
   * @return {undefined}
   */
  message.rip = function(inL, inR, out, off) {
    /** @type {number} */
    var outL = 0;
    /** @type {number} */
    var outR = 0;
    /** @type {number} */
    var i = 0;
    for (; i < 4; i++) {
      /** @type {number} */
      var j = 24;
      for (; j >= 0; j = j - 8) {
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inR >>> j + i & 1;
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inL >>> j + i & 1;
      }
    }
    /** @type {number} */
    i = 4;
    for (; i < 8; i++) {
      /** @type {number} */
      j = 24;
      for (; j >= 0; j = j - 8) {
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inR >>> j + i & 1;
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inL >>> j + i & 1;
      }
    }
    /** @type {number} */
    out[off + 0] = outL >>> 0;
    /** @type {number} */
    out[off + 1] = outR >>> 0;
  };
  /**
   * @param {number} inL
   * @param {number} inR
   * @param {?} out
   * @param {number} off
   * @return {undefined}
   */
  message.pc1 = function(inL, inR, out, off) {
    /** @type {number} */
    var outL = 0;
    /** @type {number} */
    var outR = 0;
    /** @type {number} */
    var i = 7;
    for (; i >= 5; i--) {
      /** @type {number} */
      var j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inR >> j + i & 1;
      }
      /** @type {number} */
      j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outL = outL << 1;
        /** @type {number} */
        outL = outL | inL >> j + i & 1;
      }
    }
    /** @type {number} */
    j = 0;
    for (; j <= 24; j = j + 8) {
      /** @type {number} */
      outL = outL << 1;
      /** @type {number} */
      outL = outL | inR >> j + i & 1;
    }
    /** @type {number} */
    i = 1;
    for (; i <= 3; i++) {
      /** @type {number} */
      j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inR >> j + i & 1;
      }
      /** @type {number} */
      j = 0;
      for (; j <= 24; j = j + 8) {
        /** @type {number} */
        outR = outR << 1;
        /** @type {number} */
        outR = outR | inL >> j + i & 1;
      }
    }
    /** @type {number} */
    j = 0;
    for (; j <= 24; j = j + 8) {
      /** @type {number} */
      outR = outR << 1;
      /** @type {number} */
      outR = outR | inL >> j + i & 1;
    }
    /** @type {number} */
    out[off + 0] = outL >>> 0;
    /** @type {number} */
    out[off + 1] = outR >>> 0;
  };
  /**
   * @param {number} num
   * @param {number} shift
   * @return {?}
   */
  message.r28shl = function(num, shift) {
    return num << shift & 268435455 | num >>> 28 - shift;
  };
  /** @type {!Array} */
  var pc2table = [14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];
  /**
   * @param {?} inL
   * @param {?} inR
   * @param {!Array} out
   * @param {number} off
   * @return {undefined}
   */
  message.pc2 = function(inL, inR, out, off) {
    /** @type {number} */
    var outL = 0;
    /** @type {number} */
    var outR = 0;
    /** @type {number} */
    var contactCapacity = pc2table.length >>> 1;
    /** @type {number} */
    var i = 0;
    for (; i < contactCapacity; i++) {
      /** @type {number} */
      outL = outL << 1;
      /** @type {number} */
      outL = outL | inL >>> pc2table[i] & 1;
    }
    /** @type {number} */
    i = contactCapacity;
    for (; i < pc2table.length; i++) {
      /** @type {number} */
      outR = outR << 1;
      /** @type {number} */
      outR = outR | inR >>> pc2table[i] & 1;
    }
    /** @type {number} */
    out[off + 0] = outL >>> 0;
    /** @type {number} */
    out[off + 1] = outR >>> 0;
  };
  /**
   * @param {number} n
   * @param {?} data
   * @param {number} elem
   * @return {undefined}
   */
  message.expand = function(n, data, elem) {
    /** @type {number} */
    var size = 0;
    /** @type {number} */
    var num = 0;
    /** @type {number} */
    size = (1 & n) << 5 | n >>> 27;
    /** @type {number} */
    var b = 23;
    for (; b >= 15; b = b - 4) {
      /** @type {number} */
      size = size << 6;
      /** @type {number} */
      size = size | n >>> b & 63;
    }
    /** @type {number} */
    b = 11;
    for (; b >= 3; b = b - 4) {
      /** @type {number} */
      num = num | n >>> b & 63;
      /** @type {number} */
      num = num << 6;
    }
    /** @type {number} */
    num = num | ((31 & n) << 1 | n >>> 31);
    /** @type {number} */
    data[elem + 0] = size >>> 0;
    /** @type {number} */
    data[elem + 1] = num >>> 0;
  };
  /** @type {!Array} */
  var bytes = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 
  2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 
  12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 
  14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];
  /**
   * @param {number} inL
   * @param {number} inR
   * @return {?}
   */
  message.substitute = function(inL, inR) {
    /** @type {number} */
    var mantissa = 0;
    /** @type {number} */
    var n = 0;
    for (; n < 4; n++) {
      /** @type {number} */
      mantissa = mantissa << 4;
      /** @type {number} */
      mantissa = mantissa | bytes[64 * n + (inL >>> 18 - 6 * n & 63)];
    }
    /** @type {number} */
    n = 0;
    for (; n < 4; n++) {
      /** @type {number} */
      mantissa = mantissa << 4;
      /** @type {number} */
      mantissa = mantissa | bytes[256 + 64 * n + (inR >>> 18 - 6 * n & 63)];
    }
    return mantissa >>> 0;
  };
  /** @type {!Array} */
  var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];
  /**
   * @param {!NodeList} num
   * @return {?}
   */
  message.permute = function(num) {
    /** @type {number} */
    var current = 0;
    /** @type {number} */
    var i = 0;
    for (; i < permuteTable.length; i++) {
      /** @type {number} */
      current = current << 1;
      /** @type {number} */
      current = current | num >>> permuteTable[i] & 1;
    }
    return current >>> 0;
  };
  /**
   * @param {string} group
   * @param {number} num
   * @param {number} size
   * @return {?}
   */
  message.padSplit = function(group, num, size) {
    var str = group.toString(2);
    for (; str.length < num;) {
      /** @type {string} */
      str = "0" + str;
    }
    /** @type {!Array} */
    var binaryValues = [];
    /** @type {number} */
    var i = 0;
    for (; i < num; i = i + size) {
      binaryValues.push(str.slice(i, i + size));
    }
    return binaryValues.join(" ");
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function main() {
    /** @type {!Array} */
    this.tmp = new Array(2);
    /** @type {null} */
    this.keys = null;
  }
  /**
   * @param {string} key
   * @return {undefined}
   */
  function Cipher(key) {
    Observer.call(this, key);
    var state = new main;
    this._desState = state;
    this.deriveKeys(state, key.key);
  }
  var assert = require(6);
  var inherits = require(1);
  var utils = require(79);
  var Observer = require(45);
  inherits(Cipher, Observer);
  /** @type {function(string): undefined} */
  module.exports = Cipher;
  /**
   * @param {string} key
   * @return {?}
   */
  Cipher.create = function(key) {
    return new Cipher(key);
  };
  /** @type {!Array} */
  var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];
  /**
   * @param {!Object} state
   * @param {number} key
   * @return {undefined}
   */
  Cipher.prototype.deriveKeys = function(state, key) {
    /** @type {!Array} */
    state.keys = new Array(32);
    assert.equal(key.length, this.blockSize, "Invalid key length");
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];
    /** @type {number} */
    var i = 0;
    for (; i < state.keys.length; i = i + 2) {
      var shift = shiftTable[i >>> 1];
      kL = utils.r28shl(kL, shift);
      kR = utils.r28shl(kR, shift);
      utils.pc2(kL, kR, state.keys, i);
    }
  };
  /**
   * @param {!Array} a
   * @param {number} inOff
   * @param {!Array} out
   * @param {number} outOff
   * @return {undefined}
   */
  Cipher.prototype._update = function(a, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(a, inOff);
    var r = utils.readUInt32BE(a, inOff + 4);
    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if ("encrypt" === this.type) {
      this._encrypt(state, l, r, state.tmp, 0);
    } else {
      this._decrypt(state, l, r, state.tmp, 0);
    }
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
  };
  /**
   * @param {!NodeList} buffer
   * @param {?} length
   * @return {?}
   */
  Cipher.prototype._pad = function(buffer, length) {
    /** @type {number} */
    var parsedBodyNode = buffer.length - length;
    var n = length;
    for (; n < buffer.length; n++) {
      /** @type {number} */
      buffer[n] = parsedBodyNode;
    }
    return true;
  };
  /**
   * @param {!Array} buffer
   * @return {?}
   */
  Cipher.prototype._unpad = function(buffer) {
    var pad = buffer[buffer.length - 1];
    /** @type {number} */
    var i = buffer.length - pad;
    for (; i < buffer.length; i++) {
      assert.equal(buffer[i], pad);
    }
    return buffer.slice(0, buffer.length - pad);
  };
  /**
   * @param {!Object} state
   * @param {!Array} lStart
   * @param {!Array} rStart
   * @param {?} out
   * @param {number} off
   * @return {undefined}
   */
  Cipher.prototype._encrypt = function(state, lStart, rStart, out, off) {
    /** @type {!Array} */
    var r = lStart;
    /** @type {!Array} */
    var l = rStart;
    /** @type {number} */
    var i = 0;
    for (; i < state.keys.length; i = i + 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(l, state.tmp, 0);
      /** @type {number} */
      keyL = keyL ^ state.tmp[0];
      /** @type {number} */
      keyR = keyR ^ state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var ret = l;
      /** @type {number} */
      l = (r ^ utils.permute(s)) >>> 0;
      r = ret;
    }
    utils.rip(l, r, out, off);
  };
  /**
   * @param {!Object} state
   * @param {!Array} lStart
   * @param {!Array} rStart
   * @param {?} out
   * @param {number} off
   * @return {undefined}
   */
  Cipher.prototype._decrypt = function(state, lStart, rStart, out, off) {
    /** @type {!Array} */
    var l = rStart;
    /** @type {!Array} */
    var r = lStart;
    /** @type {number} */
    var i = state.keys.length - 2;
    for (; i >= 0; i = i - 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1];
      utils.expand(l, state.tmp, 0);
      /** @type {number} */
      keyL = keyL ^ state.tmp[0];
      /** @type {number} */
      keyR = keyR ^ state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var ret = l;
      /** @type {number} */
      l = (r ^ utils.permute(s)) >>> 0;
      r = ret;
    }
    utils.rip(l, r, out, off);
  };
}, function(canCreateDiscussions, state, require) {
  /**
   * @param {?} self
   * @return {?}
   */
  function encryptByte(self) {
    var result = self._cipher.encryptBlockRaw(self._prev);
    return shiftIn(self._prev), result;
  }
  var xor = require(22);
  var Buffer = require(2).Buffer;
  var shiftIn = require(82);
  /**
   * @param {?} self
   * @param {!Object} block
   * @return {?}
   */
  state.encrypt = function(self, block) {
    /** @type {number} */
    var otherValue = Math.ceil(block.length / 16);
    var x = self._cache.length;
    self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(16 * otherValue)]);
    /** @type {number} */
    var i = 0;
    for (; i < otherValue; i++) {
      var value = encryptByte(self);
      var pos = x + 16 * i;
      self._cache.writeUInt32BE(value[0], pos + 0);
      self._cache.writeUInt32BE(value[1], pos + 4);
      self._cache.writeUInt32BE(value[2], pos + 8);
      self._cache.writeUInt32BE(value[3], pos + 12);
    }
    var Vi = self._cache.slice(0, block.length);
    return self._cache = self._cache.slice(block.length), xor(block, Vi);
  };
}, function(mixin, canCreateDiscussions) {
  /**
   * @param {?} value
   * @return {undefined}
   */
  mixin.exports = function(value) {
    var t;
    var i = value.length;
    for (; i--;) {
      if (255 !== (t = value.readUInt8(i))) {
        t++;
        value.writeUInt8(t, i);
        break;
      }
      value.writeUInt8(0, i);
    }
  };
}, function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"aes-128-ecb":{"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},"aes-192-ecb":{"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},"aes-256-ecb":{"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},"aes-128-cbc":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes-192-cbc":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes-256-cbc":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes128":{"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},"aes192":{"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},"aes256":{"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},"aes-128-cfb":{"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},"aes-192-cfb":{"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},"aes-256-cfb":{"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},"aes-128-cfb8":{"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},"aes-192-cfb8":{"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},"aes-256-cfb8":{"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},"aes-128-cfb1":{"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},"aes-192-cfb1":{"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},"aes-256-cfb1":{"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},"aes-128-ofb":{"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},"aes-192-ofb":{"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},"aes-256-ofb":{"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},"aes-128-ctr":{"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},"aes-192-ctr":{"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},"aes-256-ctr":{"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},"aes-128-gcm":{"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},"aes-192-gcm":{"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},"aes-256-gcm":{"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"}}');
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @param {string} mode
   * @param {?} data
   * @param {string} decrypt
   * @return {undefined}
   */
  function StreamCipher(key, mode, data, decrypt) {
    Duplex.call(this);
    var words = Buffer.alloc(4, 0);
    this._cipher = new packets.AES(mode);
    var name = this._cipher.encryptBlock(words);
    this._ghash = new Node(name);
    data = function(options, t, img) {
      if (12 === t.length) {
        return options._finID = Buffer.concat([t, Buffer.from([0, 0, 0, 1])]), Buffer.concat([t, Buffer.from([0, 0, 0, 2])]);
      }
      var n = new Node(img);
      var size = t.length;
      /** @type {number} */
      var b = size % 16;
      n.update(t);
      if (b) {
        /** @type {number} */
        b = 16 - b;
        n.update(Buffer.alloc(b, 0));
      }
      n.update(Buffer.alloc(8, 0));
      /** @type {number} */
      var i = 8 * size;
      var data = Buffer.alloc(8);
      data.writeUIntBE(i, 0, 8);
      n.update(data);
      options._finID = n.state;
      var e = Buffer.from(options._finID);
      return g(e), e;
    }(this, data, name);
    this._prev = Buffer.from(data);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    /** @type {string} */
    this._decrypt = decrypt;
    /** @type {number} */
    this._alen = 0;
    /** @type {number} */
    this._len = 0;
    /** @type {string} */
    this._mode = key;
    /** @type {null} */
    this._authTag = null;
    /** @type {boolean} */
    this._called = false;
  }
  var packets = require(31);
  var Buffer = require(2).Buffer;
  var Duplex = require(10);
  var inherits = require(1);
  var Node = require(150);
  var xor = require(22);
  var g = require(82);
  inherits(StreamCipher, Duplex);
  /**
   * @param {!Array} chunk
   * @return {?}
   */
  StreamCipher.prototype._update = function(chunk) {
    if (!this._called && this._alen) {
      /** @type {number} */
      var out = 16 - this._alen % 16;
      if (out < 16) {
        out = Buffer.alloc(out, 0);
        this._ghash.update(out);
      }
    }
    /** @type {boolean} */
    this._called = true;
    var out = this._mode.encrypt(this, chunk);
    return this._decrypt ? this._ghash.update(chunk) : this._ghash.update(out), this._len += chunk.length, out;
  };
  /**
   * @return {undefined}
   */
  StreamCipher.prototype._final = function() {
    if (this._decrypt && !this._authTag) {
      throw new Error("Unsupported state or unable to authenticate data");
    }
    var tag = xor(this._ghash.final(8 * this._alen, 8 * this._len), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && function(a, b) {
      /** @type {number} */
      var rot = 0;
      if (a.length !== b.length) {
        rot++;
      }
      /** @type {number} */
      var cell_amount = Math.min(a.length, b.length);
      /** @type {number} */
      var i = 0;
      for (; i < cell_amount; ++i) {
        /** @type {number} */
        rot = rot + (a[i] ^ b[i]);
      }
      return rot;
    }(tag, this._authTag)) {
      throw new Error("Unsupported state or unable to authenticate data");
    }
    this._authTag = tag;
    this._cipher.scrub();
  };
  /**
   * @return {?}
   */
  StreamCipher.prototype.getAuthTag = function() {
    if (this._decrypt || !Buffer.isBuffer(this._authTag)) {
      throw new Error("Attempting to get auth tag in unsupported state");
    }
    return this._authTag;
  };
  /**
   * @param {!AudioNode} tag
   * @return {undefined}
   */
  StreamCipher.prototype.setAuthTag = function(tag) {
    if (!this._decrypt) {
      throw new Error("Attempting to set auth tag in unsupported state");
    }
    /** @type {!AudioNode} */
    this._authTag = tag;
  };
  /**
   * @param {!Array} buf
   * @return {undefined}
   */
  StreamCipher.prototype.setAAD = function(buf) {
    if (this._called) {
      throw new Error("Attempting to set AAD in unsupported state");
    }
    this._ghash.update(buf);
    this._alen += buf.length;
  };
  /** @type {function(string, string, ?, string): undefined} */
  module.exports = StreamCipher;
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @param {string} mode
   * @param {?} iv
   * @param {string} decrypt
   * @return {undefined}
   */
  function StreamCipher(key, mode, iv, decrypt) {
    Chart.call(this);
    this._cipher = new packets.AES(mode);
    this._prev = Buffer.from(iv);
    this._cache = Buffer.allocUnsafe(0);
    this._secCache = Buffer.allocUnsafe(0);
    /** @type {string} */
    this._decrypt = decrypt;
    /** @type {string} */
    this._mode = key;
  }
  var packets = require(31);
  var Buffer = require(2).Buffer;
  var Chart = require(10);
  require(1)(StreamCipher, Chart);
  /**
   * @param {!Object} chunk
   * @return {?}
   */
  StreamCipher.prototype._update = function(chunk) {
    return this._mode.encrypt(this, chunk, this._decrypt);
  };
  /**
   * @return {undefined}
   */
  StreamCipher.prototype._final = function() {
    this._cipher.scrub();
  };
  /** @type {function(string, string, ?, string): undefined} */
  module.exports = StreamCipher;
}, function(mixin, canCreateDiscussions, compose) {
  /**
   * @return {?}
   */
  function range() {
    if (null !== A) {
      return A;
    }
    /** @type {!Array} */
    var b = [];
    /** @type {number} */
    b[0] = 2;
    /** @type {number} */
    var j = 1;
    /** @type {number} */
    var val = 3;
    for (; val < 1048576; val = val + 2) {
      /** @type {number} */
      var temp = Math.ceil(Math.sqrt(val));
      /** @type {number} */
      var i = 0;
      for (; i < j && b[i] <= temp && val % b[i] !== 0; i++) {
      }
      if (!(j !== i && b[i] <= temp)) {
        /** @type {number} */
        b[j++] = val;
      }
    }
    return A = b, b;
  }
  /**
   * @param {!Object} p
   * @return {?}
   */
  function isString(p) {
    var primes = range();
    /** @type {number} */
    var i = 0;
    for (; i < primes.length; i++) {
      if (0 === p.modn(primes[i])) {
        return 0 === p.cmpn(primes[i]);
      }
    }
    return true;
  }
  /**
   * @param {string} p
   * @return {?}
   */
  function verify(p) {
    var montp = Array.mont(p);
    return 0 === c.toRed(montp).redPow(p.subn(1)).fromRed().cmpn(1);
  }
  /**
   * @param {!Object} value
   * @param {?} obj
   * @return {?}
   */
  function generateRandom(value, obj) {
    if (value < 16) {
      return new Array(2 === obj || 5 === obj ? [140, 123] : [140, 39]);
    }
    var out;
    var main;
    obj = new Array(obj);
    for (;;) {
      out = new Array(toDec(Math.ceil(value / 8)));
      for (; out.bitLength() > value;) {
        out.ishrn(1);
      }
      if (out.isEven() && out.iadd(b), out.testn(1) || out.iadd(c), obj.cmp(c)) {
        if (!obj.cmp(a)) {
          for (; out.mod(key).cmp(one);) {
            out.iadd(h);
          }
        }
      } else {
        for (; out.mod(n).cmp(nOne);) {
          out.iadd(h);
        }
      }
      if (isString(main = out.shrn(1)) && isString(out) && verify(main) && verify(out) && tmp.test(main) && tmp.test(out)) {
        return out;
      }
    }
  }
  var toDec = compose(16);
  /** @type {function(!Object, ?): ?} */
  mixin.exports = generateRandom;
  /** @type {function(!Object): ?} */
  generateRandom.simpleSieve = isString;
  /** @type {function(string): ?} */
  generateRandom.fermatTest = verify;
  var Array = compose(4);
  var n = new Array(24);
  var tmp = new (compose(88));
  var b = new Array(1);
  var c = new Array(2);
  var a = new Array(5);
  var key = (new Array(16), new Array(8), new Array(10));
  var one = new Array(3);
  var nOne = (new Array(7), new Array(11));
  var h = new Array(4);
  /** @type {null} */
  var A = (new Array(12), null);
}, function(mixin, canCreateDiscussions) {
  /**
   * @param {!Object} value
   * @return {?}
   */
  mixin.exports = function(value) {
    return value.webpackPolyfill || (value.deprecate = function() {
    }, value.paths = [], value.children || (value.children = []), Object.defineProperty(value, "loaded", {
      enumerable : true,
      get : function() {
        return value.l;
      }
    }), Object.defineProperty(value, "id", {
      enumerable : true,
      get : function() {
        return value.i;
      }
    }), value.webpackPolyfill = 1), value;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function f(key) {
    this.rand = key || new TagHourlyStat.Rand;
  }
  var BN = require(4);
  var TagHourlyStat = require(48);
  /** @type {function(string): undefined} */
  module.exports = f;
  /**
   * @param {string} key
   * @return {?}
   */
  f.create = function(key) {
    return new f(key);
  };
  /**
   * @param {!Object} q
   * @return {?}
   */
  f.prototype._randbelow = function(q) {
    var visRecords = q.bitLength();
    /** @type {number} */
    var result = Math.ceil(visRecords / 8);
    do {
      var r = new BN(this.rand.generate(result));
    } while (r.cmp(q) >= 0);
    return r;
  };
  /**
   * @param {!Object} s
   * @param {!Object} key
   * @return {?}
   */
  f.prototype._randrange = function(s, key) {
    var i = key.sub(s);
    return s.add(this._randbelow(i));
  };
  /**
   * @param {string} num
   * @param {number} response
   * @param {?} f
   * @return {?}
   */
  f.prototype.test = function(num, response, f) {
    var i = num.bitLength();
    var b = BN.mont(num);
    var r = (new BN(1)).toRed(b);
    if (!response) {
      /** @type {number} */
      response = Math.max(1, i / 48 | 0);
    }
    var base = num.subn(1);
    /** @type {number} */
    var j = 0;
    for (; !base.testn(j); j++) {
    }
    var k = num.shrn(j);
    var a = base.toRed(b);
    for (; response > 0; response--) {
      var c = this._randrange(new BN(2), base);
      if (f) {
        f(c);
      }
      var x = c.toRed(b).redPow(k);
      if (0 !== x.cmp(r) && 0 !== x.cmp(a)) {
        /** @type {number} */
        var i = 1;
        for (; i < j; i++) {
          if (0 === (x = x.redSqr()).cmp(r)) {
            return false;
          }
          if (0 === x.cmp(a)) {
            break;
          }
        }
        if (i === j) {
          return false;
        }
      }
    }
    return true;
  };
  /**
   * @param {undefined} q
   * @param {number} doScrolling
   * @return {?}
   */
  f.prototype.getDivisor = function(q, doScrolling) {
    var incDays = q.bitLength();
    var start = BN.mont(q);
    var r = (new BN(1)).toRed(start);
    if (!doScrolling) {
      /** @type {number} */
      doScrolling = Math.max(1, incDays / 48 | 0);
    }
    var y = q.subn(1);
    /** @type {number} */
    var i = 0;
    for (; !y.testn(i); i++) {
    }
    var e = q.shrn(i);
    var s = y.toRed(start);
    for (; doScrolling > 0; doScrolling--) {
      var b = this._randrange(new BN(2), y);
      var a = q.gcd(b);
      if (0 !== a.cmpn(1)) {
        return a;
      }
      var x = b.toRed(start).redPow(e);
      if (0 !== x.cmp(r) && 0 !== x.cmp(s)) {
        /** @type {number} */
        var n = 1;
        for (; n < i; n++) {
          if (0 === (x = x.redSqr()).cmp(r)) {
            return x.fromRed().subn(1).gcd(q);
          }
          if (0 === x.cmp(s)) {
            break;
          }
        }
        if (n === i) {
          return (x = x.redSqr()).fromRed().subn(1).gcd(q);
        }
      }
    }
    return false;
  };
}, function(canCreateDiscussions, psView, isSlidingUp) {
  /**
   * @param {string} errorText
   * @return {?}
   */
  function encode(errorText) {
    return 1 === errorText.length ? "0" + errorText : errorText;
  }
  /**
   * @param {!Array} num
   * @return {?}
   */
  function toHex(num) {
    /** @type {string} */
    var output = "";
    /** @type {number} */
    var offset = 0;
    for (; offset < num.length; offset++) {
      /** @type {string} */
      output = output + encode(num[offset].toString(16));
    }
    return output;
  }
  /** @type {!Object} */
  var self = psView;
  /**
   * @param {string} value
   * @param {string} length
   * @return {?}
   */
  self.toArray = function(value, length) {
    if (Array.isArray(value)) {
      return value.slice();
    }
    if (!value) {
      return [];
    }
    /** @type {!Array} */
    var array = [];
    if ("string" !== typeof value) {
      /** @type {number} */
      var j = 0;
      for (; j < value.length; j++) {
        /** @type {number} */
        array[j] = 0 | value[j];
      }
      return array;
    }
    if ("hex" === length) {
      if ((value = value.replace(/[^a-z0-9]+/gi, "")).length % 2 !== 0) {
        /** @type {string} */
        value = "0" + value;
      }
      /** @type {number} */
      j = 0;
      for (; j < value.length; j = j + 2) {
        array.push(parseInt(value[j] + value[j + 1], 16));
      }
    } else {
      /** @type {number} */
      j = 0;
      for (; j < value.length; j++) {
        /** @type {number} */
        var i = value.charCodeAt(j);
        /** @type {number} */
        var row = i >> 8;
        /** @type {number} */
        var a = 255 & i;
        if (row) {
          array.push(row, a);
        } else {
          array.push(a);
        }
      }
    }
    return array;
  };
  /** @type {function(string): ?} */
  self.zero2 = encode;
  /** @type {function(!Array): ?} */
  self.toHex = toHex;
  /**
   * @param {!Array} val
   * @param {string} object
   * @return {?}
   */
  self.encode = function(val, object) {
    return "hex" === object ? toHex(val) : val;
  };
}, function(canCreateDiscussions, valueVar, require) {
  /** @type {string} */
  var o = valueVar;
  o.base = require(33);
  o.short = require(161);
  o.mont = require(162);
  o.edwards = require(163);
}, function(isSlidingUp, module, saveNotifs) {
  /**
   * @param {?} t
   * @param {?} a
   * @param {number} b
   * @return {?}
   */
  function test(t, a, b) {
    return t & a ^ ~t & b;
  }
  /**
   * @param {number} a
   * @param {string} b
   * @param {number} c
   * @return {?}
   */
  function F(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }
  /**
   * @param {?} a
   * @param {?} b
   * @param {number} c
   * @return {?}
   */
  function md5_ff(a, b, c) {
    return a ^ b ^ c;
  }
  var S = saveNotifs(9).rotr32;
  /**
   * @param {number} number
   * @param {?} a
   * @param {?} b
   * @param {undefined} d
   * @return {?}
   */
  module.ft_1 = function(number, a, b, d) {
    return 0 === number ? test(a, b, d) : 1 === number || 3 === number ? md5_ff(a, b, d) : 2 === number ? F(a, b, d) : void 0;
  };
  /** @type {function(?, ?, number): ?} */
  module.ch32 = test;
  /** @type {function(number, string, number): ?} */
  module.maj32 = F;
  /** @type {function(?, ?, number): ?} */
  module.p32 = md5_ff;
  /**
   * @param {undefined} x
   * @return {?}
   */
  module.s0_256 = function(x) {
    return S(x, 2) ^ S(x, 13) ^ S(x, 22);
  };
  /**
   * @param {undefined} x
   * @return {?}
   */
  module.s1_256 = function(x) {
    return S(x, 6) ^ S(x, 11) ^ S(x, 25);
  };
  /**
   * @param {number} x
   * @return {?}
   */
  module.g0_256 = function(x) {
    return S(x, 7) ^ S(x, 18) ^ x >>> 3;
  };
  /**
   * @param {number} x
   * @return {?}
   */
  module.g1_256 = function(x) {
    return S(x, 17) ^ S(x, 19) ^ x >>> 10;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {?}
   */
  function Slider() {
    if (!(this instanceof Slider)) {
      return new Slider;
    }
    TileAnimation.call(this);
    /** @type {!Array} */
    this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
    /** @type {!Array} */
    this.k = k;
    /** @type {!Array} */
    this.W = new Array(64);
  }
  var _ = require(9);
  var TagHourlyStat = require(23);
  var obj = require(91);
  var flow = require(6);
  var assign = _.sum32;
  var f = _.sum32_4;
  var add = _.sum32_5;
  var getValue = obj.ch32;
  var handler = obj.maj32;
  var prop = obj.s0_256;
  var scale = obj.s1_256;
  var unpack = obj.g0_256;
  var $ = obj.g1_256;
  var TileAnimation = TagHourlyStat.BlockHash;
  /** @type {!Array} */
  var k = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 
  3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  _.inherits(Slider, TileAnimation);
  /** @type {function(): ?} */
  module.exports = Slider;
  /** @type {number} */
  Slider.blockSize = 512;
  /** @type {number} */
  Slider.outSize = 256;
  /** @type {number} */
  Slider.hmacStrength = 192;
  /** @type {number} */
  Slider.padLength = 64;
  /**
   * @param {!Object} data
   * @param {number} off
   * @return {undefined}
   */
  Slider.prototype._update = function(data, off) {
    var args = this.W;
    /** @type {number} */
    var i = 0;
    for (; i < 16; i++) {
      args[i] = data[off + i];
    }
    for (; i < args.length; i++) {
      args[i] = f($(args[i - 2]), args[i - 7], unpack(args[i - 15]), args[i - 16]);
    }
    var response = this.h[0];
    var context = this.h[1];
    var data = this.h[2];
    var options = this.h[3];
    var value = this.h[4];
    var b = this.h[5];
    var c = this.h[6];
    var a = this.h[7];
    flow(this.k.length === args.length);
    /** @type {number} */
    i = 0;
    for (; i < args.length; i++) {
      var obj = add(a, scale(value), getValue(value, b, c), this.k[i], args[i]);
      var result = assign(prop(response), handler(response, context, data));
      a = c;
      c = b;
      b = value;
      value = assign(options, obj);
      options = data;
      data = context;
      context = response;
      response = assign(obj, result);
    }
    this.h[0] = assign(this.h[0], response);
    this.h[1] = assign(this.h[1], context);
    this.h[2] = assign(this.h[2], data);
    this.h[3] = assign(this.h[3], options);
    this.h[4] = assign(this.h[4], value);
    this.h[5] = assign(this.h[5], b);
    this.h[6] = assign(this.h[6], c);
    this.h[7] = assign(this.h[7], a);
  };
  /**
   * @param {string} hex2
   * @return {?}
   */
  Slider.prototype._digest = function(hex2) {
    return "hex" === hex2 ? _.toHex32(this.h, "big") : _.split32(this.h, "big");
  };
}, function(module, canCreateDiscussions, $) {
  /**
   * @return {?}
   */
  function Slider() {
    if (!(this instanceof Slider)) {
      return new Slider;
    }
    base.call(this);
    /** @type {!Array} */
    this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209];
    /** @type {!Array} */
    this.k = k;
    /** @type {!Array} */
    this.W = new Array(160);
  }
  /**
   * @param {number} t
   * @param {?} result
   * @param {number} r
   * @param {?} controller
   * @param {number} e
   * @return {?}
   */
  function run(t, result, r, controller, e) {
    /** @type {number} */
    var value = t & r ^ ~t & e;
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {?} s
   * @param {number} e
   * @param {?} text
   * @param {number} f
   * @param {?} c
   * @param {number} g
   * @return {?}
   */
  function u(s, e, text, f, c, g) {
    /** @type {number} */
    var value = e & f ^ ~e & g;
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {number} a
   * @param {?} m
   * @param {number} b
   * @param {?} f
   * @param {number} c
   * @return {?}
   */
  function filter(a, m, b, f, c) {
    /** @type {number} */
    var value = a & b ^ a & c ^ b & c;
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {?} y2
   * @param {number} t
   * @param {?} host
   * @param {number} a
   * @param {?} m
   * @param {number} b
   * @return {?}
   */
  function insert(y2, t, host, a, m, b) {
    /** @type {number} */
    var value = t & a ^ t & b ^ a & b;
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} a
   * @param {undefined} al
   * @return {?}
   */
  function copy(a, al) {
    /** @type {number} */
    var value = cb(a, al, 28) ^ cb(al, a, 2) ^ cb(al, a, 7);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} a
   * @param {undefined} al
   * @return {?}
   */
  function parse(a, al) {
    /** @type {number} */
    var value = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} e
   * @param {undefined} el
   * @return {?}
   */
  function next(e, el) {
    /** @type {number} */
    var value = cb(e, el, 14) ^ cb(e, el, 18) ^ cb(el, e, 9);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} e
   * @param {undefined} el
   * @return {?}
   */
  function set(e, el) {
    /** @type {number} */
    var value = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} e
   * @param {undefined} el
   * @return {?}
   */
  function merge(e, el) {
    /** @type {number} */
    var value = cb(e, el, 1) ^ cb(e, el, 8) ^ log(e, el, 7);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} el
   * @param {undefined} e
   * @return {?}
   */
  function output(el, e) {
    /** @type {number} */
    var value = S(el, e, 1) ^ S(el, e, 8) ^ getAttr(el, e, 7);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} a
   * @param {undefined} al
   * @return {?}
   */
  function extend(a, al) {
    /** @type {number} */
    var value = cb(a, al, 19) ^ cb(al, a, 29) ^ log(a, al, 6);
    return value < 0 && (value = value + 4294967296), value;
  }
  /**
   * @param {undefined} a
   * @param {undefined} al
   * @return {?}
   */
  function g(a, al) {
    /** @type {number} */
    var value = S(a, al, 19) ^ S(al, a, 29) ^ getAttr(a, al, 6);
    return value < 0 && (value = value + 4294967296), value;
  }
  var self = $(9);
  var msg = $(23);
  var prec = $(6);
  var cb = self.rotr64_hi;
  var S = self.rotr64_lo;
  var log = self.shr64_hi;
  var getAttr = self.shr64_lo;
  var callback = self.sum64;
  var fn = self.sum64_hi;
  var format = self.sum64_lo;
  var f = self.sum64_4_hi;
  var func = self.sum64_4_lo;
  var get = self.sum64_5_hi;
  var debug = self.sum64_5_lo;
  var base = msg.BlockHash;
  /** @type {!Array} */
  var k = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 
  1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 
  3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 
  3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  self.inherits(Slider, base);
  /** @type {function(): ?} */
  module.exports = Slider;
  /** @type {number} */
  Slider.blockSize = 1024;
  /** @type {number} */
  Slider.outSize = 512;
  /** @type {number} */
  Slider.hmacStrength = 192;
  /** @type {number} */
  Slider.padLength = 128;
  /**
   * @param {!Object} array
   * @param {number} start
   * @return {undefined}
   */
  Slider.prototype._prepareBlock = function(array, start) {
    var a = this.W;
    /** @type {number} */
    var i = 0;
    for (; i < 32; i++) {
      a[i] = array[start + i];
    }
    for (; i < a.length; i = i + 2) {
      var o = extend(a[i - 4], a[i - 3]);
      var b = g(a[i - 4], a[i - 3]);
      var x = a[i - 14];
      var args = a[i - 13];
      var options = merge(a[i - 30], a[i - 29]);
      var A = output(a[i - 30], a[i - 29]);
      var key = a[i - 32];
      var C = a[i - 31];
      a[i] = f(o, b, x, args, options, A, key, C);
      a[i + 1] = func(o, b, x, args, options, A, key, C);
    }
  };
  /**
   * @param {!Object} data
   * @param {number} off
   * @return {undefined}
   */
  Slider.prototype._update = function(data, off) {
    this._prepareBlock(data, off);
    var urls = this.W;
    var value = this.h[0];
    var i = this.h[1];
    var name = this.h[2];
    var b = this.h[3];
    var p = this.h[4];
    var a = this.h[5];
    var h = this.h[6];
    var f = this.h[7];
    var d = this.h[8];
    var r = this.h[9];
    var e = this.h[10];
    var t = this.h[11];
    var content = this.h[12];
    var s = this.h[13];
    var child = this.h[14];
    var schema = this.h[15];
    prec(this.k.length === urls.length);
    /** @type {number} */
    var index = 0;
    for (; index < urls.length; index = index + 2) {
      var obj = child;
      var path = schema;
      var v = next(d, r);
      var c = set(d, r);
      var result = run(d, r, e, t, content);
      var m = u(d, r, e, t, content, s);
      var version = this.k[index];
      var options = this.k[index + 1];
      var data = urls[index];
      var temp = urls[index + 1];
      var x = get(obj, path, v, c, result, m, version, options, data, temp);
      var item = debug(obj, path, v, c, result, m, version, options, data, temp);
      obj = copy(value, i);
      path = parse(value, i);
      v = filter(value, i, name, b, p);
      c = insert(value, i, name, b, p, a);
      var ret = fn(obj, path, v, c);
      var id = format(obj, path, v, c);
      child = content;
      schema = s;
      content = e;
      s = t;
      e = d;
      t = r;
      d = fn(h, f, x, item);
      r = format(f, f, x, item);
      h = p;
      f = a;
      p = name;
      a = b;
      name = value;
      b = i;
      value = fn(x, item, ret, id);
      i = format(x, item, ret, id);
    }
    callback(this.h, 0, value, i);
    callback(this.h, 2, name, b);
    callback(this.h, 4, p, a);
    callback(this.h, 6, h, f);
    callback(this.h, 8, d, r);
    callback(this.h, 10, e, t);
    callback(this.h, 12, content, s);
    callback(this.h, 14, child, schema);
  };
  /**
   * @param {string} hex2
   * @return {?}
   */
  Slider.prototype._digest = function(hex2) {
    return "hex" === hex2 ? self.toHex32(this.h, "big") : self.split32(this.h, "big");
  };
}, function(canCreateDiscussions, exports, require) {
  /**
   * @param {string} base
   * @param {?} options
   * @return {undefined}
   */
  function DecoderBuffer(base, options) {
    Reporter.call(this, options);
    if (Buffer.isBuffer(base)) {
      /** @type {string} */
      this.base = base;
      /** @type {number} */
      this.offset = 0;
      this.length = base.length;
    } else {
      this.error("Input not Buffer");
    }
  }
  /**
   * @param {number} value
   * @param {!Object} reporter
   * @return {?}
   */
  function EncoderBuffer(value, reporter) {
    if (Array.isArray(value)) {
      /** @type {number} */
      this.length = 0;
      this.value = value.map(function(item) {
        return item instanceof EncoderBuffer || (item = new EncoderBuffer(item, reporter)), this.length += item.length, item;
      }, this);
    } else {
      if ("number" === typeof value) {
        if (!(0 <= value && value <= 255)) {
          return reporter.error("non-byte EncoderBuffer value");
        }
        /** @type {number} */
        this.value = value;
        /** @type {number} */
        this.length = 1;
      } else {
        if ("string" === typeof value) {
          /** @type {number} */
          this.value = value;
          this.length = Buffer.byteLength(value);
        } else {
          if (!Buffer.isBuffer(value)) {
            return reporter.error("Unsupported type: " + typeof value);
          }
          /** @type {number} */
          this.value = value;
          this.length = value.length;
        }
      }
    }
  }
  var inherits = require(1);
  var Reporter = require(25).Reporter;
  var Buffer = require(3).Buffer;
  inherits(DecoderBuffer, Reporter);
  /** @type {function(string, ?): undefined} */
  exports.DecoderBuffer = DecoderBuffer;
  /**
   * @return {?}
   */
  DecoderBuffer.prototype.save = function() {
    return {
      offset : this.offset,
      reporter : Reporter.prototype.save.call(this)
    };
  };
  /**
   * @param {!Object} data
   * @return {?}
   */
  DecoderBuffer.prototype.restore = function(data) {
    var res = new DecoderBuffer(this.base);
    return res.offset = data.offset, res.length = this.offset, this.offset = data.offset, Reporter.prototype.restore.call(this, data.reporter), res;
  };
  /**
   * @return {?}
   */
  DecoderBuffer.prototype.isEmpty = function() {
    return this.offset === this.length;
  };
  /**
   * @param {!Object} message
   * @return {?}
   */
  DecoderBuffer.prototype.readUInt8 = function(message) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, true) : this.error(message || "DecoderBuffer overrun");
  };
  /**
   * @param {?} bytes
   * @param {!Object} fail
   * @return {?}
   */
  DecoderBuffer.prototype.skip = function(bytes, fail) {
    if (!(this.offset + bytes <= this.length)) {
      return this.error(fail || "DecoderBuffer overrun");
    }
    var res = new DecoderBuffer(this.base);
    return res._reporterState = this._reporterState, res.offset = this.offset, res.length = this.offset + bytes, this.offset += bytes, res;
  };
  /**
   * @param {number} save
   * @return {?}
   */
  DecoderBuffer.prototype.raw = function(save) {
    return this.base.slice(save ? save.offset : this.offset, this.length);
  };
  /** @type {function(number, !Object): ?} */
  exports.EncoderBuffer = EncoderBuffer;
  /**
   * @param {!Object} data
   * @param {number} offset
   * @return {?}
   */
  EncoderBuffer.prototype.join = function(data, offset) {
    return data || (data = new Buffer(this.length)), offset || (offset = 0), 0 === this.length || (Array.isArray(this.value) ? this.value.forEach(function(part) {
      part.join(data, offset);
      offset = offset + part.length;
    }) : ("number" === typeof this.value ? data[offset] = this.value : "string" === typeof this.value ? data.write(this.value, offset) : Buffer.isBuffer(this.value) && this.value.copy(data, offset), offset = offset + this.length)), data;
  };
}, function(canCreateDiscussions, dojoQuery, getCollection) {
  var query = dojoQuery;
  /**
   * @param {!Object} query
   * @return {?}
   */
  query._reverse = function(query) {
    var kernel = {};
    return Object.keys(query).forEach(function(t) {
      if ((0 | t) == t) {
        /** @type {number} */
        t = t | 0;
      }
      var p = query[t];
      /** @type {string} */
      kernel[p] = t;
    }), kernel;
  };
  query.der = getCollection(183);
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} value
   * @return {undefined}
   */
  function DEREncoder(value) {
    /** @type {string} */
    this.enc = "der";
    this.name = value.name;
    /** @type {string} */
    this.entity = value;
    this.tree = new DERNode;
    this.tree._init(value.body);
  }
  /**
   * @param {?} parent
   * @return {undefined}
   */
  function DERNode(parent) {
    base.Node.call(this, "der", parent);
  }
  /**
   * @param {!Object} buf
   * @param {!Object} fail
   * @return {?}
   */
  function derDecodeTag(buf, fail) {
    var tag = buf.readUInt8(fail);
    if (buf.isError(tag)) {
      return tag;
    }
    var thisCls = der.tagClass[tag >> 6];
    /** @type {boolean} */
    var primitive = 0 === (32 & tag);
    if (31 === (31 & tag)) {
      var oct = tag;
      /** @type {number} */
      tag = 0;
      for (; 128 === (128 & oct);) {
        if (oct = buf.readUInt8(fail), buf.isError(oct)) {
          return oct;
        }
        /** @type {number} */
        tag = tag << 7;
        /** @type {number} */
        tag = tag | 127 & oct;
      }
    } else {
      /** @type {number} */
      tag = tag & 31;
    }
    return {
      cls : thisCls,
      primitive : primitive,
      tag : tag,
      tagStr : der.tag[tag]
    };
  }
  /**
   * @param {!Object} buf
   * @param {?} fail
   * @param {?} data
   * @return {?}
   */
  function derDecodeLen(buf, fail, data) {
    var len = buf.readUInt8(data);
    if (buf.isError(len)) {
      return len;
    }
    if (!fail && 128 === len) {
      return null;
    }
    if (0 === (128 & len)) {
      return len;
    }
    /** @type {number} */
    var i = 127 & len;
    if (i > 4) {
      return buf.error("length octect is too long");
    }
    /** @type {number} */
    len = 0;
    /** @type {number} */
    var nextCreation = 0;
    for (; nextCreation < i; nextCreation++) {
      /** @type {number} */
      len = len << 8;
      var j = buf.readUInt8(data);
      if (buf.isError(j)) {
        return j;
      }
      /** @type {number} */
      len = len | j;
    }
    return len;
  }
  var inherits = require(1);
  var asn1 = require(24);
  var base = asn1.base;
  var bn = asn1.bignum;
  var der = asn1.constants.der;
  /** @type {function(string): undefined} */
  module.exports = DEREncoder;
  /**
   * @param {string} data
   * @param {string} options
   * @return {?}
   */
  DEREncoder.prototype.decode = function(data, options) {
    return data instanceof base.DecoderBuffer || (data = new base.DecoderBuffer(data, options)), this.tree._decode(data, options);
  };
  inherits(DERNode, base.Node);
  /**
   * @param {!Object} buffer
   * @param {string} tag
   * @param {string} lutDescriptor
   * @return {?}
   */
  DERNode.prototype._peekTag = function(buffer, tag, lutDescriptor) {
    if (buffer.isEmpty()) {
      return false;
    }
    var data = buffer.save();
    var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
    return buffer.isError(decodedTag) ? decodedTag : (buffer.restore(data), decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || lutDescriptor);
  };
  /**
   * @param {!Object} buffer
   * @param {string} tag
   * @param {?} any
   * @return {?}
   */
  DERNode.prototype._decodeTag = function(buffer, tag, any) {
    var decodedTag = derDecodeTag(buffer, 'Failed to decode tag of "' + tag + '"');
    if (buffer.isError(decodedTag)) {
      return decodedTag;
    }
    var len = derDecodeLen(buffer, decodedTag.primitive, 'Failed to get length of "' + tag + '"');
    if (buffer.isError(len)) {
      return len;
    }
    if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
      return buffer.error('Failed to match tag: "' + tag + '"');
    }
    if (decodedTag.primitive || null !== len) {
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    }
    var state = buffer.save();
    var res = this._skipUntilEnd(buffer, 'Failed to skip indefinite length body: "' + this.tag + '"');
    return buffer.isError(res) ? res : (len = buffer.offset - state.offset, buffer.restore(state), buffer.skip(len, 'Failed to match body of: "' + tag + '"'));
  };
  /**
   * @param {!Object} buffer
   * @param {?} fail
   * @return {?}
   */
  DERNode.prototype._skipUntilEnd = function(buffer, fail) {
    for (;;) {
      var tag = derDecodeTag(buffer, fail);
      if (buffer.isError(tag)) {
        return tag;
      }
      var e;
      var len = derDecodeLen(buffer, tag.primitive, fail);
      if (buffer.isError(len)) {
        return len;
      }
      if (e = tag.primitive || null !== len ? buffer.skip(len) : this._skipUntilEnd(buffer, fail), buffer.isError(e)) {
        return e;
      }
      if ("end" === tag.tagStr) {
        break;
      }
    }
  };
  /**
   * @param {!Object} buf
   * @param {string} encoding
   * @param {!Function} decoder
   * @param {boolean} options
   * @return {?}
   */
  DERNode.prototype._decodeList = function(buf, encoding, decoder, options) {
    /** @type {!Array} */
    var eventPrototypes = [];
    for (; !buf.isEmpty();) {
      var res = this._peekTag(buf, "end");
      if (buf.isError(res)) {
        return res;
      }
      var a = decoder.decode(buf, "der", options);
      if (buf.isError(a) && res) {
        break;
      }
      eventPrototypes.push(a);
    }
    return eventPrototypes;
  };
  /**
   * @param {!Object} value
   * @param {string} modifier
   * @return {?}
   */
  DERNode.prototype._decodeStr = function(value, modifier) {
    if ("bitstr" === modifier) {
      var e = value.readUInt8();
      return value.isError(e) ? e : {
        unused : e,
        data : value.raw()
      };
    }
    if ("bmpstr" === modifier) {
      var buf = value.raw();
      if (buf.length % 2 === 1) {
        return value.error("Decoding of string type: bmpstr length mismatch");
      }
      /** @type {string} */
      var pix_color = "";
      /** @type {number} */
      var indexSize = 0;
      for (; indexSize < buf.length / 2; indexSize++) {
        /** @type {string} */
        pix_color = pix_color + String.fromCharCode(buf.readUInt16BE(2 * indexSize));
      }
      return pix_color;
    }
    if ("numstr" === modifier) {
      var str = value.raw().toString("ascii");
      return this._isNumstr(str) ? str : value.error("Decoding of string type: numstr unsupported characters");
    }
    if ("octstr" === modifier) {
      return value.raw();
    }
    if ("objDesc" === modifier) {
      return value.raw();
    }
    if ("printstr" === modifier) {
      var str = value.raw().toString("ascii");
      return this._isPrintstr(str) ? str : value.error("Decoding of string type: printstr unsupported characters");
    }
    return /str$/.test(modifier) ? value.raw().toString() : value.error("Decoding of string type: " + modifier + " unsupported");
  };
  /**
   * @param {!Object} data
   * @param {!Function} tags
   * @param {!Array} replace
   * @return {?}
   */
  DERNode.prototype._decodeObjid = function(data, tags, replace) {
    var togo;
    /** @type {!Array} */
    var value = [];
    /** @type {number} */
    var a = 0;
    for (; !data.isEmpty();) {
      var c = data.readUInt8();
      /** @type {number} */
      a = a << 7;
      /** @type {number} */
      a = a | 127 & c;
      if (0 === (128 & c)) {
        value.push(a);
        /** @type {number} */
        a = 0;
      }
    }
    if (128 & c) {
      value.push(a);
    }
    /** @type {number} */
    var intfName = value[0] / 40 | 0;
    /** @type {number} */
    var QUOTED2 = value[0] % 40;
    if (togo = replace ? value : [intfName, QUOTED2].concat(value.slice(1)), tags) {
      var region = tags[togo.join(" ")];
      if (void 0 === region) {
        region = tags[togo.join(".")];
      }
      if (void 0 !== region) {
        togo = region;
      }
    }
    return togo;
  };
  /**
   * @param {!Object} e
   * @param {string} islongclick
   * @return {?}
   */
  DERNode.prototype._decodeTime = function(e, islongclick) {
    var charListNotLatin = e.raw().toString();
    if ("gentime" === islongclick) {
      /** @type {number} */
      var year = 0 | charListNotLatin.slice(0, 4);
      /** @type {number} */
      var month = 0 | charListNotLatin.slice(4, 6);
      /** @type {number} */
      var date = 0 | charListNotLatin.slice(6, 8);
      /** @type {number} */
      var hh = 0 | charListNotLatin.slice(8, 10);
      /** @type {number} */
      var mm = 0 | charListNotLatin.slice(10, 12);
      /** @type {number} */
      var _ss = 0 | charListNotLatin.slice(12, 14);
    } else {
      if ("utctime" !== islongclick) {
        return e.error("Decoding " + islongclick + " time is not supported yet");
      }
      /** @type {number} */
      year = 0 | charListNotLatin.slice(0, 2);
      /** @type {number} */
      month = 0 | charListNotLatin.slice(2, 4);
      /** @type {number} */
      date = 0 | charListNotLatin.slice(4, 6);
      /** @type {number} */
      hh = 0 | charListNotLatin.slice(6, 8);
      /** @type {number} */
      mm = 0 | charListNotLatin.slice(8, 10);
      /** @type {number} */
      _ss = 0 | charListNotLatin.slice(10, 12);
      /** @type {number} */
      year = year < 70 ? 2E3 + year : 1900 + year;
    }
    return Date.UTC(year, month - 1, date, hh, mm, _ss, 0);
  };
  /**
   * @param {!Object} name
   * @return {?}
   */
  DERNode.prototype._decodeNull = function(name) {
    return null;
  };
  /**
   * @param {!Object} buf
   * @return {?}
   */
  DERNode.prototype._decodeBool = function(buf) {
    var value = buf.readUInt8();
    return buf.isError(value) ? value : 0 !== value;
  };
  /**
   * @param {!Object} headers
   * @param {?} n
   * @return {?}
   */
  DERNode.prototype._decodeInt = function(headers, n) {
    var s = headers.raw();
    var r = new bn(s);
    return n && (r = n[r.toString(10)] || r), r;
  };
  /**
   * @param {!Function} callback
   * @param {!Array} event
   * @return {?}
   */
  DERNode.prototype._use = function(callback, event) {
    return "function" === typeof callback && (callback = callback(event)), callback._getDecoder("der").tree;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} value
   * @return {undefined}
   */
  function DEREncoder(value) {
    /** @type {string} */
    this.enc = "der";
    this.name = value.name;
    /** @type {string} */
    this.entity = value;
    this.tree = new DERNode;
    this.tree._init(value.body);
  }
  /**
   * @param {?} parent
   * @return {undefined}
   */
  function DERNode(parent) {
    base.Node.call(this, "der", parent);
  }
  /**
   * @param {number} s
   * @return {?}
   */
  function serveStaticJs(s) {
    return s < 10 ? "0" + s : s;
  }
  var inherits = require(1);
  var Buffer = require(3).Buffer;
  var asn1 = require(24);
  var base = asn1.base;
  var der = asn1.constants.der;
  /** @type {function(string): undefined} */
  module.exports = DEREncoder;
  /**
   * @param {!Array} data
   * @param {string} options
   * @return {?}
   */
  DEREncoder.prototype.encode = function(data, options) {
    return this.tree._encode(data, options).join();
  };
  inherits(DERNode, base.Node);
  /**
   * @param {undefined} tag
   * @param {boolean} primitive
   * @param {string} cls
   * @param {!Object} content
   * @return {?}
   */
  DERNode.prototype._encodeComposite = function(tag, primitive, cls, content) {
    var header;
    var encodedTag = function(tag, opt_leftOrShape, cls, result) {
      var res;
      if ("seqof" === tag) {
        /** @type {string} */
        tag = "seq";
      } else {
        if ("setof" === tag) {
          /** @type {string} */
          tag = "set";
        }
      }
      if (der.tagByName.hasOwnProperty(tag)) {
        res = der.tagByName[tag];
      } else {
        if ("number" !== typeof tag || (0 | tag) !== tag) {
          return result.error("Unknown tag: " + tag);
        }
        /** @type {number} */
        res = tag;
      }
      if (res >= 31) {
        return result.error("Multi-octet tag encoding unsupported");
      }
      if (!opt_leftOrShape) {
        /** @type {number} */
        res = res | 32;
      }
      return res = res | der.tagClassByName[cls || "universal"] << 6;
    }(tag, primitive, cls, this.reporter);
    if (content.length < 128) {
      return (header = new Buffer(2))[0] = encodedTag, header[1] = content.length, this._createEncoderBuffer([header, content]);
    }
    /** @type {number} */
    var lenOctets = 1;
    var i = content.length;
    for (; i >= 256; i = i >> 8) {
      lenOctets++;
    }
    (header = new Buffer(2 + lenOctets))[0] = encodedTag;
    /** @type {number} */
    header[1] = 128 | lenOctets;
    /** @type {number} */
    i = 1 + lenOctets;
    var j = content.length;
    for (; j > 0; i--, j = j >> 8) {
      /** @type {number} */
      header[i] = 255 & j;
    }
    return this._createEncoderBuffer([header, content]);
  };
  /**
   * @param {?} str
   * @param {string} name
   * @return {?}
   */
  DERNode.prototype._encodeStr = function(str, name) {
    if ("bitstr" === name) {
      return this._createEncoderBuffer([0 | str.unused, str.data]);
    }
    if ("bmpstr" === name) {
      var buf = new Buffer(2 * str.length);
      /** @type {number} */
      var i = 0;
      for (; i < str.length; i++) {
        buf.writeUInt16BE(str.charCodeAt(i), 2 * i);
      }
      return this._createEncoderBuffer(buf);
    }
    return "numstr" === name ? this._isNumstr(str) ? this._createEncoderBuffer(str) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : "printstr" === name ? this._isPrintstr(str) ? this._createEncoderBuffer(str) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(name) || 
    "objDesc" === name ? this._createEncoderBuffer(str) : this.reporter.error("Encoding of string type: " + name + " unsupported");
  };
  /**
   * @param {string} m
   * @param {!Object} t
   * @param {!Object} isTangent
   * @return {?}
   */
  DERNode.prototype._encodeObjid = function(m, t, isTangent) {
    if ("string" === typeof m) {
      if (!t) {
        return this.reporter.error("string objid given, but no values map found");
      }
      if (!t.hasOwnProperty(m)) {
        return this.reporter.error("objid not found in values map");
      }
      m = t[m].split(/[\s\.]+/g);
      /** @type {number} */
      var i = 0;
      for (; i < m.length; i++) {
        m[i] |= 0;
      }
    } else {
      if (Array.isArray(m)) {
        m = m.slice();
        /** @type {number} */
        i = 0;
        for (; i < m.length; i++) {
          m[i] |= 0;
        }
      }
    }
    if (!Array.isArray(m)) {
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(m));
    }
    if (!isTangent) {
      if (m[1] >= 40) {
        return this.reporter.error("Second objid identifier OOB");
      }
      m.splice(0, 2, 40 * m[0] + m[1]);
    }
    /** @type {number} */
    var totalCodewords = 0;
    /** @type {number} */
    i = 0;
    for (; i < m.length; i++) {
      var value = m[i];
      totalCodewords++;
      for (; value >= 128; value = value >> 7) {
        totalCodewords++;
      }
    }
    var data = new Buffer(totalCodewords);
    /** @type {number} */
    var index = data.length - 1;
    /** @type {number} */
    i = m.length - 1;
    for (; i >= 0; i--) {
      value = m[i];
      /** @type {number} */
      data[index--] = 127 & value;
      for (; (value = value >> 7) > 0;) {
        /** @type {number} */
        data[index--] = 128 | 127 & value;
      }
    }
    return this._createEncoderBuffer(data);
  };
  /**
   * @param {string} val
   * @param {string} type
   * @return {?}
   */
  DERNode.prototype._encodeTime = function(val, type) {
    var str;
    /** @type {!Date} */
    var d = new Date(val);
    return "gentime" === type ? str = [serveStaticJs(d.getFullYear()), serveStaticJs(d.getUTCMonth() + 1), serveStaticJs(d.getUTCDate()), serveStaticJs(d.getUTCHours()), serveStaticJs(d.getUTCMinutes()), serveStaticJs(d.getUTCSeconds()), "Z"].join("") : "utctime" === type ? str = [serveStaticJs(d.getFullYear() % 100), serveStaticJs(d.getUTCMonth() + 1), serveStaticJs(d.getUTCDate()), serveStaticJs(d.getUTCHours()), serveStaticJs(d.getUTCMinutes()), serveStaticJs(d.getUTCSeconds()), "Z"].join("") : 
    this.reporter.error("Encoding " + type + " time is not supported yet"), this._encodeStr(str, "octstr");
  };
  /**
   * @return {?}
   */
  DERNode.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  };
  /**
   * @param {number} num
   * @param {!Array} values
   * @return {?}
   */
  DERNode.prototype._encodeInt = function(num, values) {
    if ("string" === typeof num) {
      if (!values) {
        return this.reporter.error("String int or enum given, but no values map");
      }
      if (!values.hasOwnProperty(num)) {
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
      }
      num = values[num];
    }
    if ("number" !== typeof num && !Buffer.isBuffer(num)) {
      var numArray = num.toArray();
      if (!num.sign && 128 & numArray[0]) {
        numArray.unshift(0);
      }
      num = new Buffer(numArray);
    }
    if (Buffer.isBuffer(num)) {
      var size = num.length;
      if (0 === num.length) {
        size++;
      }
      var out = new Buffer(size);
      return num.copy(out), 0 === num.length && (out[0] = 0), this._createEncoderBuffer(out);
    }
    if (num < 128) {
      return this._createEncoderBuffer(num);
    }
    if (num < 256) {
      return this._createEncoderBuffer([0, num]);
    }
    /** @type {number} */
    size = 1;
    /** @type {number} */
    var i = num;
    for (; i >= 256; i = i >> 8) {
      size++;
    }
    /** @type {number} */
    i = (out = new Array(size)).length - 1;
    for (; i >= 0; i--) {
      /** @type {number} */
      out[i] = 255 & num;
      /** @type {number} */
      num = num >> 8;
    }
    return 128 & out[0] && out.unshift(0), this._createEncoderBuffer(new Buffer(out));
  };
  /**
   * @param {boolean} value
   * @return {?}
   */
  DERNode.prototype._encodeBool = function(value) {
    return this._createEncoderBuffer(value ? 255 : 0);
  };
  /**
   * @param {!Function} callback
   * @param {!Array} event
   * @return {?}
   */
  DERNode.prototype._use = function(callback, event) {
    return "function" === typeof callback && (callback = callback(event)), callback._getEncoder("der").tree;
  };
  /**
   * @param {!Array} dataBuffer
   * @param {!Object} reporter
   * @param {!Array} parent
   * @return {?}
   */
  DERNode.prototype._skipDefault = function(dataBuffer, reporter, parent) {
    var i;
    var state = this._baseState;
    if (null === state.default) {
      return false;
    }
    var clipPaths = dataBuffer.join();
    if (void 0 === state.defaultBuffer && (state.defaultBuffer = this._encodeValue(state.default, reporter, parent).join()), clipPaths.length !== state.defaultBuffer.length) {
      return false;
    }
    /** @type {number} */
    i = 0;
    for (; i < clipPaths.length; i++) {
      if (clipPaths[i] !== state.defaultBuffer[i]) {
        return false;
      }
    }
    return true;
  };
}, function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"1.3.132.0.10":"secp256k1","1.3.132.0.33":"p224","1.2.840.10045.3.1.1":"p192","1.2.840.10045.3.1.7":"p256","1.3.132.0.34":"p384","1.3.132.0.35":"p521"}');
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @param {number} value
   * @return {?}
   */
  function encode(value) {
    var result = Buffer.allocUnsafe(4);
    return result.writeUInt32BE(value, 0), result;
  }
  var createHash = require(19);
  var Buffer = require(2).Buffer;
  /**
   * @param {!Object} key
   * @param {string} length
   * @return {?}
   */
  mixin.exports = function(key, length) {
    var value;
    var buffer = Buffer.alloc(0);
    /** @type {number} */
    var seed = 0;
    for (; buffer.length < length;) {
      value = encode(seed++);
      buffer = Buffer.concat([buffer, createHash("sha1").update(key).update(value).digest()]);
    }
    return buffer.slice(0, length);
  };
}, function(mixin, canCreateDiscussions) {
  /**
   * @param {string} key
   * @param {string} block
   * @return {?}
   */
  mixin.exports = function(key, block) {
    var l = key.length;
    /** @type {number} */
    var i = -1;
    for (; ++i < l;) {
      key[i] ^= block[i];
    }
    return key;
  };
}, function(mixin, canCreateDiscussions, require) {
  var BN = require(4);
  var Buffer = require(2).Buffer;
  /**
   * @param {string} key
   * @param {!Object} pub
   * @return {?}
   */
  mixin.exports = function(key, pub) {
    return Buffer.from(key.toRed(BN.mont(pub.modulus)).redPow(new BN(pub.publicExponent)).fromRed().toArray());
  };
}, function(canCreateDiscussions, config, moment) {
  (function(global) {
    /**
     * @return {?}
     */
    function ajax() {
      if (void 0 !== request) {
        return request;
      }
      if (global.XMLHttpRequest) {
        request = new global.XMLHttpRequest;
        try {
          request.open("GET", global.XDomainRequest ? "/" : "https://example.com");
        } catch (f) {
          /** @type {null} */
          request = null;
        }
      } else {
        /** @type {null} */
        request = null;
      }
      return request;
    }
    /**
     * @param {string} type
     * @return {?}
     */
    function supportsXhrResponseType(type) {
      var req = ajax();
      if (!req) {
        return false;
      }
      try {
        return req.responseType = type, req.responseType === type;
      } catch (f) {
      }
      return false;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    function isFunction(fn) {
      return "function" === typeof fn;
    }
    config.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream);
    config.writableStream = isFunction(global.WritableStream);
    config.abortController = isFunction(global.AbortController);
    /** @type {boolean} */
    config.blobConstructor = false;
    try {
      new Blob([new ArrayBuffer(1)]);
      /** @type {boolean} */
      config.blobConstructor = true;
    } catch (f) {
    }
    var request;
    /** @type {boolean} */
    var handler = "undefined" !== typeof global.ArrayBuffer;
    var computeHandler = handler && isFunction(global.ArrayBuffer.prototype.slice);
    config.arraybuffer = config.fetch || handler && supportsXhrResponseType("arraybuffer");
    config.msstream = !config.fetch && computeHandler && supportsXhrResponseType("ms-stream");
    config.mozchunkedarraybuffer = !config.fetch && handler && supportsXhrResponseType("moz-chunked-arraybuffer");
    config.overrideMimeType = config.fetch || !!ajax() && isFunction(ajax().overrideMimeType);
    config.vbArray = isFunction(global.VBArray);
    /** @type {null} */
    request = null;
  }).call(this, moment(5));
}, function(canCreateDiscussions, MockXMLHttpRequest, __webpack_require__) {
  (function($process, Buffer, window) {
    var options = __webpack_require__(102);
    var inherits = __webpack_require__(1);
    var stream = __webpack_require__(20);
    var FakeXMLHttpRequest = MockXMLHttpRequest.readyStates = {
      UNSENT : 0,
      OPENED : 1,
      HEADERS_RECEIVED : 2,
      LOADING : 3,
      DONE : 4
    };
    /** @type {function(!Object, !Object, string, ?): ?} */
    var FeaturedContents = MockXMLHttpRequest.IncomingMessage = function(data, response, socket, id) {
      var self = this;
      if (stream.Readable.call(self), self._mode = socket, self.headers = {}, self.rawHeaders = [], self.trailers = {}, self.rawTrailers = [], self.on("end", function() {
        $process.nextTick(function() {
          self.emit("close");
        });
      }), "fetch" === socket) {
        if (self._fetchResponse = response, self.url = response.url, self.statusCode = response.status, self.statusMessage = response.statusText, response.headers.forEach(function(e, t) {
          /** @type {(number|string)} */
          self.headers[t.toLowerCase()] = e;
          self.rawHeaders.push(t, e);
        }), options.writableStream) {
          /** @type {!WritableStream} */
          var stream = new WritableStream({
            write : function(data) {
              return new Promise(function(callback, errorCB) {
                if (self._destroyed) {
                  errorCB();
                } else {
                  if (self.push(new Buffer(data))) {
                    callback();
                  } else {
                    self._resumeFetch = callback;
                  }
                }
              });
            },
            close : function() {
              window.clearTimeout(id);
              if (!self._destroyed) {
                self.push(null);
              }
            },
            abort : function(o) {
              if (!self._destroyed) {
                self.emit("error", o);
              }
            }
          });
          try {
            return void response.body.pipeTo(stream).catch(function(e) {
              window.clearTimeout(id);
              if (!self._destroyed) {
                self.emit("error", e);
              }
            });
          } catch (p) {
          }
        }
        var CoreDriverHandler = response.body.getReader();
        !function next() {
          CoreDriverHandler.read().then(function(dataSet) {
            if (!self._destroyed) {
              if (dataSet.done) {
                return window.clearTimeout(id), void self.push(null);
              }
              self.push(new Buffer(dataSet.value));
              next();
            }
          }).catch(function(e) {
            window.clearTimeout(id);
            if (!self._destroyed) {
              self.emit("error", e);
            }
          });
        }();
      } else {
        if (self._xhr = data, self._pos = 0, self.url = data.responseURL, self.statusCode = data.status, self.statusMessage = data.statusText, data.getAllResponseHeaders().split(/\r?\n/).forEach(function(_testModuleName) {
          var tokens = _testModuleName.match(/^([^:]+):\s*(.*)/);
          if (tokens) {
            var name = tokens[1].toLowerCase();
            if ("set-cookie" === name) {
              if (void 0 === self.headers[name]) {
                /** @type {!Array} */
                self.headers[name] = [];
              }
              self.headers[name].push(tokens[2]);
            } else {
              if (void 0 !== self.headers[name]) {
                self.headers[name] += ", " + tokens[2];
              } else {
                self.headers[name] = tokens[2];
              }
            }
            self.rawHeaders.push(tokens[1], tokens[2]);
          }
        }), self._charset = "x-user-defined", !options.overrideMimeType) {
          var searcher_name = self.rawHeaders["mime-type"];
          if (searcher_name) {
            var nameTmpArr = searcher_name.match(/;\s*charset=([^;])(;|$)/);
            if (nameTmpArr) {
              self._charset = nameTmpArr[1].toLowerCase();
            }
          }
          if (!self._charset) {
            /** @type {string} */
            self._charset = "utf-8";
          }
        }
      }
    };
    inherits(FeaturedContents, stream.Readable);
    /**
     * @return {undefined}
     */
    FeaturedContents.prototype._read = function() {
      var _pushSVGIcons = this._resumeFetch;
      if (_pushSVGIcons) {
        /** @type {null} */
        this._resumeFetch = null;
        _pushSVGIcons();
      }
    };
    /**
     * @return {undefined}
     */
    FeaturedContents.prototype._onXHRProgress = function() {
      var self = this;
      var xhr = self._xhr;
      /** @type {null} */
      var data = null;
      switch(self._mode) {
        case "text:vbarray":
          if (xhr.readyState !== FakeXMLHttpRequest.DONE) {
            break;
          }
          try {
            data = (new window.VBArray(xhr.responseBody)).toArray();
          } catch (c) {
          }
          if (null !== data) {
            self.push(new Buffer(data));
            break;
          }
        case "text":
          try {
            data = xhr.responseText;
          } catch (c) {
            /** @type {string} */
            self._mode = "text:vbarray";
            break;
          }
          if (data.length > self._pos) {
            var value = data.substr(self._pos);
            if ("x-user-defined" === self._charset) {
              var a = new Buffer(value.length);
              /** @type {number} */
              var i = 0;
              for (; i < value.length; i++) {
                /** @type {number} */
                a[i] = 255 & value.charCodeAt(i);
              }
              self.push(a);
            } else {
              self.push(value, self._charset);
            }
            self._pos = data.length;
          }
          break;
        case "arraybuffer":
          if (xhr.readyState !== FakeXMLHttpRequest.DONE || !xhr.response) {
            break;
          }
          data = xhr.response;
          self.push(new Buffer(new Uint8Array(data)));
          break;
        case "moz-chunked-arraybuffer":
          if (data = xhr.response, xhr.readyState !== FakeXMLHttpRequest.LOADING || !data) {
            break;
          }
          self.push(new Buffer(new Uint8Array(data)));
          break;
        case "ms-stream":
          if (data = xhr.response, xhr.readyState !== FakeXMLHttpRequest.LOADING) {
            break;
          }
          var reader = new window.MSStreamReader;
          /**
           * @return {undefined}
           */
          reader.onprogress = function() {
            if (reader.result.byteLength > self._pos) {
              self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))));
              self._pos = reader.result.byteLength;
            }
          };
          /**
           * @return {undefined}
           */
          reader.onload = function() {
            self.push(null);
          };
          reader.readAsArrayBuffer(data);
      }
      if (self._xhr.readyState === FakeXMLHttpRequest.DONE && "ms-stream" !== self._mode) {
        self.push(null);
      }
    };
  }).call(this, __webpack_require__(8), __webpack_require__(3).Buffer, __webpack_require__(5));
}, function(mixin, canCreateDiscussions) {
  /**
   * @param {string} hostName
   * @return {?}
   */
  mixin.exports.isAnEarlyCloseHost = function(hostName) {
    return hostName && hostName.match(".*google(apis)?.com$");
  };
}, , , function(context, canCreateDiscussions, $) {
  /** @type {function(this:string, (RegExp|null|string), (!Function|null|string)): string} */
  var replace = String.prototype.replace;
  /** @type {!RegExp} */
  var reUnescape = /%20/g;
  var self = $(57);
  var key = {
    RFC1738 : "RFC1738",
    RFC3986 : "RFC3986"
  };
  context.exports = self.assign({
    default : key.RFC3986,
    formatters : {
      RFC1738 : function(value) {
        return replace.call(value, reUnescape, "+");
      },
      RFC3986 : function(value) {
        return String(value);
      }
    }
  }, key);
}, function(module, canCreateDiscussions, factory) {
  !function e() {
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) {
      0;
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (exceptions) {
        console.error(exceptions);
      }
    }
  }();
  module.exports = factory(112);
}, function(canCreateDiscussions, exports, saveNotifs) {
  exports.OAuth = saveNotifs(62).OAuth;
  exports.OAuthEcho = saveNotifs(62).OAuthEcho;
  exports.OAuth2 = saveNotifs(206).OAuth2;
}, , function(canCreateDiscussions, self, require) {
  /**
   * @param {number} id
   * @return {?}
   */
  function push(id) {
    /** @type {string} */
    var bibtex = "https://reactjs.org/docs/error-decoder.html?invariant=" + id;
    /** @type {number} */
    var i = 1;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      bibtex = bibtex + ("&args[]=" + encodeURIComponent(arguments[i]));
    }
    return "Minified React error #" + id + "; visit " + bibtex + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  /**
   * @param {!Object} props
   * @param {!Object} context
   * @param {?} updater
   * @return {undefined}
   */
  function ReactComponent(props, context, updater) {
    /** @type {!Object} */
    this.props = props;
    /** @type {!Object} */
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  /**
   * @return {undefined}
   */
  function ComponentDummy() {
  }
  /**
   * @param {!Object} obj
   * @param {!Object} context
   * @param {?} updater
   * @return {undefined}
   */
  function ReactPureComponent(obj, context, updater) {
    /** @type {!Object} */
    this.props = obj;
    /** @type {!Object} */
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  /**
   * @param {(!Function|string)} type
   * @param {!Object} data
   * @param {!Array} elem
   * @return {?}
   */
  function createElement(type, data, elem) {
    var i;
    var o = {};
    /** @type {null} */
    var a = null;
    /** @type {null} */
    var ref = null;
    if (null != data) {
      for (i in void 0 !== data.ref && (ref = data.ref), void 0 !== data.key && (a = "" + data.key), data) {
        if (has.call(data, i) && !RESERVED_PROPS.hasOwnProperty(i)) {
          o[i] = data[i];
        }
      }
    }
    /** @type {number} */
    var v = arguments.length - 2;
    if (1 === v) {
      /** @type {!Array} */
      o.children = elem;
    } else {
      if (1 < v) {
        /** @type {!Array} */
        var list = Array(v);
        /** @type {number} */
        var j = 0;
        for (; j < v; j++) {
          list[j] = arguments[j + 2];
        }
        /** @type {!Array} */
        o.children = list;
      }
    }
    if (type && type.defaultProps) {
      for (i in v = type.defaultProps) {
        if (void 0 === o[i]) {
          o[i] = v[i];
        }
      }
    }
    return {
      $$typeof : REACT_ELEMENT_TYPE,
      type : type,
      key : a,
      ref : ref,
      props : o,
      _owner : ReactCurrentOwner.current
    };
  }
  /**
   * @param {!Object} object
   * @return {?}
   */
  function keys(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  /**
   * @param {!Object} e
   * @param {string} g
   * @param {!Function} value
   * @param {!Object} path
   * @return {?}
   */
  function search(e, g, value, path) {
    if (pre_seek_l.length) {
      var that = pre_seek_l.pop();
      return that.result = e, that.keyPrefix = g, that.func = value, that.context = path, that.count = 0, that;
    }
    return {
      result : e,
      keyPrefix : g,
      func : value,
      context : path,
      count : 0
    };
  }
  /**
   * @param {!Object} p
   * @return {undefined}
   */
  function split(p) {
    /** @type {null} */
    p.result = null;
    /** @type {null} */
    p.keyPrefix = null;
    /** @type {null} */
    p.func = null;
    /** @type {null} */
    p.context = null;
    /** @type {number} */
    p.count = 0;
    if (10 > pre_seek_l.length) {
      pre_seek_l.push(p);
    }
  }
  /**
   * @param {string} string
   * @param {!Function} event
   * @param {!Object} model
   * @return {?}
   */
  function set(string, event, model) {
    return null == string ? 0 : function check(val, result, callback, args) {
      /** @type {string} */
      var type = typeof val;
      if (!("undefined" !== type && "boolean" !== type)) {
        /** @type {null} */
        val = null;
      }
      /** @type {boolean} */
      var name = false;
      if (null === val) {
        /** @type {boolean} */
        name = true;
      } else {
        switch(type) {
          case "string":
          case "number":
            /** @type {boolean} */
            name = true;
            break;
          case "object":
            switch(val.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case platform:
                /** @type {boolean} */
                name = true;
            }
        }
      }
      if (name) {
        return callback(args, val, "" === result ? "." + f(val, 0) : result), 1;
      }
      if (name = 0, result = "" === result ? "." : result + ":", Array.isArray(val)) {
        /** @type {number} */
        var i = 0;
        for (; i < val.length; i++) {
          /** @type {string} */
          var cb = result + f(type = val[i], i);
          name = name + check(type, cb, callback, args);
        }
      } else {
        if (null === val || "object" !== typeof val ? cb = null : cb = "function" === typeof(cb = templateWidgetName && val[templateWidgetName] || val["@@iterator"]) ? cb : null, "function" === typeof cb) {
          val = cb.call(val);
          /** @type {number} */
          i = 0;
          for (; !(type = val.next()).done;) {
            name = name + check(type = type.value, cb = result + f(type, i++), callback, args);
          }
        } else {
          if ("object" === type) {
            throw callback = "" + val, Error(push(31, "[object Object]" === callback ? "object with keys {" + Object.keys(val).join(", ") + "}" : callback, ""));
          }
        }
      }
      return name;
    }(string, "", event, model);
  }
  /**
   * @param {!Object} value
   * @param {number} name
   * @return {?}
   */
  function f(value, name) {
    return "object" === typeof value && null !== value && null != value.key ? function(b) {
      var subwikiListsCache = {
        "=" : "=0",
        ":" : "=2"
      };
      return "$" + ("" + b).replace(/[=:]/g, function(wikiId) {
        return subwikiListsCache[wikiId];
      });
    }(value.key) : name.toString(36);
  }
  /**
   * @param {!Object} control
   * @param {?} e
   * @return {undefined}
   */
  function _onChangeCheckbox(control, e) {
    control.func.call(control.context, e, control.count++);
  }
  /**
   * @param {!Object} options
   * @param {string} context
   * @param {string} index
   * @return {undefined}
   */
  function get(options, context, index) {
    var r = options.result;
    var prefix = options.keyPrefix;
    options = options.func.call(options.context, context, options.count++);
    if (Array.isArray(options)) {
      callback(options, r, index, function(letter) {
        return letter;
      });
    } else {
      if (null != options) {
        if (keys(options)) {
          options = function(options, awsKey) {
            return {
              $$typeof : REACT_ELEMENT_TYPE,
              type : options.type,
              key : awsKey,
              ref : options.ref,
              props : options.props,
              _owner : options._owner
            };
          }(options, prefix + (!options.key || context && context.key === options.key ? "" : ("" + options.key).replace(REGEX_ESCAPE_EXPR, "$&/") + "/") + index);
        }
        r.push(options);
      }
    }
  }
  /**
   * @param {string} o
   * @param {!Array} t
   * @param {string} i
   * @param {!Function} c
   * @param {!Object} d
   * @return {undefined}
   */
  function callback(o, t, i, c, d) {
    /** @type {string} */
    var b = "";
    if (null != i) {
      /** @type {string} */
      b = ("" + i).replace(REGEX_ESCAPE_EXPR, "$&/") + "/";
    }
    set(o, get, t = search(t, b, c, d));
    split(t);
  }
  /**
   * @return {?}
   */
  function sbeforeAll() {
    /** @type {null} */
    var source = level.current;
    if (null === source) {
      throw Error(push(321));
    }
    return source;
  }
  var assign = require(61);
  /** @type {(boolean|function(string): (?|undefined))} */
  var i = "function" === typeof Symbol && Symbol.for;
  var REACT_ELEMENT_TYPE = i ? Symbol.for("react.element") : 60103;
  var platform = i ? Symbol.for("react.portal") : 60106;
  var range = i ? Symbol.for("react.fragment") : 60107;
  var tl = i ? Symbol.for("react.strict_mode") : 60108;
  var right = i ? Symbol.for("react.profiler") : 60114;
  var xsign = i ? Symbol.for("react.provider") : 60109;
  var pre = i ? Symbol.for("react.context") : 60110;
  var yCoord = i ? Symbol.for("react.forward_ref") : 60112;
  var br = i ? Symbol.for("react.suspense") : 60113;
  var full_address = i ? Symbol.for("react.memo") : 60115;
  var prev = i ? Symbol.for("react.lazy") : 60116;
  var templateWidgetName = "function" === typeof Symbol && Symbol.iterator;
  var ReactNoopUpdateQueue = {
    isMounted : function() {
      return false;
    },
    enqueueForceUpdate : function() {
    },
    enqueueReplaceState : function() {
    },
    enqueueSetState : function() {
    }
  };
  var emptyObject = {};
  ReactComponent.prototype.isReactComponent = {};
  /**
   * @param {string} partialState
   * @param {string} callback
   * @return {undefined}
   */
  ReactComponent.prototype.setState = function(partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState) {
      throw Error(push(85));
    }
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  /**
   * @param {string} callback
   * @return {undefined}
   */
  ReactComponent.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  ComponentDummy.prototype = ReactComponent.prototype;
  var state = ReactPureComponent.prototype = new ComponentDummy;
  /** @type {function(!Object, !Object, ?): undefined} */
  state.constructor = ReactPureComponent;
  assign(state, ReactComponent.prototype);
  /** @type {boolean} */
  state.isPureReactComponent = true;
  var ReactCurrentOwner = {
    current : null
  };
  /** @type {function(this:Object, *): boolean} */
  var has = Object.prototype.hasOwnProperty;
  var RESERVED_PROPS = {
    key : true,
    ref : true,
    __self : true,
    __source : true
  };
  /** @type {!RegExp} */
  var REGEX_ESCAPE_EXPR = /\/+/g;
  /** @type {!Array} */
  var pre_seek_l = [];
  var level = {
    current : null
  };
  var e = {
    ReactCurrentDispatcher : level,
    ReactCurrentBatchConfig : {
      suspense : null
    },
    ReactCurrentOwner : ReactCurrentOwner,
    IsSomeRendererActing : {
      current : false
    },
    assign : assign
  };
  self.Children = {
    map : function(obj, type, left) {
      if (null == obj) {
        return obj;
      }
      /** @type {!Array} */
      var value = [];
      return callback(obj, value, null, type, left), value;
    },
    forEach : function(obj, value, options) {
      if (null == obj) {
        return obj;
      }
      set(obj, _onChangeCheckbox, value = search(null, null, value, options));
      split(value);
    },
    count : function(key) {
      return set(key, function() {
        return null;
      }, null);
    },
    toArray : function(key) {
      /** @type {!Array} */
      var value = [];
      return callback(key, value, null, function(i) {
        return i;
      }), value;
    },
    only : function(obj) {
      if (!keys(obj)) {
        throw Error(push(143));
      }
      return obj;
    }
  };
  /** @type {function(!Object, !Object, ?): undefined} */
  self.Component = ReactComponent;
  self.Fragment = range;
  self.Profiler = right;
  /** @type {function(!Object, !Object, ?): undefined} */
  self.PureComponent = ReactPureComponent;
  self.StrictMode = tl;
  self.Suspense = br;
  self.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = e;
  /**
   * @param {!Object} element
   * @param {!Object} props
   * @param {!Array} children
   * @return {?}
   */
  self.cloneElement = function(element, props, children) {
    if (null === element || void 0 === element) {
      throw Error(push(267, element));
    }
    var data = assign({}, element.props);
    var a = element.key;
    var ref = element.ref;
    var owner = element._owner;
    if (null != props) {
      if (void 0 !== props.ref && (ref = props.ref, owner = ReactCurrentOwner.current), void 0 !== props.key && (a = "" + props.key), element.type && element.type.defaultProps) {
        var values = element.type.defaultProps;
      }
      for (index in props) {
        if (has.call(props, index) && !RESERVED_PROPS.hasOwnProperty(index)) {
          data[index] = void 0 === props[index] && void 0 !== values ? values[index] : props[index];
        }
      }
    }
    /** @type {number} */
    var index = arguments.length - 2;
    if (1 === index) {
      /** @type {!Array} */
      data.children = children;
    } else {
      if (1 < index) {
        /** @type {!Array} */
        values = Array(index);
        /** @type {number} */
        var i = 0;
        for (; i < index; i++) {
          values[i] = arguments[i + 2];
        }
        /** @type {!Array} */
        data.children = values;
      }
    }
    return {
      $$typeof : REACT_ELEMENT_TYPE,
      type : element.type,
      key : a,
      ref : ref,
      props : data,
      _owner : owner
    };
  };
  /**
   * @param {!Object} name
   * @param {!Array} Context
   * @return {?}
   */
  self.createContext = function(name, Context) {
    return void 0 === Context && (Context = null), (name = {
      $$typeof : pre,
      _calculateChangedBits : Context,
      _currentValue : name,
      _currentValue2 : name,
      _threadCount : 0,
      Provider : null,
      Consumer : null
    }).Provider = {
      $$typeof : xsign,
      _context : name
    }, name.Consumer = name;
  };
  /** @type {function((!Function|string), !Object, !Array): ?} */
  self.createElement = createElement;
  /**
   * @param {!Object} a
   * @return {?}
   */
  self.createFactory = function(a) {
    var t = createElement.bind(null, a);
    return t.type = a, t;
  };
  /**
   * @return {?}
   */
  self.createRef = function() {
    return {
      current : null
    };
  };
  /**
   * @param {boolean} forwardRefFn
   * @return {?}
   */
  self.forwardRef = function(forwardRefFn) {
    return {
      $$typeof : yCoord,
      render : forwardRefFn
    };
  };
  /** @type {function(!Object): ?} */
  self.isValidElement = keys;
  /**
   * @param {!Function} ctxt_alloc_param
   * @return {?}
   */
  self.lazy = function(ctxt_alloc_param) {
    return {
      $$typeof : prev,
      _ctor : ctxt_alloc_param,
      _status : -1,
      _result : null
    };
  };
  /**
   * @param {!Object} klass
   * @param {?} key
   * @return {?}
   */
  self.memo = function(klass, key) {
    return {
      $$typeof : full_address,
      type : klass,
      compare : void 0 === key ? null : key
    };
  };
  /**
   * @param {!Function} callback
   * @param {!Array} index
   * @return {?}
   */
  self.useCallback = function(callback, index) {
    return sbeforeAll().useCallback(callback, index);
  };
  /**
   * @param {!Function} context
   * @param {!Array} start
   * @return {?}
   */
  self.useContext = function(context, start) {
    return sbeforeAll().useContext(context, start);
  };
  /**
   * @return {undefined}
   */
  self.useDebugValue = function() {
  };
  /**
   * @param {!Function} object
   * @param {!Array} start
   * @return {?}
   */
  self.useEffect = function(object, start) {
    return sbeforeAll().useEffect(object, start);
  };
  /**
   * @param {!Function} object
   * @param {!Array} start
   * @param {?} fn
   * @return {?}
   */
  self.useImperativeHandle = function(object, start, fn) {
    return sbeforeAll().useImperativeHandle(object, start, fn);
  };
  /**
   * @param {!Function} object
   * @param {!Array} start
   * @return {?}
   */
  self.useLayoutEffect = function(object, start) {
    return sbeforeAll().useLayoutEffect(object, start);
  };
  /**
   * @param {!Function} object
   * @param {!Array} start
   * @return {?}
   */
  self.useMemo = function(object, start) {
    return sbeforeAll().useMemo(object, start);
  };
  /**
   * @param {!Function} object
   * @param {!Array} start
   * @param {?} fn
   * @return {?}
   */
  self.useReducer = function(object, start, fn) {
    return sbeforeAll().useReducer(object, start, fn);
  };
  /**
   * @param {!Function} object
   * @return {?}
   */
  self.useRef = function(object) {
    return sbeforeAll().useRef(object);
  };
  /**
   * @param {!Function} object
   * @return {?}
   */
  self.useState = function(object) {
    return sbeforeAll().useState(object);
  };
  /** @type {string} */
  self.version = "16.13.0";
}, function(canCreateDiscussions, exports, __webpack_require__) {
  /**
   * @param {number} listener
   * @return {?}
   */
  function call(listener) {
    /** @type {string} */
    var msg = "https://reactjs.org/docs/error-decoder.html?invariant=" + listener;
    /** @type {number} */
    var i = 1;
    for (; i < arguments.length; i++) {
      /** @type {string} */
      msg = msg + ("&args[]=" + encodeURIComponent(arguments[i]));
    }
    return "Minified React error #" + listener + "; visit " + msg + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  /**
   * @param {?} url
   * @param {!Function} f
   * @param {string} h
   * @param {?} format
   * @param {?} scale
   * @param {?} color
   * @param {?} expected
   * @param {?} name
   * @param {?} components
   * @return {undefined}
   */
  function path(url, f, h, format, scale, color, expected, name, components) {
    /** @type {!Array<?>} */
    var argsArray = Array.prototype.slice.call(arguments, 3);
    try {
      f.apply(h, argsArray);
    } catch (xhr) {
      this.onError(xhr);
    }
  }
  /**
   * @param {?} user
   * @param {?} payment
   * @param {?} value
   * @param {?} q
   * @param {?} a
   * @param {?} s
   * @param {?} o
   * @param {?} attr
   * @param {?} txt
   * @return {undefined}
   */
  function h(user, payment, value, q, a, s, o, attr, txt) {
    /** @type {boolean} */
    res = false;
    /** @type {null} */
    active = null;
    path.apply(date, arguments);
  }
  /**
   * @param {!Object} event
   * @param {?} listener
   * @param {?} domID
   * @return {undefined}
   */
  function executeDispatch(event, listener, domID) {
    var type = event.type || "unknown-event";
    event.currentTarget = warning(domID);
    (function(deltaType, listenerInfo, partKeys, type, i, canCreateDiscussions, s, isSlidingUp, p) {
      if (h.apply(this, arguments), res) {
        if (!res) {
          throw Error(call(198));
        }
        var status = active;
        /** @type {boolean} */
        res = false;
        /** @type {null} */
        active = null;
        if (!$b) {
          /** @type {boolean} */
          $b = true;
          location = status;
        }
      }
    })(type, listener, void 0, event);
    /** @type {null} */
    event.currentTarget = null;
  }
  /**
   * @param {!Object} obj
   * @return {?}
   */
  function isPlainObject(obj) {
    return null === obj || "object" !== typeof obj ? null : "function" === typeof(obj = special && obj[special] || obj["@@iterator"]) ? obj : null;
  }
  /**
   * @param {!Object} o
   * @return {?}
   */
  function each(o) {
    if (null == o) {
      return null;
    }
    if ("function" === typeof o) {
      return o.displayName || o.name || null;
    }
    if ("string" === typeof o) {
      return o;
    }
    switch(o) {
      case string:
        return "Fragment";
      case array:
        return "Portal";
      case type:
        return "Profiler";
      case binary:
        return "StrictMode";
      case NODE_RULE_VALUE:
        return "Suspense";
      case tempMatch:
        return "SuspenseList";
    }
    if ("object" === typeof o) {
      switch(o.$$typeof) {
        case xmlstring:
          return "Context.Consumer";
        case box:
          return "Context.Provider";
        case column:
          var c = o.render;
          return c = c.displayName || c.name || "", o.displayName || ("" !== c ? "ForwardRef(" + c + ")" : "ForwardRef");
        case years:
          return each(o.type);
        case getScriptLexicalStructure:
          return each(o.render);
        case MUTATE_INSERT:
          if (o = 1 === o._status ? o._result : null) {
            return each(o);
          }
      }
    }
    return null;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function bind(node) {
    /** @type {string} */
    var results = "";
    do {
      e: {
        switch(node.tag) {
          case 3:
          case 4:
          case 6:
          case 7:
          case 10:
          case 9:
            /** @type {string} */
            var result = "";
            break e;
          default:
            var value = node._debugOwner;
            var source = node._debugSource;
            var name = each(node.type);
            /** @type {null} */
            result = null;
            if (value) {
              result = each(value.type);
            }
            value = name;
            /** @type {string} */
            name = "";
            if (source) {
              /** @type {string} */
              name = " (at " + source.fileName.replace(inputRegExp, "") + ":" + source.lineNumber + ")";
            } else {
              if (result) {
                /** @type {string} */
                name = " (created by " + result + ")";
              }
            }
            /** @type {string} */
            result = "\n    in " + (value || "Unknown") + name;
        }
      }
      /** @type {string} */
      results = results + result;
      node = node.return;
    } while (node);
    return results;
  }
  /**
   * @return {undefined}
   */
  function publishEventForPlugin() {
    if (exact_keys) {
      var key;
      for (key in state) {
        var self = state[key];
        /** @type {number} */
        var i = exact_keys.indexOf(key);
        if (!(-1 < i)) {
          throw Error(call(96, key));
        }
        if (!rels[i]) {
          if (!self.extractEvents) {
            throw Error(call(97, key));
          }
          var eventType;
          for (eventType in rels[i] = self, i = self.eventTypes) {
            var phaseName = void 0;
            var dispatchConfig = i[eventType];
            var PluginModule = self;
            /** @type {string} */
            var eventName = eventType;
            if (lstnrs.hasOwnProperty(eventName)) {
              throw Error(call(99, eventName));
            }
            lstnrs[eventName] = dispatchConfig;
            var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
            if (phasedRegistrationNames) {
              for (phaseName in phasedRegistrationNames) {
                if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
                  publishRegistrationName(phasedRegistrationNames[phaseName], PluginModule, eventName);
                }
              }
              /** @type {boolean} */
              phaseName = true;
            } else {
              if (dispatchConfig.registrationName) {
                publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
                /** @type {boolean} */
                phaseName = true;
              } else {
                /** @type {boolean} */
                phaseName = false;
              }
            }
            if (!phaseName) {
              throw Error(call(98, eventType, key));
            }
          }
        }
      }
    }
  }
  /**
   * @param {?} registrationName
   * @param {!Object} PluginModule
   * @param {string} eventName
   * @return {undefined}
   */
  function publishRegistrationName(registrationName, PluginModule, eventName) {
    if (dependencies[registrationName]) {
      throw Error(call(100, registrationName));
    }
    /** @type {!Object} */
    dependencies[registrationName] = PluginModule;
    props[registrationName] = PluginModule.eventTypes[eventName].dependencies;
  }
  /**
   * @param {(Object|string)} object
   * @return {undefined}
   */
  function every(object) {
    var name;
    /** @type {boolean} */
    var r = false;
    for (name in object) {
      if (object.hasOwnProperty(name)) {
        var value = object[name];
        if (!state.hasOwnProperty(name) || state[name] !== value) {
          if (state[name]) {
            throw Error(call(102, name));
          }
          state[name] = value;
          /** @type {boolean} */
          r = true;
        }
      }
    }
    if (r) {
      publishEventForPlugin();
    }
  }
  /**
   * @param {!Object} node
   * @return {undefined}
   */
  function build(node) {
    if (node = markNodeAsRequired(node)) {
      if ("function" !== typeof callback) {
        throw Error(call(280));
      }
      var p = node.stateNode;
      if (p) {
        p = parent(p);
        callback(node.stateNode, node.type, p);
      }
    }
  }
  /**
   * @param {string} element
   * @return {undefined}
   */
  function closeTag(element) {
    if (localCanvas) {
      if (images) {
        images.push(element);
      } else {
        /** @type {!Array} */
        images = [element];
      }
    } else {
      /** @type {string} */
      localCanvas = element;
    }
  }
  /**
   * @return {undefined}
   */
  function load_random() {
    if (localCanvas) {
      var i = localCanvas;
      var asts = images;
      if (images = localCanvas = null, build(i), asts) {
        /** @type {number} */
        i = 0;
        for (; i < asts.length; i++) {
          build(asts[i]);
        }
      }
    }
  }
  /**
   * @param {!Function} callback
   * @param {!Object} event
   * @return {?}
   */
  function command(callback, event) {
    return callback(event);
  }
  /**
   * @param {!Function} callback
   * @param {?} i
   * @param {?} dest
   * @param {?} name
   * @param {?} value
   * @return {?}
   */
  function writer(callback, i, dest, name, value) {
    return callback(i, dest, name, value);
  }
  /**
   * @return {undefined}
   */
  function getData() {
  }
  /**
   * @return {undefined}
   */
  function onload() {
    if (!(null === localCanvas && null === images)) {
      getData();
      load_random();
    }
  }
  /**
   * @param {!Function} callback
   * @param {!Object} error
   * @param {?} options
   * @return {?}
   */
  function respond(callback, error, options) {
    if (ae) {
      return callback(error, options);
    }
    /** @type {boolean} */
    ae = true;
    try {
      return cmd(callback, error, options);
    } finally {
      /** @type {boolean} */
      ae = false;
      onload();
    }
  }
  /**
   * @param {string} prop
   * @param {number} type
   * @param {?} event
   * @param {string} screen
   * @param {string} connection
   * @param {?} accessPointObj
   * @return {undefined}
   */
  function ProjectionPlan(prop, type, event, screen, connection, accessPointObj) {
    /** @type {boolean} */
    this.acceptsBooleans = 2 === type || 3 === type || 4 === type;
    /** @type {string} */
    this.attributeName = screen;
    /** @type {string} */
    this.attributeNamespace = connection;
    this.mustUseProperty = event;
    /** @type {string} */
    this.propertyName = prop;
    /** @type {number} */
    this.type = type;
    this.sanitizeURL = accessPointObj;
  }
  /**
   * @param {!Object} options
   * @return {?}
   */
  function base(options) {
    return options[1].toUpperCase();
  }
  /**
   * @param {!Object} node
   * @param {string} name
   * @param {?} value
   * @param {string} key
   * @return {undefined}
   */
  function handler(node, name, value, key) {
    var item = args.hasOwnProperty(name) ? args[name] : null;
    if (!(null !== item ? 0 === item.type : !key && (2 < name.length && ("o" === name[0] || "O" === name[0]) && ("n" === name[1] || "N" === name[1])))) {
      if (function(aMetaName, val, r, element) {
        if (null === val || "undefined" === typeof val || function(s, val, min, suppressDisabledCheck) {
          if (null !== min && 0 === min.type) {
            return false;
          }
          switch(typeof val) {
            case "function":
            case "symbol":
              return true;
            case "boolean":
              return !suppressDisabledCheck && (null !== min ? !min.acceptsBooleans : "data-" !== (s = s.toLowerCase().slice(0, 5)) && "aria-" !== s);
            default:
              return false;
          }
        }(aMetaName, val, r, element)) {
          return true;
        }
        if (element) {
          return false;
        }
        if (null !== r) {
          switch(r.type) {
            case 3:
              return !val;
            case 4:
              return false === val;
            case 5:
              return isNaN(val);
            case 6:
              return isNaN(val) || 1 > val;
          }
        }
        return false;
      }(name, value, item, key)) {
        /** @type {null} */
        value = null;
      }
      if (key || null === item) {
        if (function(key) {
          return !!hasOwnProperty.call(formattedConfig, key) || !hasOwnProperty.call(eddy, key) && (VALID_IDENTIFIER_EXPR.test(key) ? formattedConfig[key] = true : (eddy[key] = true, false));
        }(name)) {
          if (null === value) {
            node.removeAttribute(name);
          } else {
            node.setAttribute(name, "" + value);
          }
        }
      } else {
        if (item.mustUseProperty) {
          node[item.propertyName] = null === value ? 3 !== item.type && "" : value;
        } else {
          name = item.attributeName;
          key = item.attributeNamespace;
          if (null === value) {
            node.removeAttribute(name);
          } else {
            /** @type {string} */
            value = 3 === (item = item.type) || 4 === item && true === value ? "" : "" + value;
            if (key) {
              node.setAttributeNS(key, name, value);
            } else {
              node.setAttribute(name, value);
            }
          }
        }
      }
    }
  }
  /**
   * @param {string} value
   * @return {?}
   */
  function stringify(value) {
    switch(typeof value) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return value;
      default:
        return "";
    }
  }
  /**
   * @param {string} element
   * @return {?}
   */
  function isCheckbox(element) {
    var type = element.type;
    return (element = element.nodeName) && "input" === element.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  /**
   * @param {boolean} obj
   * @return {undefined}
   */
  function Class(obj) {
    if (!obj._valueTracker) {
      obj._valueTracker = function(d) {
        /** @type {string} */
        var i = isCheckbox(d) ? "checked" : "value";
        /** @type {(ObjectPropertyDescriptor<?>|undefined)} */
        var descriptor = Object.getOwnPropertyDescriptor(d.constructor.prototype, i);
        var ret = "" + d[i];
        if (!d.hasOwnProperty(i) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var retriever = descriptor.get;
          var previousSet = descriptor.set;
          return Object.defineProperty(d, i, {
            configurable : true,
            get : function() {
              return retriever.call(this);
            },
            set : function(value) {
              /** @type {string} */
              ret = "" + value;
              previousSet.call(this, value);
            }
          }), Object.defineProperty(d, i, {
            enumerable : descriptor.enumerable
          }), {
            getValue : function() {
              return ret;
            },
            setValue : function(paramName) {
              /** @type {string} */
              ret = "" + paramName;
            },
            stopTracking : function() {
              /** @type {null} */
              d._valueTracker = null;
              delete d[i];
            }
          };
        }
      }(obj);
    }
  }
  /**
   * @param {!Object} el
   * @return {?}
   */
  function getValue(el) {
    if (!el) {
      return false;
    }
    var w = el._valueTracker;
    if (!w) {
      return true;
    }
    var head = w.getValue();
    /** @type {string} */
    var p = "";
    return el && (p = isCheckbox(el) ? el.checked ? "true" : "false" : el.value), (el = p) !== head && (w.setValue(el), true);
  }
  /**
   * @param {!Object} node
   * @param {!Object} obj
   * @return {?}
   */
  function convert(node, obj) {
    var value = obj.checked;
    return assign({}, obj, {
      defaultChecked : void 0,
      defaultValue : void 0,
      value : void 0,
      checked : null != value ? value : node._wrapperState.initialChecked
    });
  }
  /**
   * @param {!Object} inst
   * @param {!Object} elem
   * @return {undefined}
   */
  function _handleChange(inst, elem) {
    var val = null == elem.defaultValue ? "" : elem.defaultValue;
    var n = null != elem.checked ? elem.checked : elem.defaultChecked;
    val = stringify(null != elem.value ? elem.value : val);
    inst._wrapperState = {
      initialChecked : n,
      initialValue : val,
      controlled : "checkbox" === elem.type || "radio" === elem.type ? null != elem.checked : null != elem.value
    };
  }
  /**
   * @param {!Object} node
   * @param {!Object} value
   * @return {undefined}
   */
  function setAttribute(node, value) {
    if (null != (value = value.checked)) {
      handler(node, "checked", value, false);
    }
  }
  /**
   * @param {!Object} node
   * @param {!Object} item
   * @return {?}
   */
  function check(node, item) {
    setAttribute(node, item);
    var value = stringify(item.value);
    var type = item.type;
    if (null != value) {
      if ("number" === type) {
        if (0 === value && "" === node.value || node.value != value) {
          /** @type {string} */
          node.value = "" + value;
        }
      } else {
        if (node.value !== "" + value) {
          /** @type {string} */
          node.value = "" + value;
        }
      }
    } else {
      if ("submit" === type || "reset" === type) {
        return void node.removeAttribute("value");
      }
    }
    if (item.hasOwnProperty("value")) {
      validator(node, item.type, value);
    } else {
      if (item.hasOwnProperty("defaultValue")) {
        validator(node, item.type, stringify(item.defaultValue));
      }
    }
    if (null == item.checked && null != item.defaultChecked) {
      /** @type {boolean} */
      node.defaultChecked = !!item.defaultChecked;
    }
  }
  /**
   * @param {!Object} item
   * @param {(Object|string)} value
   * @param {string} id
   * @return {undefined}
   */
  function reset(item, value, id) {
    if (value.hasOwnProperty("value") || value.hasOwnProperty("defaultValue")) {
      var name = value.type;
      if (!("submit" !== name && "reset" !== name || void 0 !== value.value && null !== value.value)) {
        return;
      }
      /** @type {string} */
      value = "" + item._wrapperState.initialValue;
      if (!(id || value === item.value)) {
        /** @type {(Object|string)} */
        item.value = value;
      }
      /** @type {(Object|string)} */
      item.defaultValue = value;
    }
    if ("" !== (id = item.name)) {
      /** @type {string} */
      item.name = "";
    }
    /** @type {boolean} */
    item.defaultChecked = !!item._wrapperState.initialChecked;
    if ("" !== id) {
      /** @type {string} */
      item.name = id;
    }
  }
  /**
   * @param {!Object} node
   * @param {string} _
   * @param {string} value
   * @return {undefined}
   */
  function validator(node, _, value) {
    if (!("number" === _ && node.ownerDocument.activeElement === node)) {
      if (null == value) {
        /** @type {string} */
        node.defaultValue = "" + node._wrapperState.initialValue;
      } else {
        if (node.defaultValue !== "" + value) {
          /** @type {string} */
          node.defaultValue = "" + value;
        }
      }
    }
  }
  /**
   * @param {!Object} data
   * @param {!Object} element
   * @return {?}
   */
  function wrap(data, element) {
    return data = assign({
      children : void 0
    }, element), (element = function(value) {
      /** @type {string} */
      var result = "";
      return React.Children.forEach(value, function(overrideSubItems) {
        if (null != overrideSubItems) {
          result = result + overrideSubItems;
        }
      }), result;
    }(element.children)) && (data.children = element), data;
  }
  /**
   * @param {string} data
   * @param {?} res
   * @param {string} key
   * @param {number} a
   * @return {?}
   */
  function updateOptions(data, res, key, a) {
    if (data = data.options, res) {
      res = {};
      /** @type {number} */
      var i = 0;
      for (; i < key.length; i++) {
        /** @type {boolean} */
        res["$" + key[i]] = true;
      }
      /** @type {number} */
      key = 0;
      for (; key < data.length; key++) {
        /** @type {boolean} */
        i = res.hasOwnProperty("$" + data[key].value);
        if (data[key].selected !== i) {
          /** @type {boolean} */
          data[key].selected = i;
        }
        if (i && a) {
          /** @type {boolean} */
          data[key].defaultSelected = true;
        }
      }
    } else {
      /** @type {string} */
      key = "" + stringify(key);
      /** @type {null} */
      res = null;
      /** @type {number} */
      i = 0;
      for (; i < data.length; i++) {
        if (data[i].value === key) {
          return data[i].selected = true, void(a && (data[i].defaultSelected = true));
        }
        if (!(null !== res || data[i].disabled)) {
          res = data[i];
        }
      }
      if (null !== res) {
        /** @type {boolean} */
        res.selected = true;
      }
    }
  }
  /**
   * @param {!Object} evt
   * @param {!Object} props
   * @return {?}
   */
  function select(evt, props) {
    if (null != props.dangerouslySetInnerHTML) {
      throw Error(call(91));
    }
    return assign({}, props, {
      value : void 0,
      defaultValue : void 0,
      children : "" + evt._wrapperState.initialValue
    });
  }
  /**
   * @param {!Object} inst
   * @param {!Object} v
   * @return {undefined}
   */
  function done(inst, v) {
    var r = v.value;
    if (null == r) {
      if (r = v.children, v = v.defaultValue, null != r) {
        if (null != v) {
          throw Error(call(92));
        }
        if (Array.isArray(r)) {
          if (!(1 >= r.length)) {
            throw Error(call(93));
          }
          r = r[0];
        }
        v = r;
      }
      if (null == v) {
        /** @type {string} */
        v = "";
      }
      /** @type {!Object} */
      r = v;
    }
    inst._wrapperState = {
      initialValue : stringify(r)
    };
  }
  /**
   * @param {!Object} node
   * @param {!Object} options
   * @return {undefined}
   */
  function fixElement(node, options) {
    var value = stringify(options.value);
    var hash = stringify(options.defaultValue);
    if (null != value) {
      if ((value = "" + value) !== node.value) {
        /** @type {string} */
        node.value = value;
      }
      if (null == options.defaultValue && node.defaultValue !== value) {
        /** @type {string} */
        node.defaultValue = value;
      }
    }
    if (null != hash) {
      /** @type {string} */
      node.defaultValue = "" + hash;
    }
  }
  /**
   * @param {!Object} item
   * @return {undefined}
   */
  function readFile(item) {
    var value = item.textContent;
    if (value === item._wrapperState.initialValue && "" !== value && null !== value) {
      item.value = value;
    }
  }
  /**
   * @param {string} type
   * @return {?}
   */
  function createNode(type) {
    switch(type) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  /**
   * @param {string} value
   * @param {string} tag
   * @return {?}
   */
  function Number(value, tag) {
    return null == value || "http://www.w3.org/1999/xhtml" === value ? createNode(tag) : "http://www.w3.org/2000/svg" === value && "foreignObject" === tag ? "http://www.w3.org/1999/xhtml" : value;
  }
  /**
   * @param {!HTMLElement} element
   * @param {string} value
   * @return {?}
   */
  function append(element, value) {
    if (value) {
      var node = element.firstChild;
      if (node && node === element.lastChild && 3 === node.nodeType) {
        return void(node.nodeValue = value);
      }
    }
    /** @type {string} */
    element.textContent = value;
  }
  /**
   * @param {string} styleProp
   * @param {string} eventName
   * @return {?}
   */
  function _prefixedEvent(styleProp, eventName) {
    var prefixes = {};
    return prefixes[styleProp.toLowerCase()] = eventName.toLowerCase(), prefixes["Webkit" + styleProp] = "webkit" + eventName, prefixes["Moz" + styleProp] = "moz" + eventName, prefixes;
  }
  /**
   * @param {string} value
   * @return {?}
   */
  function getComputedStyle(value) {
    if (dict[value]) {
      return dict[value];
    }
    if (!EVENT_NAME_MAP[value]) {
      return value;
    }
    var name;
    var names = EVENT_NAME_MAP[value];
    for (name in names) {
      if (names.hasOwnProperty(name) && name in elem) {
        return dict[value] = names[name];
      }
    }
    return value;
  }
  /**
   * @param {boolean} o
   * @return {?}
   */
  function setOptions(o) {
    var t = ss.get(o);
    return void 0 === t && (t = new Map, ss.set(o, t)), t;
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function assert(value) {
    /** @type {!Object} */
    var node = value;
    /** @type {!Object} */
    var assignee = value;
    if (value.alternate) {
      for (; node.return;) {
        node = node.return;
      }
    } else {
      value = node;
      do {
        if (0 !== (1026 & (node = value).effectTag)) {
          assignee = node.return;
        }
        value = node.return;
      } while (value);
    }
    return 3 === node.tag ? assignee : null;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function text(node) {
    if (13 === node.tag) {
      var locTexture = node.memoizedState;
      if (null === locTexture && (null !== (node = node.alternate) && (locTexture = node.memoizedState)), null !== locTexture) {
        return locTexture.dehydrated;
      }
    }
    return null;
  }
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  function lookup(key) {
    if (assert(key) !== key) {
      throw Error(call(188));
    }
  }
  /**
   * @param {?} data
   * @return {?}
   */
  function query(data) {
    if (!(data = function(root) {
      var parent = root.alternate;
      if (!parent) {
        if (null === (parent = assert(root))) {
          throw Error(call(188));
        }
        return parent !== root ? null : root;
      }
      var node = root;
      var current = parent;
      for (;;) {
        var item = node.return;
        if (null === item) {
          break;
        }
        var next = item.alternate;
        if (null === next) {
          if (null !== (current = item.return)) {
            node = current;
            continue;
          }
          break;
        }
        if (item.child === next.child) {
          next = item.child;
          for (; next;) {
            if (next === node) {
              return lookup(item), root;
            }
            if (next === current) {
              return lookup(item), parent;
            }
            next = next.sibling;
          }
          throw Error(call(188));
        }
        if (node.return !== current.return) {
          node = item;
          current = next;
        } else {
          /** @type {boolean} */
          var s = false;
          var child = item.child;
          for (; child;) {
            if (child === node) {
              /** @type {boolean} */
              s = true;
              node = item;
              current = next;
              break;
            }
            if (child === current) {
              /** @type {boolean} */
              s = true;
              current = item;
              node = next;
              break;
            }
            child = child.sibling;
          }
          if (!s) {
            child = next.child;
            for (; child;) {
              if (child === node) {
                /** @type {boolean} */
                s = true;
                node = next;
                current = item;
                break;
              }
              if (child === current) {
                /** @type {boolean} */
                s = true;
                current = next;
                node = item;
                break;
              }
              child = child.sibling;
            }
            if (!s) {
              throw Error(call(189));
            }
          }
        }
        if (node.alternate !== current) {
          throw Error(call(190));
        }
      }
      if (3 !== node.tag) {
        throw Error(call(188));
      }
      return node.stateNode.current === node ? root : parent;
    }(data))) {
      return null;
    }
    var node = data;
    for (;;) {
      if (5 === node.tag || 6 === node.tag) {
        return node;
      }
      if (node.child) {
        node.child.return = node;
        node = node.child;
      } else {
        if (node === data) {
          break;
        }
        for (; !node.sibling;) {
          if (!node.return || node.return === data) {
            return null;
          }
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return null;
  }
  /**
   * @param {string} n
   * @param {string} a
   * @return {?}
   */
  function push(n, a) {
    if (null == a) {
      throw Error(call(30));
    }
    return null == n ? a : Array.isArray(n) ? Array.isArray(a) ? (n.push.apply(n, a), n) : (n.push(a), n) : Array.isArray(a) ? [n].concat(a) : [n, a];
  }
  /**
   * @param {string} data
   * @param {!Function} type
   * @param {!Array} func
   * @return {undefined}
   */
  function after(data, type, func) {
    if (Array.isArray(data)) {
      data.forEach(type, func);
    } else {
      if (data) {
        type.call(func, data);
      }
    }
  }
  /**
   * @param {!Object} event
   * @return {undefined}
   */
  function executeDispatchesInOrder(event) {
    if (event) {
      var b = event._dispatchListeners;
      var dispatchListeners = event._dispatchInstances;
      if (Array.isArray(b)) {
        /** @type {number} */
        var i = 0;
        for (; i < b.length && !event.isPropagationStopped(); i++) {
          executeDispatch(event, b[i], dispatchListeners[i]);
        }
      } else {
        if (b) {
          executeDispatch(event, b, dispatchListeners);
        }
      }
      /** @type {null} */
      event._dispatchListeners = null;
      /** @type {null} */
      event._dispatchInstances = null;
      if (!event.isPersistent()) {
        event.constructor.release(event);
      }
    }
  }
  /**
   * @param {!Object} value
   * @return {undefined}
   */
  function fail(value) {
    if (null !== value && (c = push(c, value)), value = c, c = null, value) {
      if (after(value, executeDispatchesInOrder), c) {
        throw Error(call(95));
      }
      if ($b) {
        throw value = location, $b = false, location = null, value;
      }
    }
  }
  /**
   * @param {!Object} e
   * @return {?}
   */
  function getEventTarget(e) {
    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e;
  }
  /**
   * @param {string} eventName
   * @return {?}
   */
  function makeResultContainer(eventName) {
    if (!val) {
      return false;
    }
    /** @type {boolean} */
    var element = (eventName = "on" + eventName) in document;
    return element || ((element = document.createElement("div")).setAttribute(eventName, "return;"), element = "function" === typeof element[eventName]), element;
  }
  /**
   * @param {!Object} event
   * @return {undefined}
   */
  function mousedown(event) {
    /** @type {null} */
    event.topLevelType = null;
    /** @type {null} */
    event.nativeEvent = null;
    /** @type {null} */
    event.targetInst = null;
    /** @type {number} */
    event.ancestors.length = 0;
    if (10 > deadPool.length) {
      deadPool.push(event);
    }
  }
  /**
   * @param {string} key
   * @param {!Object} e
   * @param {!Object} i
   * @param {!Object} value
   * @return {?}
   */
  function o(key, e, i, value) {
    if (deadPool.length) {
      var p = deadPool.pop();
      return p.topLevelType = key, p.eventSystemFlags = value, p.nativeEvent = e, p.targetInst = i, p;
    }
    return {
      topLevelType : key,
      eventSystemFlags : value,
      nativeEvent : e,
      targetInst : i,
      ancestors : []
    };
  }
  /**
   * @param {!Object} bookKeeping
   * @return {undefined}
   */
  function handleTopLevelWithPath(bookKeeping) {
    var result = bookKeeping.targetInst;
    var i = result;
    do {
      if (!i) {
        bookKeeping.ancestors.push(i);
        break;
      }
      var value = i;
      if (3 === value.tag) {
        value = value.stateNode.containerInfo;
      } else {
        for (; value.return;) {
          value = value.return;
        }
        value = 3 !== value.tag ? null : value.stateNode.containerInfo;
      }
      if (!value) {
        break;
      }
      if (!(5 !== (result = i.tag) && 6 !== result)) {
        bookKeeping.ancestors.push(i);
      }
      i = recurse(value);
    } while (i);
    /** @type {number} */
    i = 0;
    for (; i < bookKeeping.ancestors.length; i++) {
      result = bookKeeping.ancestors[i];
      var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
      value = bookKeeping.topLevelType;
      var e = bookKeeping.nativeEvent;
      var y = bookKeeping.eventSystemFlags;
      if (0 === i) {
        /** @type {number} */
        y = y | 64;
      }
      /** @type {null} */
      var c = null;
      /** @type {number} */
      var r = 0;
      for (; r < rels.length; r++) {
        var self = rels[r];
        if (self && (self = self.extractEvents(value, result, e, nativeEventTarget, y))) {
          c = push(c, self);
        }
      }
      fail(c);
    }
  }
  /**
   * @param {string} event
   * @param {!Object} port
   * @param {!Object} target
   * @return {undefined}
   */
  function get(event, port, target) {
    if (!target.has(event)) {
      switch(event) {
        case "scroll":
          listen(port, "scroll", true);
          break;
        case "focus":
        case "blur":
          listen(port, "focus", true);
          listen(port, "blur", true);
          target.set("blur", null);
          target.set("focus", null);
          break;
        case "cancel":
        case "close":
          if (makeResultContainer(event)) {
            listen(port, event, true);
          }
          break;
        case "invalid":
        case "submit":
        case "reset":
          break;
        default:
          if (-1 === info.indexOf(event)) {
            expect(event, port);
          }
      }
      target.set(event, null);
    }
  }
  /**
   * @param {!Object} x
   * @param {string} type
   * @param {number} context
   * @param {!Node} elem
   * @param {!Object} e
   * @return {?}
   */
  function triggerEvent(x, type, context, elem, e) {
    return {
      blockedOn : x,
      topLevelType : type,
      eventSystemFlags : 32 | context,
      nativeEvent : e,
      container : elem
    };
  }
  /**
   * @param {string} type
   * @param {!Object} data
   * @return {undefined}
   */
  function destroy(type, data) {
    switch(type) {
      case "focus":
      case "blur":
        /** @type {null} */
        result = null;
        break;
      case "dragenter":
      case "dragleave":
        /** @type {null} */
        url = null;
        break;
      case "mouseover":
      case "mouseout":
        /** @type {null} */
        v = null;
        break;
      case "pointerover":
      case "pointerout":
        target.delete(data.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        cache.delete(data.pointerId);
    }
  }
  /**
   * @param {!Object} value
   * @param {!Object} text
   * @param {string} input
   * @param {number} context
   * @param {!Node} data
   * @param {!Object} result
   * @return {?}
   */
  function escape(value, text, input, context, data, result) {
    return null === value || value.nativeEvent !== result ? (value = triggerEvent(text, input, context, data, result), null !== text && (null !== (text = matches(text)) && flatten(text)), value) : (value.eventSystemFlags |= context, value);
  }
  /**
   * @param {!Function} e
   * @return {?}
   */
  function watch(e) {
    var result = recurse(e.target);
    if (null !== result) {
      var node = assert(result);
      if (null !== node) {
        if (13 === (result = node.tag)) {
          if (null !== (result = text(node))) {
            return e.blockedOn = result, void app.unstable_runWithPriority(e.priority, function() {
              match(node);
            });
          }
        } else {
          if (3 === result && node.stateNode.hydrate) {
            return void(e.blockedOn = 3 === node.tag ? node.stateNode.containerInfo : null);
          }
        }
      }
    }
    /** @type {null} */
    e.blockedOn = null;
  }
  /**
   * @param {!Object} event
   * @return {?}
   */
  function is(event) {
    if (null !== event.blockedOn) {
      return false;
    }
    var element = error(event.topLevelType, event.eventSystemFlags, event.container, event.nativeEvent);
    if (null !== element) {
      var value = matches(element);
      return null !== value && flatten(value), event.blockedOn = element, false;
    }
    return true;
  }
  /**
   * @param {!Object} name
   * @param {string} a
   * @param {!File} b
   * @return {undefined}
   */
  function inst(name, a, b) {
    if (is(name)) {
      b.delete(a);
    }
  }
  /**
   * @return {undefined}
   */
  function collect() {
    /** @type {boolean} */
    vt = false;
    for (; 0 < data.length;) {
      var e = data[0];
      if (null !== e.blockedOn) {
        if (null !== (e = matches(e.blockedOn))) {
          draw(e);
        }
        break;
      }
      var err = error(e.topLevelType, e.eventSystemFlags, e.container, e.nativeEvent);
      if (null !== err) {
        e.blockedOn = err;
      } else {
        data.shift();
      }
    }
    if (null !== result && is(result)) {
      /** @type {null} */
      result = null;
    }
    if (null !== url && is(url)) {
      /** @type {null} */
      url = null;
    }
    if (null !== v && is(v)) {
      /** @type {null} */
      v = null;
    }
    target.forEach(inst);
    cache.forEach(inst);
  }
  /**
   * @param {!Object} msg
   * @param {!Object} done
   * @return {undefined}
   */
  function step(msg, done) {
    if (msg.blockedOn === done) {
      /** @type {null} */
      msg.blockedOn = null;
      if (!vt) {
        /** @type {boolean} */
        vt = true;
        app.unstable_scheduleCallback(app.unstable_NormalPriority, collect);
      }
    }
  }
  /**
   * @param {!Object} value
   * @return {undefined}
   */
  function _register(value) {
    /**
     * @param {!Object} note
     * @return {?}
     */
    function error(note) {
      return step(note, value);
    }
    if (0 < data.length) {
      step(data[0], value);
      /** @type {number} */
      var id = 1;
      for (; id < data.length; id++) {
        var obj = data[id];
        if (obj.blockedOn === value) {
          /** @type {null} */
          obj.blockedOn = null;
        }
      }
    }
    if (null !== result) {
      step(result, value);
    }
    if (null !== url) {
      step(url, value);
    }
    if (null !== v) {
      step(v, value);
    }
    target.forEach(error);
    cache.forEach(error);
    /** @type {number} */
    id = 0;
    for (; id < params.length; id++) {
      if ((obj = params[id]).blockedOn === value) {
        /** @type {null} */
        obj.blockedOn = null;
      }
    }
    for (; 0 < params.length && null === (id = params[0]).blockedOn;) {
      watch(id);
      if (null === id.blockedOn) {
        params.shift();
      }
    }
  }
  /**
   * @param {!Array} value
   * @param {number} id
   * @return {undefined}
   */
  function dispatchEvent(value, id) {
    /** @type {number} */
    var j = 0;
    for (; j < value.length; j = j + 2) {
      var url = value[j];
      var i = value[j + 1];
      /** @type {string} */
      var key = "on" + (i[0].toUpperCase() + i.slice(1));
      key = {
        phasedRegistrationNames : {
          bubbled : key,
          captured : key + "Capture"
        },
        dependencies : [url],
        eventPriority : id
      };
      span.set(url, id);
      executionContextNamesByOrigin.set(url, key);
      eventTypes[i] = key;
    }
  }
  /**
   * @param {string} eventName
   * @param {!Object} cb
   * @return {undefined}
   */
  function expect(eventName, cb) {
    listen(cb, eventName, false);
  }
  /**
   * @param {!Object} cb
   * @param {string} value
   * @param {boolean} fallback
   * @return {undefined}
   */
  function listen(cb, value, fallback) {
    var name = span.get(value);
    switch(void 0 === name ? 2 : name) {
      case 0:
        name = load.bind(null, value, 1, cb);
        break;
      case 1:
        name = upload.bind(null, value, 1, cb);
        break;
      default:
        name = setup.bind(null, value, 1, cb);
    }
    if (fallback) {
      cb.addEventListener(value, name, true);
    } else {
      cb.addEventListener(value, name, false);
    }
  }
  /**
   * @param {?} x
   * @param {?} r
   * @param {?} b
   * @param {?} g
   * @return {undefined}
   */
  function load(x, r, b, g) {
    if (!searchScope) {
      getData();
    }
    /** @type {function(string, undefined, undefined, !Object): undefined} */
    var fn = setup;
    var possibleSearchScope = searchScope;
    /** @type {boolean} */
    searchScope = true;
    try {
      writer(fn, x, r, b, g);
    } finally {
      if (!(searchScope = possibleSearchScope)) {
        onload();
      }
    }
  }
  /**
   * @param {?} callback
   * @param {?} id
   * @param {?} d
   * @param {?} e
   * @return {undefined}
   */
  function upload(callback, id, d, e) {
    skip(p, setup.bind(null, callback, id, d, e));
  }
  /**
   * @param {string} e
   * @param {undefined} value
   * @param {undefined} id
   * @param {!Object} c
   * @return {undefined}
   */
  function setup(e, value, id, c) {
    if (viewportCenter) {
      if (0 < data.length && -1 < related_node_ids.indexOf(e)) {
        e = triggerEvent(null, e, value, id, c);
        data.push(e);
      } else {
        var el = error(e, value, id, c);
        if (null === el) {
          destroy(e, c);
        } else {
          if (-1 < related_node_ids.indexOf(e)) {
            e = triggerEvent(el, e, value, id, c);
            data.push(e);
          } else {
            if (!function(data, key, options, value, i) {
              switch(key) {
                case "focus":
                  return result = escape(result, data, key, options, value, i), true;
                case "dragenter":
                  return url = escape(url, data, key, options, value, i), true;
                case "mouseover":
                  return v = escape(v, data, key, options, value, i), true;
                case "pointerover":
                  var name = i.pointerId;
                  return target.set(name, escape(target.get(name) || null, data, key, options, value, i)), true;
                case "gotpointercapture":
                  return name = i.pointerId, cache.set(name, escape(cache.get(name) || null, data, key, options, value, i)), true;
              }
              return false;
            }(el, e, value, id, c)) {
              destroy(e, c);
              e = o(e, c, null, value);
              try {
                respond(handleTopLevelWithPath, e);
              } finally {
                mousedown(e);
              }
            }
          }
        }
      }
    }
  }
  /**
   * @param {string} e
   * @param {!Object} d
   * @param {!Object} i
   * @param {!Object} t
   * @return {?}
   */
  function error(e, d, i, t) {
    if (null !== (i = recurse(i = getEventTarget(t)))) {
      var val = assert(i);
      if (null === val) {
        /** @type {null} */
        i = null;
      } else {
        var name = val.tag;
        if (13 === name) {
          if (null !== (i = text(val))) {
            return i;
          }
          /** @type {null} */
          i = null;
        } else {
          if (3 === name) {
            if (val.stateNode.hydrate) {
              return 3 === val.tag ? val.stateNode.containerInfo : null;
            }
            /** @type {null} */
            i = null;
          } else {
            if (val !== i) {
              /** @type {null} */
              i = null;
            }
          }
        }
      }
    }
    e = o(e, t, i, d);
    try {
      respond(handleTopLevelWithPath, e);
    } finally {
      mousedown(e);
    }
    return null;
  }
  /**
   * @param {string} name
   * @param {string} value
   * @param {string} count
   * @return {?}
   */
  function loop(name, value, count) {
    return null == value || "boolean" === typeof value || "" === value ? "" : count || "number" !== typeof value || 0 === value || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name] ? ("" + value).trim() : value + "px";
  }
  /**
   * @param {!Object} node
   * @param {!Object} obj
   * @return {undefined}
   */
  function setStyle(node, obj) {
    var key;
    for (key in node = node.style, obj) {
      if (obj.hasOwnProperty(key)) {
        /** @type {boolean} */
        var limit = 0 === key.indexOf("--");
        var result = loop(key, obj[key], limit);
        if ("float" === key) {
          /** @type {string} */
          key = "cssFloat";
        }
        if (limit) {
          node.setProperty(key, result);
        } else {
          node[key] = result;
        }
      }
    }
  }
  /**
   * @param {!Array} name
   * @param {!Object} props
   * @return {undefined}
   */
  function has(name, props) {
    if (props) {
      if (minimizeOptions[name] && (null != props.children || null != props.dangerouslySetInnerHTML)) {
        throw Error(call(137, name, ""));
      }
      if (null != props.dangerouslySetInnerHTML) {
        if (null != props.children) {
          throw Error(call(60));
        }
        if (!("object" === typeof props.dangerouslySetInnerHTML && "__html" in props.dangerouslySetInnerHTML)) {
          throw Error(call(61));
        }
      }
      if (null != props.style && "object" !== typeof props.style) {
        throw Error(call(62, ""));
      }
    }
  }
  /**
   * @param {!Object} type
   * @param {!Object} t
   * @return {?}
   */
  function factory(type, t) {
    if (-1 === type.indexOf("-")) {
      return "string" === typeof t.is;
    }
    switch(type) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  /**
   * @param {!Object} options
   * @param {string} value
   * @return {undefined}
   */
  function invoke(options, value) {
    var opts = setOptions(options = 9 === options.nodeType || 11 === options.nodeType ? options : options.ownerDocument);
    value = props[value];
    /** @type {number} */
    var i = 0;
    for (; i < value.length; i++) {
      get(value[i], options, opts);
    }
  }
  /**
   * @return {undefined}
   */
  function size() {
  }
  /**
   * @param {!Object} doc
   * @return {?}
   */
  function getActiveElement(doc) {
    if ("undefined" === typeof(doc = doc || ("undefined" !== typeof document ? document : void 0))) {
      return null;
    }
    try {
      return doc.activeElement || doc.body;
    } catch (t) {
      return doc.body;
    }
  }
  /**
   * @param {!Object} data
   * @return {?}
   */
  function getMessage(data) {
    for (; data && data.firstChild;) {
      data = data.firstChild;
    }
    return data;
  }
  /**
   * @param {string} s
   * @param {string} start
   * @return {?}
   */
  function _findDomPosition(s, start) {
    var e;
    var msg = getMessage(s);
    /** @type {number} */
    s = 0;
    for (; msg;) {
      if (3 === msg.nodeType) {
        if (e = s + msg.textContent.length, s <= start && e >= start) {
          return {
            node : msg,
            offset : start - s
          };
        }
        s = e;
      }
      e: {
        for (; msg;) {
          if (msg.nextSibling) {
            msg = msg.nextSibling;
            break e;
          }
          msg = msg.parentNode;
        }
        msg = void 0;
      }
      msg = getMessage(msg);
    }
  }
  /**
   * @return {?}
   */
  function addScript() {
    /** @type {!Window} */
    var w = window;
    var element = getActiveElement();
    for (; element instanceof w.HTMLIFrameElement;) {
      try {
        /** @type {boolean} */
        var hasD = "string" === typeof element.contentWindow.location.href;
      } catch (n) {
        /** @type {boolean} */
        hasD = false;
      }
      if (!hasD) {
        break;
      }
      element = getActiveElement((w = element.contentWindow).document);
    }
    return element;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function handleKeyEvent(node) {
    var tagName = node && node.nodeName && node.nodeName.toLowerCase();
    return tagName && ("input" === tagName && ("text" === node.type || "search" === node.type || "tel" === node.type || "url" === node.type || "password" === node.type) || "textarea" === tagName || "true" === node.contentEditable);
  }
  /**
   * @param {?} type
   * @param {!Object} options
   * @return {?}
   */
  function focus(type, options) {
    switch(type) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!options.autoFocus;
    }
    return false;
  }
  /**
   * @param {string} name
   * @param {!Object} props
   * @return {?}
   */
  function walker(name, props) {
    return "textarea" === name || "option" === name || "noscript" === name || "string" === typeof props.children || "number" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function insertBefore(node) {
    for (; null != node; node = node.nextSibling) {
      var type = node.nodeType;
      if (1 === type || 3 === type) {
        break;
      }
    }
    return node;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function normalize(node) {
    node = node.previousSibling;
    /** @type {number} */
    var t = 0;
    for (; node;) {
      if (8 === node.nodeType) {
        var v = node.data;
        if ("$" === v || "$!" === v || "$?" === v) {
          if (0 === t) {
            return node;
          }
          t--;
        } else {
          if ("/$" === v) {
            t++;
          }
        }
      }
      node = node.previousSibling;
    }
    return null;
  }
  /**
   * @param {!Object} item
   * @return {?}
   */
  function recurse(item) {
    var node = item[id];
    if (node) {
      return node;
    }
    var obj = item.parentNode;
    for (; obj;) {
      if (node = obj[key] || obj[id]) {
        if (obj = node.alternate, null !== node.child || null !== obj && null !== obj.child) {
          item = normalize(item);
          for (; null !== item;) {
            if (obj = item[id]) {
              return obj;
            }
            item = normalize(item);
          }
        }
        return node;
      }
      obj = (item = obj).parentNode;
    }
    return null;
  }
  /**
   * @param {!Object} item
   * @return {?}
   */
  function matches(item) {
    return !(item = item[id] || item[key]) || 5 !== item.tag && 6 !== item.tag && 13 !== item.tag && 3 !== item.tag ? null : item;
  }
  /**
   * @param {?} node
   * @return {?}
   */
  function getProperty(node) {
    if (5 === node.tag || 6 === node.tag) {
      return node.stateNode;
    }
    throw Error(call(33));
  }
  /**
   * @param {!Object} arg
   * @return {?}
   */
  function b(arg) {
    return arg[k] || null;
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function isNaN(value) {
    do {
      value = value.return;
    } while (value && 5 !== value.tag);
    return value || null;
  }
  /**
   * @param {!Object} node
   * @param {?} name
   * @return {?}
   */
  function onClick(node, name) {
    var object = node.stateNode;
    if (!object) {
      return null;
    }
    var handler = parent(object);
    if (!handler) {
      return null;
    }
    object = handler[name];
    e: {
      switch(name) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          if (!(handler = !handler.disabled)) {
            /** @type {boolean} */
            handler = !("button" === (node = node.type) || "input" === node || "select" === node || "textarea" === node);
          }
          /** @type {boolean} */
          node = !handler;
          break e;
        default:
          /** @type {boolean} */
          node = false;
      }
    }
    if (node) {
      return null;
    }
    if (object && "function" !== typeof object) {
      throw Error(call(231, name, typeof object));
    }
    return object;
  }
  /**
   * @param {undefined} data
   * @param {string} id
   * @param {!Object} event
   * @return {undefined}
   */
  function addRow(data, id, event) {
    if (id = onClick(data, event.dispatchConfig.phasedRegistrationNames[id])) {
      event._dispatchListeners = push(event._dispatchListeners, id);
      event._dispatchInstances = push(event._dispatchInstances, data);
    }
  }
  /**
   * @param {!Object} event
   * @return {undefined}
   */
  function onLoad(event) {
    if (event && event.dispatchConfig.phasedRegistrationNames) {
      var x = event._targetInst;
      /** @type {!Array} */
      var r = [];
      for (; x;) {
        r.push(x);
        x = isNaN(x);
      }
      /** @type {number} */
      x = r.length;
      for (; 0 < x--;) {
        addRow(r[x], "captured", event);
      }
      /** @type {number} */
      x = 0;
      for (; x < r.length; x++) {
        addRow(r[x], "bubbled", event);
      }
    }
  }
  /**
   * @param {string} element
   * @param {string} value
   * @param {!Object} event
   * @return {undefined}
   */
  function accumulateDispatches(element, value, event) {
    if (element && event && event.dispatchConfig.registrationName && (value = onClick(element, event.dispatchConfig.registrationName))) {
      event._dispatchListeners = push(event._dispatchListeners, value);
      event._dispatchInstances = push(event._dispatchInstances, element);
    }
  }
  /**
   * @param {!Object} event
   * @return {undefined}
   */
  function accumulateDirectDispatchesSingle(event) {
    if (event && event.dispatchConfig.registrationName) {
      accumulateDispatches(event._targetInst, null, event);
    }
  }
  /**
   * @param {!Object} value
   * @return {undefined}
   */
  function trigger(value) {
    after(value, onLoad);
  }
  /**
   * @return {?}
   */
  function commit() {
    if (actions) {
      return actions;
    }
    var j;
    var i;
    var result = storeOptions;
    var len = result.length;
    var b = "value" in cursor ? cursor.value : cursor.textContent;
    var bl = b.length;
    /** @type {number} */
    j = 0;
    for (; j < len && result[j] === b[j]; j++) {
    }
    /** @type {number} */
    var k = len - j;
    /** @type {number} */
    i = 1;
    for (; i <= k && result[len - i] === b[bl - i]; i++) {
    }
    return actions = b.slice(j, 1 < i ? 1 - i : void 0);
  }
  /**
   * @return {?}
   */
  function returnTrue() {
    return true;
  }
  /**
   * @return {?}
   */
  function returnFalse() {
    return false;
  }
  /**
   * @param {!Object} key
   * @param {?} value
   * @param {!Object} event
   * @param {string} target
   * @return {?}
   */
  function Event(key, value, event, target) {
    var name;
    for (name in this.dispatchConfig = key, this._targetInst = value, this.nativeEvent = event, key = this.constructor.Interface) {
      if (key.hasOwnProperty(name)) {
        if (value = key[name]) {
          this[name] = value(event);
        } else {
          if ("target" === name) {
            /** @type {string} */
            this.target = target;
          } else {
            this[name] = event[name];
          }
        }
      }
    }
    return this.isDefaultPrevented = (null != event.defaultPrevented ? event.defaultPrevented : false === event.returnValue) ? returnTrue : returnFalse, this.isPropagationStopped = returnFalse, this;
  }
  /**
   * @param {?} e
   * @param {?} obj
   * @param {boolean} callback
   * @param {boolean} target
   * @return {?}
   */
  function kill(e, obj, callback, target) {
    if (this.eventPool.length) {
      var t = this.eventPool.pop();
      return this.call(t, e, obj, callback, target), t;
    }
    return new this(e, obj, callback, target);
  }
  /**
   * @param {!Object} info
   * @return {undefined}
   */
  function release(info) {
    if (!(info instanceof this)) {
      throw Error(call(279));
    }
    info.destructor();
    if (10 > this.eventPool.length) {
      this.eventPool.push(info);
    }
  }
  /**
   * @param {!Object} child
   * @return {undefined}
   */
  function inherits(child) {
    /** @type {!Array} */
    child.eventPool = [];
    /** @type {function(?, ?, boolean, boolean): ?} */
    child.getPooled = kill;
    /** @type {function(!Object): undefined} */
    child.release = release;
  }
  /**
   * @param {string} type
   * @param {!Object} e
   * @return {?}
   */
  function inArray(type, e) {
    switch(type) {
      case "keyup":
        return -1 !== allowedCodes.indexOf(e.keyCode);
      case "keydown":
        return 229 !== e.keyCode;
      case "keypress":
      case "mousedown":
      case "blur":
        return true;
      default:
        return false;
    }
  }
  /**
   * @param {!Object} event
   * @return {?}
   */
  function on(event) {
    return "object" === typeof(event = event.detail) && "data" in event ? event.data : null;
  }
  /**
   * @param {string} el
   * @return {?}
   */
  function targetNeedsFocus(el) {
    var tagName = el && el.nodeName && el.nodeName.toLowerCase();
    return "input" === tagName ? !!$inputTypes[el.type] : "textarea" === tagName;
  }
  /**
   * @param {?} event
   * @param {boolean} func
   * @param {boolean} target
   * @return {?}
   */
  function write(event, func, target) {
    return (event = Event.getPooled(listeners.change, event, func, target)).type = "change", closeTag(target), trigger(event), event;
  }
  /**
   * @param {!Object} fn
   * @return {undefined}
   */
  function retry(fn) {
    fail(fn);
  }
  /**
   * @param {?} obj
   * @return {?}
   */
  function isDefined(obj) {
    if (getValue(getProperty(obj))) {
      return obj;
    }
  }
  /**
   * @param {string} q
   * @param {boolean} items
   * @return {?}
   */
  function source(q, items) {
    if ("change" === q) {
      return items;
    }
  }
  /**
   * @return {undefined}
   */
  function once() {
    if (self) {
      self.detachEvent("onpropertychange", listener);
      /** @type {null} */
      name = self = null;
    }
  }
  /**
   * @param {!Object} options
   * @return {undefined}
   */
  function listener(options) {
    if ("value" === options.propertyName && isDefined(name)) {
      if (options = write(name, options, getEventTarget(options)), searchScope) {
        fail(options);
      } else {
        /** @type {boolean} */
        searchScope = true;
        try {
          command(retry, options);
        } finally {
          /** @type {boolean} */
          searchScope = false;
          onload();
        }
      }
    }
  }
  /**
   * @param {string} type
   * @param {!Element} str
   * @param {string} callback
   * @return {undefined}
   */
  function main(type, str, callback) {
    if ("focus" === type) {
      once();
      /** @type {string} */
      name = callback;
      (self = str).attachEvent("onpropertychange", listener);
    } else {
      if ("blur" === type) {
        once();
      }
    }
  }
  /**
   * @param {string} value
   * @return {?}
   */
  function initEvents(value) {
    if ("selectionchange" === value || "keyup" === value || "keydown" === value) {
      return isDefined(name);
    }
  }
  /**
   * @param {string} evt
   * @param {?} el
   * @return {?}
   */
  function isClickableElement(evt, el) {
    if ("click" === evt) {
      return isDefined(el);
    }
  }
  /**
   * @param {string} id
   * @param {?} config
   * @return {?}
   */
  function structureExtras(id, config) {
    if ("input" === id || "change" === id) {
      return isDefined(config);
    }
  }
  /**
   * @param {?} key
   * @return {?}
   */
  function normalizeCommandKeys(key) {
    var event = this.nativeEvent;
    return event.getModifierState ? event.getModifierState(key) : !!(key = keymap[key]) && !!event[key];
  }
  /**
   * @return {?}
   */
  function movementCost() {
    return normalizeCommandKeys;
  }
  /**
   * @param {!Object} a
   * @param {!Object} item
   * @return {?}
   */
  function next(a, item) {
    if (deepEqual(a, item)) {
      return true;
    }
    if ("object" !== typeof a || null === a || "object" !== typeof item || null === item) {
      return false;
    }
    /** @type {!Array<string>} */
    var keys = Object.keys(a);
    /** @type {!Array<string>} */
    var i = Object.keys(item);
    if (keys.length !== i.length) {
      return false;
    }
    /** @type {number} */
    i = 0;
    for (; i < keys.length; i++) {
      if (!hasOwn.call(item, keys[i]) || !deepEqual(a[keys[i]], item[keys[i]])) {
        return false;
      }
    }
    return true;
  }
  /**
   * @param {?} event
   * @param {?} nativeEventTarget
   * @return {?}
   */
  function getSelection(event, nativeEventTarget) {
    var selection = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    return files || null == s || s !== getActiveElement(selection) ? null : ("selectionStart" in (selection = s) && handleKeyEvent(selection) ? selection = {
      start : selection.selectionStart,
      end : selection.selectionEnd
    } : selection = {
      anchorNode : (selection = (selection.ownerDocument && selection.ownerDocument.defaultView || window).getSelection()).anchorNode,
      anchorOffset : selection.anchorOffset,
      focusNode : selection.focusNode,
      focusOffset : selection.focusOffset
    }, err && next(err, selection) ? null : (err = selection, (event = Event.getPooled(panel.select, payload, event, nativeEventTarget)).type = "select", event.target = s, trigger(event), event));
  }
  /**
   * @param {number} e
   * @return {?}
   */
  function getKey(e) {
    var c = e.keyCode;
    return "charCode" in e ? 0 === (e = e.charCode) && 13 === c && (e = 13) : e = c, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0;
  }
  /**
   * @param {!Object} obj
   * @return {undefined}
   */
  function isString(obj) {
    if (!(0 > i)) {
      obj.current = fields[i];
      /** @type {null} */
      fields[i] = null;
      i--;
    }
  }
  /**
   * @param {!Object} obj
   * @param {number} val
   * @return {undefined}
   */
  function indexOf(obj, val) {
    i++;
    fields[i] = obj.current;
    /** @type {number} */
    obj.current = val;
  }
  /**
   * @param {!Object} node
   * @param {!Array} t
   * @return {?}
   */
  function $(node, t) {
    var contextTypes = node.type.contextTypes;
    if (!contextTypes) {
      return root;
    }
    var key = node.stateNode;
    if (key && key.__reactInternalMemoizedUnmaskedChildContext === t) {
      return key.__reactInternalMemoizedMaskedChildContext;
    }
    var j;
    var attr = {};
    for (j in contextTypes) {
      attr[j] = t[j];
    }
    return key && ((node = node.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, node.__reactInternalMemoizedMaskedChildContext = attr), attr;
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function isFunction(value) {
    return null !== (value = value.childContextTypes) && void 0 !== value;
  }
  /**
   * @return {undefined}
   */
  function required() {
    isString(nodeList);
    isString(item);
  }
  /**
   * @param {number} container
   * @param {undefined} data
   * @param {boolean} obj
   * @return {undefined}
   */
  function rec(container, data, obj) {
    if (item.current !== root) {
      throw Error(call(168));
    }
    indexOf(item, data);
    indexOf(nodeList, obj);
  }
  /**
   * @param {string} data
   * @param {!Object} options
   * @param {?} element
   * @return {?}
   */
  function store(data, options, element) {
    var c = data.stateNode;
    if (data = options.childContextTypes, "function" !== typeof c.getChildContext) {
      return element;
    }
    var value;
    for (value in c = c.getChildContext()) {
      if (!(value in data)) {
        throw Error(call(108, each(options) || "Unknown", value));
      }
    }
    return assign({}, element, {}, c);
  }
  /**
   * @param {!Array} node
   * @return {?}
   */
  function replaceChild(node) {
    return node = (node = node.stateNode) && node.__reactInternalMemoizedMergedChildContext || root, form = item.current, indexOf(item, node), indexOf(nodeList, nodeList.current), true;
  }
  /**
   * @param {boolean} value
   * @param {!Object} options
   * @param {boolean} key
   * @return {undefined}
   */
  function getChildren(value, options, key) {
    var observeData = value.stateNode;
    if (!observeData) {
      throw Error(call(169));
    }
    if (key) {
      value = store(value, options, form);
      /** @type {boolean} */
      observeData.__reactInternalMemoizedMergedChildContext = value;
      isString(nodeList);
      isString(item);
      indexOf(item, value);
    } else {
      isString(nodeList);
    }
    indexOf(nodeList, key);
  }
  /**
   * @return {?}
   */
  function then() {
    switch(onWait()) {
      case e:
        return 99;
      case output:
        return 98;
      case curDoc:
        return 97;
      case tasks:
        return 96;
      case collection:
        return 95;
      default:
        throw Error(call(332));
    }
  }
  /**
   * @param {number} ast
   * @return {?}
   */
  function search(ast) {
    switch(ast) {
      case 99:
        return e;
      case 98:
        return output;
      case 97:
        return curDoc;
      case 96:
        return tasks;
      case 95:
        return collection;
      default:
        throw Error(call(332));
    }
  }
  /**
   * @param {number} e
   * @param {!Function} id
   * @return {?}
   */
  function drop(e, id) {
    return e = search(e), D(e, id);
  }
  /**
   * @param {number} e
   * @param {!Function} d
   * @param {!Object} i
   * @return {?}
   */
  function multiply(e, d, i) {
    return e = search(e), u(e, d, i);
  }
  /**
   * @param {string} value
   * @return {?}
   */
  function success(value) {
    return null === number ? (number = [value], el = u(e, d)) : number.push(value), origin;
  }
  /**
   * @return {undefined}
   */
  function log() {
    if (null !== el) {
      var check = el;
      /** @type {null} */
      el = null;
      concat(check);
    }
    d();
  }
  /**
   * @return {undefined}
   */
  function d() {
    if (!address && null !== number) {
      /** @type {boolean} */
      address = true;
      /** @type {number} */
      var i = 0;
      try {
        /** @type {!Array} */
        var b = number;
        drop(99, function() {
          for (; i < b.length; i++) {
            var f = b[i];
            do {
              f = f(true);
            } while (null !== f);
          }
        });
        /** @type {null} */
        number = null;
      } catch (r) {
        throw null !== number && (number = number.slice(i + 1)), u(e, log), r;
      } finally {
        /** @type {boolean} */
        address = false;
      }
    }
  }
  /**
   * @param {number} o
   * @param {number} pos
   * @param {number} update
   * @return {?}
   */
  function calc(o, pos, update) {
    return 1073741821 - (1 + ((1073741821 - o + pos / 10) / (update = update / 10) | 0)) * update;
  }
  /**
   * @param {undefined} type
   * @param {!Function} data
   * @return {?}
   */
  function transform(type, data) {
    if (type && type.defaultProps) {
      var name;
      for (name in data = assign({}, data), type = type.defaultProps) {
        if (void 0 === data[name]) {
          data[name] = type[name];
        }
      }
    }
    return data;
  }
  /**
   * @return {undefined}
   */
  function assertConcrete() {
    /** @type {null} */
    prev = current = top = null;
  }
  /**
   * @param {!Object} element
   * @return {undefined}
   */
  function template(element) {
    /** @type {null} */
    var value = status.current;
    isString(status);
    /** @type {null} */
    element.type._context._currentValue = value;
  }
  /**
   * @param {!Object} value
   * @param {number} min
   * @return {undefined}
   */
  function visit(value, min) {
    for (; null !== value;) {
      var result = value.alternate;
      if (value.childExpirationTime < min) {
        /** @type {number} */
        value.childExpirationTime = min;
        if (null !== result && result.childExpirationTime < min) {
          /** @type {number} */
          result.childExpirationTime = min;
        }
      } else {
        if (!(null !== result && result.childExpirationTime < min)) {
          break;
        }
        /** @type {number} */
        result.childExpirationTime = min;
      }
      value = value.return;
    }
  }
  /**
   * @param {!Object} value
   * @param {number} start
   * @return {undefined}
   */
  function report(value, start) {
    /** @type {!Object} */
    top = value;
    /** @type {null} */
    prev = current = null;
    if (null !== (value = value.dependencies) && null !== value.firstContext) {
      if (value.expirationTime >= start) {
        /** @type {boolean} */
        property = true;
      }
      /** @type {null} */
      value.firstContext = null;
    }
  }
  /**
   * @param {string} name
   * @param {number} p
   * @return {?}
   */
  function require(name, p) {
    if (prev !== name && false !== p && 0 !== p) {
      if ("number" === typeof p && 1073741823 !== p || (prev = name, p = 1073741823), p = {
        context : name,
        observedBits : p,
        next : null
      }, null === current) {
        if (null === top) {
          throw Error(call(308));
        }
        /** @type {number} */
        current = p;
        top.dependencies = {
          expirationTime : 0,
          firstContext : p,
          responders : null
        };
      } else {
        current = current.next = p;
      }
    }
    return name._currentValue;
  }
  /**
   * @param {!Object} condition
   * @return {undefined}
   */
  function ok(condition) {
    condition.updateQueue = {
      baseState : condition.memoizedState,
      baseQueue : null,
      shared : {
        pending : null
      },
      effects : null
    };
  }
  /**
   * @param {!Object} data
   * @param {!Object} obj
   * @return {undefined}
   */
  function forEach(data, obj) {
    data = data.updateQueue;
    if (obj.updateQueue === data) {
      obj.updateQueue = {
        baseState : data.baseState,
        baseQueue : data.baseQueue,
        shared : data.shared,
        effects : data.effects
      };
    }
  }
  /**
   * @param {!Object} obj
   * @param {!Object} i
   * @return {?}
   */
  function parseInt(obj, i) {
    return (obj = {
      expirationTime : obj,
      suspenseConfig : i,
      tag : 0,
      payload : null,
      callback : null,
      next : null
    }).next = obj;
  }
  /**
   * @param {!Object} obj
   * @param {!Object} node
   * @return {undefined}
   */
  function copy(obj, node) {
    if (null !== (obj = obj.updateQueue)) {
      var afterBaseNode = (obj = obj.shared).pending;
      if (null === afterBaseNode) {
        /** @type {!Object} */
        node.next = node;
      } else {
        node.next = afterBaseNode.next;
        /** @type {!Object} */
        afterBaseNode.next = node;
      }
      /** @type {!Object} */
      obj.pending = node;
    }
  }
  /**
   * @param {!Object} self
   * @param {?} node
   * @return {undefined}
   */
  function reduce(self, node) {
    var state = self.alternate;
    if (null !== state) {
      forEach(state, self);
    }
    if (null === (state = (self = self.updateQueue).baseQueue)) {
      self.baseQueue = node.next = node;
      node.next = node;
    } else {
      node.next = state.next;
      state.next = node;
    }
  }
  /**
   * @param {!Object} value
   * @param {!Object} key
   * @param {!Object} index
   * @param {number} uri
   * @return {undefined}
   */
  function add(value, key, index, uri) {
    var self = value.updateQueue;
    /** @type {boolean} */
    layout = false;
    var parent = self.baseQueue;
    var obj = self.shared.pending;
    if (null !== obj) {
      if (null !== parent) {
        var node = parent.next;
        parent.next = obj.next;
        obj.next = node;
      }
      parent = obj;
      /** @type {null} */
      self.shared.pending = null;
      if (null !== (node = value.alternate)) {
        if (null !== (node = node.updateQueue)) {
          node.baseQueue = obj;
        }
      }
    }
    if (null !== parent) {
      node = parent.next;
      var data = self.baseState;
      /** @type {number} */
      var max = 0;
      /** @type {null} */
      var l = null;
      /** @type {null} */
      var id = null;
      /** @type {null} */
      var output = null;
      if (null !== node) {
        var item = node;
        for (;;) {
          if ((obj = item.expirationTime) < uri) {
            var result = {
              expirationTime : item.expirationTime,
              suspenseConfig : item.suspenseConfig,
              tag : item.tag,
              payload : item.payload,
              callback : item.callback,
              next : null
            };
            if (null === output) {
              id = output = result;
              l = data;
            } else {
              output = output.next = result;
            }
            if (obj > max) {
              max = obj;
            }
          } else {
            if (null !== output) {
              output = output.next = {
                expirationTime : 1073741823,
                suspenseConfig : item.suspenseConfig,
                tag : item.tag,
                payload : item.payload,
                callback : item.callback,
                next : null
              };
            }
            hash(obj, item.suspenseConfig);
            e: {
              /** @type {!Object} */
              var fn = value;
              var type = item;
              switch(obj = key, result = index, type.tag) {
                case 1:
                  if ("function" === typeof(fn = type.payload)) {
                    data = fn.call(result, data, obj);
                    break e;
                  }
                  data = fn;
                  break e;
                case 3:
                  /** @type {number} */
                  fn.effectTag = -4097 & fn.effectTag | 64;
                case 0:
                  if (null === (obj = "function" === typeof(fn = type.payload) ? fn.call(result, data, obj) : fn) || void 0 === obj) {
                    break e;
                  }
                  data = assign({}, data, obj);
                  break e;
                case 2:
                  /** @type {boolean} */
                  layout = true;
              }
            }
            if (null !== item.callback) {
              value.effectTag |= 32;
              if (null === (obj = self.effects)) {
                /** @type {!Array} */
                self.effects = [item];
              } else {
                obj.push(item);
              }
            }
          }
          if (null === (item = item.next) || item === node) {
            if (null === (obj = self.shared.pending)) {
              break;
            }
            item = parent.next = obj.next;
            obj.next = node;
            self.baseQueue = parent = obj;
            /** @type {null} */
            self.shared.pending = null;
          }
        }
      }
      if (null === output) {
        l = data;
      } else {
        /** @type {null} */
        output.next = id;
      }
      /** @type {null} */
      self.baseState = l;
      /** @type {(null|{callback: ??, expirationTime: number, next: (null|{callback: ??, expirationTime: ??, next: null, payload: ??, suspenseConfig: ??, tag: ??}|?), payload: ??, suspenseConfig: ??, tag: ??})} */
      self.baseQueue = output;
      isPresent(max);
      value.expirationTime = max;
      value.memoizedState = data;
    }
  }
  /**
   * @param {!Object} a
   * @param {!Object} d
   * @param {string} f
   * @return {undefined}
   */
  function hide(a, d, f) {
    if (a = d.effects, d.effects = null, null !== a) {
      /** @type {number} */
      d = 0;
      for (; d < a.length; d++) {
        var value = a[d];
        var j = value.callback;
        if (null !== j) {
          if (value.callback = null, value = j, j = f, "function" !== typeof value) {
            throw Error(call(191, value));
          }
          value.call(j);
        }
      }
    }
  }
  /**
   * @param {!Object} data
   * @param {(Object|string)} options
   * @param {!Array} id
   * @param {string} a
   * @return {undefined}
   */
  function find(data, options, id, a) {
    id = null === (id = id(a, options = data.memoizedState)) || void 0 === id ? options : assign({}, options, id);
    /** @type {!Array} */
    data.memoizedState = id;
    if (0 === data.expirationTime) {
      /** @type {!Array} */
      data.updateQueue.baseState = id;
    }
  }
  /**
   * @param {(Object|string)} obj
   * @param {!Object} Component
   * @param {undefined} props
   * @param {!Array} value
   * @param {undefined} item
   * @param {undefined} data
   * @param {?} context
   * @return {?}
   */
  function fetch(obj, Component, props, value, item, data, context) {
    return "function" === typeof(obj = obj.stateNode).shouldComponentUpdate ? obj.shouldComponentUpdate(value, data, context) : !Component.prototype || !Component.prototype.isPureReactComponent || (!next(props, value) || !next(item, data));
  }
  /**
   * @param {!Object} node
   * @param {!Object} options
   * @param {!Object} url
   * @return {?}
   */
  function connect(node, options, url) {
    /** @type {boolean} */
    var canvas_frame = false;
    var result = root;
    var context = options.contextType;
    return "object" === typeof context && null !== context ? context = require(context) : (result = isFunction(options) ? form : item.current, context = (canvas_frame = null !== (canvas_frame = options.contextTypes) && void 0 !== canvas_frame) ? $(node, result) : root), options = new options(url, context), node.memoizedState = null !== options.state && void 0 !== options.state ? options.state : null, options.updater = _, node.stateNode = options, options._reactInternalFiber = node, canvas_frame && 
    ((node = node.stateNode).__reactInternalMemoizedUnmaskedChildContext = result, node.__reactInternalMemoizedMaskedChildContext = context), options;
  }
  /**
   * @param {(Object|string)} value
   * @param {!Object} component
   * @param {?} props
   * @param {?} context
   * @return {undefined}
   */
  function setComponentProps(value, component, props, context) {
    value = component.state;
    if ("function" === typeof component.componentWillReceiveProps) {
      component.componentWillReceiveProps(props, context);
    }
    if ("function" === typeof component.UNSAFE_componentWillReceiveProps) {
      component.UNSAFE_componentWillReceiveProps(props, context);
    }
    if (component.state !== value) {
      _.enqueueReplaceState(component, component.state, null);
    }
  }
  /**
   * @param {!Object} obj
   * @param {(Object|string)} options
   * @param {!Object} value
   * @param {number} hash
   * @return {undefined}
   */
  function create(obj, options, value, hash) {
    var self = obj.stateNode;
    /** @type {!Object} */
    self.props = value;
    self.state = obj.memoizedState;
    self.refs = refs;
    ok(obj);
    var data = options.contextType;
    if ("object" === typeof data && null !== data) {
      self.context = require(data);
    } else {
      data = isFunction(options) ? form : item.current;
      self.context = $(obj, data);
    }
    add(obj, value, self, hash);
    self.state = obj.memoizedState;
    if ("function" === typeof(data = options.getDerivedStateFromProps)) {
      find(obj, options, data, value);
      self.state = obj.memoizedState;
    }
    if (!("function" === typeof options.getDerivedStateFromProps || "function" === typeof self.getSnapshotBeforeUpdate || "function" !== typeof self.UNSAFE_componentWillMount && "function" !== typeof self.componentWillMount)) {
      options = self.state;
      if ("function" === typeof self.componentWillMount) {
        self.componentWillMount();
      }
      if ("function" === typeof self.UNSAFE_componentWillMount) {
        self.UNSAFE_componentWillMount();
      }
      if (options !== self.state) {
        _.enqueueReplaceState(self, self.state, null);
      }
      add(obj, value, self, hash);
      self.state = obj.memoizedState;
    }
    if ("function" === typeof self.componentDidMount) {
      obj.effectTag |= 4;
    }
  }
  /**
   * @param {string} name
   * @param {!Object} e
   * @param {!Object} node
   * @return {?}
   */
  function set(name, e, node) {
    if (null !== (name = node.ref) && "function" !== typeof name && "object" !== typeof name) {
      if (node._owner) {
        if (node = node._owner) {
          if (1 !== node.tag) {
            throw Error(call(309));
          }
          var group = node.stateNode;
        }
        if (!group) {
          throw Error(call(147, name));
        }
        /** @type {string} */
        var i = "" + name;
        return null !== e && null !== e.ref && "function" === typeof e.ref && e.ref._stringRef === i ? e.ref : ((e = function(t) {
          var items = group.refs;
          if (items === refs) {
            items = group.refs = {};
          }
          if (null === t) {
            delete items[i];
          } else {
            /** @type {!Object} */
            items[i] = t;
          }
        })._stringRef = i, e);
      }
      if ("string" !== typeof name) {
        throw Error(call(284));
      }
      if (!node._owner) {
        throw Error(call(290, name));
      }
    }
    return name;
  }
  /**
   * @param {!Object} obj
   * @param {!Object} item
   * @return {undefined}
   */
  function contains(obj, item) {
    if ("textarea" !== obj.type) {
      throw Error(call(31, "[object Object]" === Object.prototype.toString.call(item) ? "object with keys {" + Object.keys(item).join(", ") + "}" : item, ""));
    }
  }
  /**
   * @param {string} flag
   * @return {?}
   */
  function run(flag) {
    /**
     * @param {!Object} t
     * @param {string} start
     * @return {undefined}
     */
    function next(t, start) {
      if (flag) {
        var current = t.lastEffect;
        if (null !== current) {
          /** @type {string} */
          current.nextEffect = start;
          /** @type {string} */
          t.lastEffect = start;
        } else {
          t.firstEffect = t.lastEffect = start;
        }
        /** @type {null} */
        start.nextEffect = null;
        /** @type {number} */
        start.effectTag = 8;
      }
    }
    /**
     * @param {!Object} text
     * @param {string} node
     * @return {?}
     */
    function done(text, node) {
      if (!flag) {
        return null;
      }
      for (; null !== node;) {
        next(text, node);
        node = node.sibling;
      }
      return null;
    }
    /**
     * @param {!Object} result
     * @param {!Object} node
     * @return {?}
     */
    function parse(result, node) {
      /** @type {!Map} */
      result = new Map;
      for (; null !== node;) {
        if (null !== node.key) {
          result.set(node.key, node);
        } else {
          result.set(node.index, node);
        }
        node = node.sibling;
      }
      return result;
    }
    /**
     * @param {!Object} obj
     * @param {!Object} val
     * @return {?}
     */
    function callback(obj, val) {
      return (obj = send(obj, val)).index = 0, obj.sibling = null, obj;
    }
    /**
     * @param {!Object} obj
     * @param {!Object} s
     * @param {string} a
     * @return {?}
     */
    function recurse(obj, s, a) {
      return obj.index = a, flag ? null !== (a = obj.alternate) ? (a = a.index) < s ? (obj.effectTag = 2, s) : a : (obj.effectTag = 2, s) : s;
    }
    /**
     * @param {!Object} item
     * @return {?}
     */
    function update(item) {
      return flag && null === item.alternate && (item.effectTag = 2), item;
    }
    /**
     * @param {string} value
     * @param {!Object} result
     * @param {!Object} r
     * @param {!Object} p
     * @return {?}
     */
    function cb(value, result, r, p) {
      return null === result || 6 !== result.tag ? ((result = cb(r, value.mode, p)).return = value, result) : ((result = callback(result, r)).return = value, result);
    }
    /**
     * @param {string} key
     * @param {!Object} target
     * @param {!Object} value
     * @param {!Object} result
     * @return {?}
     */
    function handler(key, target, value, result) {
      return null !== target && target.elementType === value.type ? ((result = callback(target, value.props)).ref = set(key, target, value), result.return = key, result) : ((result = func(value.type, value.key, value.props, null, key.mode, result)).ref = set(key, target, value), result.return = key, result);
    }
    /**
     * @param {string} value
     * @param {!Object} node
     * @param {!Object} type
     * @param {!Object} name
     * @return {?}
     */
    function factory(value, node, type, name) {
      return null === node || 4 !== node.tag || node.stateNode.containerInfo !== type.containerInfo || node.stateNode.implementation !== type.implementation ? ((node = change(type, value.mode, name)).return = value, node) : ((node = callback(node, type.children || [])).return = value, node);
    }
    /**
     * @param {string} v
     * @param {!Object} r
     * @param {!Object} e
     * @param {!Object} data
     * @param {!Object} id
     * @return {?}
     */
    function fn(v, r, e, data, id) {
      return null === r || 7 !== r.tag ? ((r = format(e, v.mode, data, id)).return = v, r) : ((r = callback(r, e)).return = v, r);
    }
    /**
     * @param {string} target
     * @param {!Object} value
     * @param {!Object} data
     * @return {?}
     */
    function create(target, value, data) {
      if ("string" === typeof value || "number" === typeof value) {
        return (value = cb("" + value, target.mode, data)).return = target, value;
      }
      if ("object" === typeof value && null !== value) {
        switch(value.$$typeof) {
          case buffer:
            return (data = func(value.type, value.key, value.props, null, target.mode, data)).ref = set(target, null, value), data.return = target, data;
          case array:
            return (value = change(value, target.mode, data)).return = target, value;
        }
        if (isArray(value) || isPlainObject(value)) {
          return (value = format(value, target.mode, data, null)).return = target, value;
        }
        contains(target, value);
      }
      return null;
    }
    /**
     * @param {string} item
     * @param {!Object} options
     * @param {!Object} value
     * @param {!Object} i
     * @return {?}
     */
    function get(item, options, value, i) {
      var undefined = null !== options ? options.key : null;
      if ("string" === typeof value || "number" === typeof value) {
        return null !== undefined ? null : cb(item, options, "" + value, i);
      }
      if ("object" === typeof value && null !== value) {
        switch(value.$$typeof) {
          case buffer:
            return value.key === undefined ? value.type === string ? fn(item, options, value.props.children, i, undefined) : handler(item, options, value, i) : null;
          case array:
            return value.key === undefined ? factory(item, options, value, i) : null;
        }
        if (isArray(value) || isPlainObject(value)) {
          return null !== undefined ? null : fn(item, options, value, i, null);
        }
        contains(item, value);
      }
      return null;
    }
    /**
     * @param {string} data
     * @param {string} x
     * @param {!Function} key
     * @param {!Object} value
     * @param {!Object} i
     * @return {?}
     */
    function f(data, x, key, value, i) {
      if ("string" === typeof value || "number" === typeof value) {
        return cb(x, data = data.get(key) || null, "" + value, i);
      }
      if ("object" === typeof value && null !== value) {
        switch(value.$$typeof) {
          case buffer:
            return data = data.get(null === value.key ? key : value.key) || null, value.type === string ? fn(x, data, value.props.children, i, value.key) : handler(x, data, value, i);
          case array:
            return factory(x, data = data.get(null === value.key ? key : value.key) || null, value, i);
        }
        if (isArray(value) || isPlainObject(value)) {
          return fn(x, data = data.get(key) || null, value, i, null);
        }
        contains(x, value);
      }
      return null;
    }
    /**
     * @param {string} value
     * @param {!Object} key
     * @param {!Object} args
     * @param {!Object} context
     * @return {?}
     */
    function add(value, key, args, context) {
      /** @type {null} */
      var result = null;
      /** @type {null} */
      var prev = null;
      /** @type {!Object} */
      var node = key;
      /** @type {number} */
      var i = key = 0;
      /** @type {null} */
      var obj = null;
      for (; null !== node && i < args.length; i++) {
        if (node.index > i) {
          obj = node;
          /** @type {null} */
          node = null;
        } else {
          obj = node.sibling;
        }
        var n = get(value, node, args[i], context);
        if (null === n) {
          if (null === node) {
            /** @type {null} */
            node = obj;
          }
          break;
        }
        if (flag && node && null === n.alternate) {
          next(value, node);
        }
        key = recurse(n, key, i);
        if (null === prev) {
          result = n;
        } else {
          prev.sibling = n;
        }
        prev = n;
        /** @type {null} */
        node = obj;
      }
      if (i === args.length) {
        return done(value, node), result;
      }
      if (null === node) {
        for (; i < args.length; i++) {
          if (null !== (node = create(value, args[i], context))) {
            key = recurse(node, key, i);
            if (null === prev) {
              result = node;
            } else {
              prev.sibling = node;
            }
            prev = node;
          }
        }
        return result;
      }
      node = parse(value, node);
      for (; i < args.length; i++) {
        if (null !== (obj = f(node, value, i, args[i], context))) {
          if (flag && null !== obj.alternate) {
            node.delete(null === obj.key ? i : obj.key);
          }
          key = recurse(obj, key, i);
          if (null === prev) {
            result = obj;
          } else {
            prev.sibling = obj;
          }
          prev = obj;
        }
      }
      return flag && node.forEach(function(testUploadId) {
        return next(value, testUploadId);
      }), result;
    }
    /**
     * @param {string} data
     * @param {!Object} val
     * @param {!Object} source
     * @param {!Object} context
     * @return {?}
     */
    function check(data, val, source, context) {
      var object = isPlainObject(source);
      if ("function" !== typeof object) {
        throw Error(call(150));
      }
      if (null == (source = object.call(source))) {
        throw Error(call(151));
      }
      /** @type {null} */
      var result = object = null;
      /** @type {!Object} */
      var node = val;
      /** @type {number} */
      var i = val = 0;
      /** @type {null} */
      var child = null;
      var obj = source.next();
      for (; null !== node && !obj.done; i++, obj = source.next()) {
        if (node.index > i) {
          child = node;
          /** @type {null} */
          node = null;
        } else {
          child = node.sibling;
        }
        var value = get(data, node, obj.value, context);
        if (null === value) {
          if (null === node) {
            /** @type {null} */
            node = child;
          }
          break;
        }
        if (flag && node && null === value.alternate) {
          next(data, node);
        }
        val = recurse(value, val, i);
        if (null === result) {
          object = value;
        } else {
          result.sibling = value;
        }
        result = value;
        /** @type {null} */
        node = child;
      }
      if (obj.done) {
        return done(data, node), object;
      }
      if (null === node) {
        for (; !obj.done; i++, obj = source.next()) {
          if (null !== (obj = create(data, obj.value, context))) {
            val = recurse(obj, val, i);
            if (null === result) {
              object = obj;
            } else {
              result.sibling = obj;
            }
            result = obj;
          }
        }
        return object;
      }
      node = parse(data, node);
      for (; !obj.done; i++, obj = source.next()) {
        if (null !== (obj = f(node, data, i, obj.value, context))) {
          if (flag && null !== obj.alternate) {
            node.delete(null === obj.key ? i : obj.key);
          }
          val = recurse(obj, val, i);
          if (null === result) {
            object = obj;
          } else {
            result.sibling = obj;
          }
          result = obj;
        }
      }
      return flag && node.forEach(function(testUploadId) {
        return next(data, testUploadId);
      }), object;
    }
    return function(item, result, value, data) {
      /** @type {boolean} */
      var node = "object" === typeof value && null !== value && value.type === string && null === value.key;
      if (node) {
        value = value.props.children;
      }
      /** @type {boolean} */
      var key = "object" === typeof value && null !== value;
      if (key) {
        switch(value.$$typeof) {
          case buffer:
            e: {
              key = value.key;
              /** @type {!Object} */
              node = result;
              for (; null !== node;) {
                if (node.key === key) {
                  switch(node.tag) {
                    case 7:
                      if (value.type === string) {
                        done(item, node.sibling);
                        /** @type {!Object} */
                        (result = callback(node, value.props.children)).return = item;
                        /** @type {!Object} */
                        item = result;
                        break e;
                      }
                      break;
                    default:
                      if (node.elementType === value.type) {
                        done(item, node.sibling);
                        (result = callback(node, value.props)).ref = set(item, node, value);
                        /** @type {!Object} */
                        result.return = item;
                        /** @type {!Object} */
                        item = result;
                        break e;
                      }
                  }
                  done(item, node);
                  break;
                }
                next(item, node);
                node = node.sibling;
              }
              if (value.type === string) {
                /** @type {!Object} */
                (result = format(value.props.children, item.mode, data, value.key)).return = item;
                /** @type {!Object} */
                item = result;
              } else {
                (data = func(value.type, value.key, value.props, null, item.mode, data)).ref = set(item, result, value);
                /** @type {!Object} */
                data.return = item;
                /** @type {!Object} */
                item = data;
              }
            }
            return update(item);
          case array:
            e: {
              node = value.key;
              for (; null !== result;) {
                if (result.key === node) {
                  if (4 === result.tag && result.stateNode.containerInfo === value.containerInfo && result.stateNode.implementation === value.implementation) {
                    done(item, result.sibling);
                    /** @type {!Object} */
                    (result = callback(result, value.children || [])).return = item;
                    /** @type {!Object} */
                    item = result;
                    break e;
                  }
                  done(item, result);
                  break;
                }
                next(item, result);
                result = result.sibling;
              }
              /** @type {!Object} */
              (result = change(value, item.mode, data)).return = item;
              /** @type {!Object} */
              item = result;
            }
            return update(item);
        }
      }
      if ("string" === typeof value || "number" === typeof value) {
        return value = "" + value, null !== result && 6 === result.tag ? (done(item, result.sibling), (result = callback(result, value)).return = item, item = result) : (done(item, result), (result = cb(value, item.mode, data)).return = item, item = result), update(item);
      }
      if (isArray(value)) {
        return add(item, result, value, data);
      }
      if (isPlainObject(value)) {
        return check(item, result, value, data);
      }
      if (key && contains(item, value), "undefined" === typeof value && !node) {
        switch(item.tag) {
          case 1:
          case 0:
            throw item = item.type, Error(call(152, item.displayName || item.name || "Component"));
        }
      }
      return done(item, result);
    };
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function translate(value) {
    if (value === rate) {
      throw Error(call(174));
    }
    return value;
  }
  /**
   * @param {?} a
   * @param {!Object} b
   * @return {undefined}
   */
  function height(a, b) {
    switch(indexOf(ret, b), indexOf(element, a), indexOf(request, rate), a = b.nodeType) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : Number(null, "");
        break;
      default:
        b = Number(b = (a = 8 === a ? b.parentNode : b).namespaceURI || null, a = a.tagName);
    }
    isString(request);
    indexOf(request, b);
  }
  /**
   * @return {undefined}
   */
  function msgHasId() {
    isString(request);
    isString(element);
    isString(ret);
  }
  /**
   * @param {?} node
   * @return {undefined}
   */
  function calculateLargestZIndex(node) {
    translate(ret.current);
    var result = translate(request.current);
    var value = Number(result, node.type);
    if (result !== value) {
      indexOf(element, node);
      indexOf(request, value);
    }
  }
  /**
   * @param {!Object} item
   * @return {undefined}
   */
  function updateGroupInfoItem(item) {
    if (element.current === item) {
      isString(request);
      isString(element);
    }
  }
  /**
   * @param {!Object} parent
   * @return {?}
   */
  function list(parent) {
    /** @type {!Object} */
    var node = parent;
    for (; null !== node;) {
      if (13 === node.tag) {
        var s = node.memoizedState;
        if (null !== s && (null === (s = s.dehydrated) || "$?" === s.data || "$!" === s.data)) {
          return node;
        }
      } else {
        if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
          if (0 !== (64 & node.effectTag)) {
            return node;
          }
        } else {
          if (null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        }
      }
      if (node === parent) {
        break;
      }
      for (; null === node.sibling;) {
        if (null === node.return || node.return === parent) {
          return null;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  /**
   * @param {!Function} value
   * @param {?} prop
   * @return {?}
   */
  function setToSystem(value, prop) {
    return {
      responder : value,
      props : prop
    };
  }
  /**
   * @return {?}
   */
  function LOFOX() {
    throw Error(call(321));
  }
  /**
   * @param {!Array} a
   * @param {!Array} b
   * @return {?}
   */
  function sameDeps(a, b) {
    if (null === b) {
      return false;
    }
    /** @type {number} */
    var i = 0;
    for (; i < b.length && i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  /**
   * @param {!Object} res
   * @param {!Object} data
   * @param {?} callback
   * @param {!Object} response
   * @param {?} args
   * @param {number} value
   * @return {?}
   */
  function execute(res, data, callback, response, args, value) {
    if (temp = value, options = data, data.memoizedState = null, data.updateQueue = null, data.expirationTime = 0, water.current = null === res || null === res.memoizedState ? pageX : retryCounter, res = callback(response, args), data.expirationTime === temp) {
      /** @type {number} */
      value = 0;
      do {
        if (data.expirationTime = 0, !(25 > value)) {
          throw Error(call(301));
        }
        /** @type {number} */
        value = value + 1;
        /** @type {null} */
        ctx = message = null;
        /** @type {null} */
        data.updateQueue = null;
        water.current = h2o;
        res = callback(response, args);
      } while (data.expirationTime === temp);
    }
    if (water.current = old, data = null !== message && null !== message.next, temp = 0, ctx = message = options = null, Vo = false, data) {
      throw Error(call(300));
    }
    return res;
  }
  /**
   * @return {?}
   */
  function jQuery() {
    var undefined = {
      memoizedState : null,
      baseState : null,
      baseQueue : null,
      queue : null,
      next : null
    };
    return null === ctx ? options.memoizedState = ctx = undefined : ctx = ctx.next = undefined, ctx;
  }
  /**
   * @return {?}
   */
  function restore() {
    if (null === message) {
      var context = options.alternate;
      context = null !== context ? context.memoizedState : null;
    } else {
      context = message.next;
    }
    var opt_handler = null === ctx ? options.memoizedState : ctx.next;
    if (null !== opt_handler) {
      ctx = opt_handler;
      message = context;
    } else {
      if (null === context) {
        throw Error(call(310));
      }
      context = {
        memoizedState : (message = context).memoizedState,
        baseState : message.baseState,
        baseQueue : message.baseQueue,
        queue : message.queue,
        next : null
      };
      if (null === ctx) {
        options.memoizedState = ctx = context;
      } else {
        ctx = ctx.next = context;
      }
    }
    return ctx;
  }
  /**
   * @param {string} value
   * @param {string} fn
   * @return {?}
   */
  function context(value, fn) {
    return "function" === typeof fn ? fn(value) : fn;
  }
  /**
   * @param {!Function} error
   * @return {?}
   */
  function resolve(error) {
    var self = restore();
    var queue = self.queue;
    if (null === queue) {
      throw Error(call(311));
    }
    /** @type {!Function} */
    queue.lastRenderedReducer = error;
    var node = message;
    var t = node.baseQueue;
    var i = queue.pending;
    if (null !== i) {
      if (null !== t) {
        var n = t.next;
        t.next = i.next;
        i.next = n;
      }
      node.baseQueue = t = i;
      /** @type {null} */
      queue.pending = null;
    }
    if (null !== t) {
      t = t.next;
      node = node.baseState;
      /** @type {null} */
      var result = n = i = null;
      var v = t;
      do {
        var i = v.expirationTime;
        if (i < temp) {
          var e = {
            expirationTime : v.expirationTime,
            suspenseConfig : v.suspenseConfig,
            action : v.action,
            eagerReducer : v.eagerReducer,
            eagerState : v.eagerState,
            next : null
          };
          if (null === result) {
            n = result = e;
            i = node;
          } else {
            result = result.next = e;
          }
          if (i > options.expirationTime) {
            options.expirationTime = i;
            isPresent(i);
          }
        } else {
          if (null !== result) {
            result = result.next = {
              expirationTime : 1073741823,
              suspenseConfig : v.suspenseConfig,
              action : v.action,
              eagerReducer : v.eagerReducer,
              eagerState : v.eagerState,
              next : null
            };
          }
          hash(i, v.suspenseConfig);
          node = v.eagerReducer === error ? v.eagerState : error(node, v.action);
        }
        v = v.next;
      } while (null !== v && v !== t);
      if (null === result) {
        i = node;
      } else {
        /** @type {null} */
        result.next = n;
      }
      if (!deepEqual(node, self.memoizedState)) {
        /** @type {boolean} */
        property = true;
      }
      self.memoizedState = node;
      /** @type {null} */
      self.baseState = i;
      /** @type {(null|{action: ??, eagerReducer: ??, eagerState: ??, expirationTime: number, next: (null|{action: ??, eagerReducer: ??, eagerState: ??, expirationTime: ??, next: null, suspenseConfig: ??}|?), suspenseConfig: ??})} */
      self.baseQueue = result;
      queue.lastRenderedState = node;
    }
    return [self.memoizedState, queue.dispatch];
  }
  /**
   * @param {!Function} fn
   * @return {?}
   */
  function clear(fn) {
    var output = restore();
    var result = output.queue;
    if (null === result) {
      throw Error(call(311));
    }
    /** @type {!Function} */
    result.lastRenderedReducer = fn;
    var courseSections = result.dispatch;
    var p = result.pending;
    var key = output.memoizedState;
    if (null !== p) {
      /** @type {null} */
      result.pending = null;
      var f = p = p.next;
      do {
        key = fn(key, f.action);
        f = f.next;
      } while (f !== p);
      if (!deepEqual(key, output.memoizedState)) {
        /** @type {boolean} */
        property = true;
      }
      output.memoizedState = key;
      if (null === output.baseQueue) {
        output.baseState = key;
      }
      result.lastRenderedState = key;
    }
    return [key, courseSections];
  }
  /**
   * @param {!Function} callback
   * @return {?}
   */
  function click(callback) {
    var self = jQuery();
    return "function" === typeof callback && (callback = callback()), self.memoizedState = self.baseState = callback, callback = (callback = self.queue = {
      pending : null,
      dispatch : null,
      lastRenderedReducer : context,
      lastRenderedState : callback
    }).dispatch = join.bind(null, options, callback), [self.memoizedState, callback];
  }
  /**
   * @param {!Object} data
   * @param {string} res
   * @param {!Object} node
   * @param {!Array} obj
   * @return {?}
   */
  function generate(data, res, node, obj) {
    return data = {
      tag : data,
      create : res,
      destroy : node,
      deps : obj,
      next : null
    }, null === (res = options.updateQueue) ? (res = {
      lastEffect : null
    }, options.updateQueue = res, res.lastEffect = data.next = data) : null === (node = res.lastEffect) ? res.lastEffect = data.next = data : (obj = node.next, node.next = data, data.next = obj, res.lastEffect = data), data;
  }
  /**
   * @return {?}
   */
  function findBlocksToIndentFromRange() {
    return restore().memoizedState;
  }
  /**
   * @param {number} v
   * @param {number} e
   * @param {!Function} cb
   * @param {?} string
   * @return {undefined}
   */
  function fire(v, e, cb, string) {
    var current = jQuery();
    options.effectTag |= v;
    current.memoizedState = generate(1 | e, cb, void 0, void 0 === string ? null : string);
  }
  /**
   * @param {number} callback
   * @param {number} type
   * @param {!Function} name
   * @param {?} data
   * @return {?}
   */
  function createToken(callback, type, name, data) {
    var node = restore();
    data = void 0 === data ? null : data;
    var i = void 0;
    if (null !== message) {
      var row = message.memoizedState;
      if (i = row.destroy, null !== data && sameDeps(data, row.deps)) {
        return void generate(type, name, i, data);
      }
    }
    options.effectTag |= callback;
    node.memoizedState = generate(1 | type, name, i, data);
  }
  /**
   * @param {!Function} data
   * @param {!Array} e
   * @return {?}
   */
  function pluginHandle(data, e) {
    return fire(516, 4, data, e);
  }
  /**
   * @param {!Function} name
   * @param {!Array} start
   * @return {?}
   */
  function interpolate(name, start) {
    return createToken(516, 4, name, start);
  }
  /**
   * @param {!Function} name
   * @param {!Array} fn
   * @return {?}
   */
  function open(name, fn) {
    return createToken(4, 2, name, fn);
  }
  /**
   * @param {string} data
   * @param {!Object} callback
   * @return {?}
   */
  function go(data, callback) {
    return "function" === typeof callback ? (data = data(), callback(data), function() {
      callback(null);
    }) : null !== callback && void 0 !== callback ? (data = data(), callback.current = data, function() {
      /** @type {null} */
      callback.current = null;
    }) : void 0;
  }
  /**
   * @param {!Function} value
   * @param {!Array} key
   * @param {?} fn
   * @return {?}
   */
  function enter(value, key, fn) {
    return fn = null !== fn && void 0 !== fn ? fn.concat([value]) : null, createToken(4, 2, go.bind(null, key, value), fn);
  }
  /**
   * @return {undefined}
   */
  function ca() {
  }
  /**
   * @param {!Function} name
   * @param {?} a
   * @return {?}
   */
  function spawn(name, a) {
    return jQuery().memoizedState = [name, void 0 === a ? null : a], name;
  }
  /**
   * @param {!Function} arg
   * @param {?} name
   * @return {?}
   */
  function insert(arg, name) {
    var $scope = restore();
    name = void 0 === name ? null : name;
    var originalName = $scope.memoizedState;
    return null !== originalName && null !== name && sameDeps(name, originalName[1]) ? originalName[0] : ($scope.memoizedState = [arg, name], arg);
  }
  /**
   * @param {!Function} callback
   * @param {?} id
   * @return {?}
   */
  function extractPresetLocal(callback, id) {
    var fiber = restore();
    id = void 0 === id ? null : id;
    var type = fiber.memoizedState;
    return null !== type && null !== id && sameDeps(id, type[1]) ? type[0] : (callback = callback(), fiber.memoizedState = [callback, id], callback);
  }
  /**
   * @param {?} handler
   * @param {number} data
   * @param {?} cb
   * @return {undefined}
   */
  function plugin(handler, data, cb) {
    var next = then();
    drop(98 > next ? 98 : next, function() {
      handler(true);
    });
    drop(97 < next ? 97 : next, function() {
      var originalBackFunction = $rootScope.suspense;
      $rootScope.suspense = void 0 === data ? null : data;
      try {
        handler(false);
        cb();
      } finally {
        $rootScope.suspense = originalBackFunction;
      }
    });
  }
  /**
   * @param {!Object} value
   * @param {!Object} action
   * @param {string} key
   * @return {undefined}
   */
  function join(value, action, key) {
    var result = parseFloat();
    var args = config.suspense;
    args = {
      expirationTime : result = map(result, value, args),
      suspenseConfig : args,
      action : key,
      eagerReducer : null,
      eagerState : null,
      next : null
    };
    var data = action.pending;
    if (null === data ? args.next = args : (args.next = data.next, data.next = args), action.pending = args, data = value.alternate, value === options || null !== data && data === options) {
      /** @type {boolean} */
      Vo = true;
      args.expirationTime = temp;
      options.expirationTime = temp;
    } else {
      if (0 === value.expirationTime && (null === data || 0 === data.expirationTime) && null !== (data = action.lastRenderedReducer)) {
        try {
          var item = action.lastRenderedState;
          var a = data(item, key);
          if (args.eagerReducer = data, args.eagerState = a, deepEqual(a, item)) {
            return;
          }
        } catch (f) {
        }
      }
      test(value, result);
    }
  }
  /**
   * @param {string} value
   * @param {?} el
   * @return {undefined}
   */
  function trim(value, el) {
    var node = f(5, null, null, 0);
    /** @type {string} */
    node.elementType = "DELETED";
    /** @type {string} */
    node.type = "DELETED";
    node.stateNode = el;
    /** @type {string} */
    node.return = value;
    /** @type {number} */
    node.effectTag = 8;
    if (null !== value.lastEffect) {
      value.lastEffect.nextEffect = node;
      value.lastEffect = node;
    } else {
      value.firstEffect = value.lastEffect = node;
    }
  }
  /**
   * @param {!Object} node
   * @param {!Object} parent
   * @return {?}
   */
  function addNode(node, parent) {
    switch(node.tag) {
      case 5:
        var type = node.type;
        return null !== (parent = 1 !== parent.nodeType || type.toLowerCase() !== parent.nodeName.toLowerCase() ? null : parent) && (node.stateNode = parent, true);
      case 6:
        return null !== (parent = "" === node.pendingProps || 3 !== parent.nodeType ? null : parent) && (node.stateNode = parent, true);
      case 13:
      default:
        return false;
    }
  }
  /**
   * @param {!Object} v
   * @return {?}
   */
  function reducer(v) {
    if (abort) {
      var node = nextNode;
      if (node) {
        var el = node;
        if (!addNode(v, node)) {
          if (!(node = insertBefore(el.nextSibling)) || !addNode(v, node)) {
            return v.effectTag = -1025 & v.effectTag | 2, abort = false, void(before = v);
          }
          trim(before, el);
        }
        /** @type {!Object} */
        before = v;
        nextNode = insertBefore(node.firstChild);
      } else {
        /** @type {number} */
        v.effectTag = -1025 & v.effectTag | 2;
        /** @type {boolean} */
        abort = false;
        /** @type {!Object} */
        before = v;
      }
    }
  }
  /**
   * @param {!Object} value
   * @return {undefined}
   */
  function read(value) {
    value = value.return;
    for (; null !== value && 5 !== value.tag && 3 !== value.tag && 13 !== value.tag;) {
      value = value.return;
    }
    /** @type {!Object} */
    before = value;
  }
  /**
   * @param {!Object} node
   * @return {?}
   */
  function walk(node) {
    if (node !== before) {
      return false;
    }
    if (!abort) {
      return read(node), abort = true, false;
    }
    var child = node.type;
    if (5 !== node.tag || "head" !== child && "body" !== child && !walker(child, node.memoizedProps)) {
      child = nextNode;
      for (; child;) {
        trim(node, child);
        child = insertBefore(child.nextSibling);
      }
    }
    if (read(node), 13 === node.tag) {
      if (!(node = null !== (node = node.memoizedState) ? node.dehydrated : null)) {
        throw Error(call(317));
      }
      e: {
        node = node.nextSibling;
        /** @type {number} */
        child = 0;
        for (; node;) {
          if (8 === node.nodeType) {
            var v = node.data;
            if ("/$" === v) {
              if (0 === child) {
                nextNode = insertBefore(node.nextSibling);
                break e;
              }
              child--;
            } else {
              if (!("$" !== v && "$!" !== v && "$?" !== v)) {
                child++;
              }
            }
          }
          node = node.nextSibling;
        }
        /** @type {null} */
        nextNode = null;
      }
    } else {
      nextNode = before ? insertBefore(node.stateNode.nextSibling) : null;
    }
    return true;
  }
  /**
   * @return {undefined}
   */
  function updateGameInfoEdit() {
    /** @type {null} */
    nextNode = before = null;
    /** @type {boolean} */
    abort = false;
  }
  /**
   * @param {!Object} object
   * @param {!Object} value
   * @param {?} options
   * @param {?} obj
   * @return {undefined}
   */
  function debug(object, value, options, obj) {
    value.child = null === object ? x(value, null, options, obj) : fn(value, object.child, options, obj);
  }
  /**
   * @param {!Object} data
   * @param {!Object} value
   * @param {(Object|string)} options
   * @param {!Object} result
   * @param {number} key
   * @return {?}
   */
  function configure(data, value, options, result, key) {
    options = options.render;
    var callback = value.ref;
    return report(value, key), result = execute(data, value, options, result, callback, key), null === data || property ? (value.effectTag |= 1, debug(data, value, result, key), value.child) : (value.updateQueue = data.updateQueue, value.effectTag &= -517, data.expirationTime <= key && (data.expirationTime = 0), replace(data, value, key));
  }
  /**
   * @param {!Object} value
   * @param {!Object} node
   * @param {!Object} obj
   * @param {undefined} key
   * @param {undefined} name
   * @param {number} data
   * @return {?}
   */
  function patch(value, node, obj, key, name, data) {
    if (null === value) {
      var i = obj.type;
      return "function" !== typeof i || createElement(i) || void 0 !== i.defaultProps || null !== obj.compare || void 0 !== obj.defaultProps ? ((value = func(obj.type, null, key, null, node.mode, data)).ref = node.ref, value.return = node, node.child = value) : (node.tag = 15, node.type = i, validate(value, node, i, key, name, data));
    }
    return i = value.child, name < data && (name = i.memoizedProps, (obj = null !== (obj = obj.compare) ? obj : next)(name, key) && value.ref === node.ref) ? replace(value, node, data) : (node.effectTag |= 1, (value = send(i, key)).ref = node.ref, value.return = node, node.child = value);
  }
  /**
   * @param {!Object} value
   * @param {!Object} data
   * @param {?} node
   * @param {!Array} options
   * @param {number} index
   * @param {number} i
   * @return {?}
   */
  function validate(value, data, node, options, index, i) {
    return null !== value && next(value.memoizedProps, options) && value.ref === data.ref && (property = false, index < i) ? (data.expirationTime = value.expirationTime, replace(value, data, i)) : remove(value, data, node, options, i);
  }
  /**
   * @param {!Object} data
   * @param {!Object} el
   * @return {undefined}
   */
  function inject(data, el) {
    var a = el.ref;
    if (null === data && null !== a || null !== data && data.ref !== a) {
      el.effectTag |= 128;
    }
  }
  /**
   * @param {!Object} data
   * @param {!Object} key
   * @param {?} result
   * @param {!Object} res
   * @param {number} value
   * @return {?}
   */
  function remove(data, key, result, res, value) {
    var i = isFunction(result) ? form : item.current;
    return i = $(key, i), report(key, value), result = execute(data, key, result, res, i, value), null === data || property ? (key.effectTag |= 1, debug(data, key, result, value), key.child) : (key.updateQueue = data.updateQueue, key.effectTag &= -517, data.expirationTime <= value && (data.expirationTime = 0), replace(data, key, value));
  }
  /**
   * @param {!Object} current
   * @param {!Object} node
   * @param {(Object|string)} options
   * @param {?} callback
   * @param {number} value
   * @return {?}
   */
  function renderComponent(current, node, options, callback, value) {
    if (isFunction(options)) {
      /** @type {boolean} */
      var OasisMessageChannel = true;
      replaceChild(node);
    } else {
      /** @type {boolean} */
      OasisMessageChannel = false;
    }
    if (report(node, value), null === node.stateNode) {
      if (null !== current) {
        /** @type {null} */
        current.alternate = null;
        /** @type {null} */
        node.alternate = null;
        node.effectTag |= 2;
      }
      connect(node, options, callback);
      create(node, options, callback, value);
      /** @type {boolean} */
      callback = true;
    } else {
      if (null === current) {
        var instance = node.stateNode;
        var name = node.memoizedProps;
        instance.props = name;
        var data = instance.context;
        var context = options.contextType;
        if ("object" === typeof context && null !== context) {
          context = require(context);
        } else {
          context = $(node, context = isFunction(options) ? form : item.current);
        }
        var type = options.getDerivedStateFromProps;
        /** @type {boolean} */
        var l = "function" === typeof type || "function" === typeof instance.getSnapshotBeforeUpdate;
        if (!(l || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps)) {
          if (name !== callback || data !== context) {
            setComponentProps(node, instance, callback, context);
          }
        }
        /** @type {boolean} */
        layout = false;
        var key = node.memoizedState;
        instance.state = key;
        add(node, callback, instance, value);
        data = node.memoizedState;
        if (name !== callback || key !== data || nodeList.current || layout) {
          if ("function" === typeof type) {
            find(node, options, type, callback);
            data = node.memoizedState;
          }
          if (name = layout || fetch(node, options, name, callback, key, data, context)) {
            if (!(l || "function" !== typeof instance.UNSAFE_componentWillMount && "function" !== typeof instance.componentWillMount)) {
              if ("function" === typeof instance.componentWillMount) {
                instance.componentWillMount();
              }
              if ("function" === typeof instance.UNSAFE_componentWillMount) {
                instance.UNSAFE_componentWillMount();
              }
            }
            if ("function" === typeof instance.componentDidMount) {
              node.effectTag |= 4;
            }
          } else {
            if ("function" === typeof instance.componentDidMount) {
              node.effectTag |= 4;
            }
            node.memoizedProps = callback;
            node.memoizedState = data;
          }
          instance.props = callback;
          instance.state = data;
          instance.context = context;
          callback = name;
        } else {
          if ("function" === typeof instance.componentDidMount) {
            node.effectTag |= 4;
          }
          /** @type {boolean} */
          callback = false;
        }
      } else {
        instance = node.stateNode;
        forEach(current, node);
        name = node.memoizedProps;
        instance.props = node.type === node.elementType ? name : transform(node.type, name);
        data = instance.context;
        if ("object" === typeof(context = options.contextType) && null !== context) {
          context = require(context);
        } else {
          context = $(node, context = isFunction(options) ? form : item.current);
        }
        if (!((l = "function" === typeof(type = options.getDerivedStateFromProps) || "function" === typeof instance.getSnapshotBeforeUpdate) || "function" !== typeof instance.UNSAFE_componentWillReceiveProps && "function" !== typeof instance.componentWillReceiveProps)) {
          if (name !== callback || data !== context) {
            setComponentProps(node, instance, callback, context);
          }
        }
        /** @type {boolean} */
        layout = false;
        data = node.memoizedState;
        instance.state = data;
        add(node, callback, instance, value);
        key = node.memoizedState;
        if (name !== callback || data !== key || nodeList.current || layout) {
          if ("function" === typeof type) {
            find(node, options, type, callback);
            key = node.memoizedState;
          }
          if (type = layout || fetch(node, options, name, callback, data, key, context)) {
            if (!(l || "function" !== typeof instance.UNSAFE_componentWillUpdate && "function" !== typeof instance.componentWillUpdate)) {
              if ("function" === typeof instance.componentWillUpdate) {
                instance.componentWillUpdate(callback, key, context);
              }
              if ("function" === typeof instance.UNSAFE_componentWillUpdate) {
                instance.UNSAFE_componentWillUpdate(callback, key, context);
              }
            }
            if ("function" === typeof instance.componentDidUpdate) {
              node.effectTag |= 4;
            }
            if ("function" === typeof instance.getSnapshotBeforeUpdate) {
              node.effectTag |= 256;
            }
          } else {
            if (!("function" !== typeof instance.componentDidUpdate || name === current.memoizedProps && data === current.memoizedState)) {
              node.effectTag |= 4;
            }
            if (!("function" !== typeof instance.getSnapshotBeforeUpdate || name === current.memoizedProps && data === current.memoizedState)) {
              node.effectTag |= 256;
            }
            node.memoizedProps = callback;
            node.memoizedState = key;
          }
          instance.props = callback;
          instance.state = key;
          instance.context = context;
          callback = type;
        } else {
          if (!("function" !== typeof instance.componentDidUpdate || name === current.memoizedProps && data === current.memoizedState)) {
            node.effectTag |= 4;
          }
          if (!("function" !== typeof instance.getSnapshotBeforeUpdate || name === current.memoizedProps && data === current.memoizedState)) {
            node.effectTag |= 256;
          }
          /** @type {boolean} */
          callback = false;
        }
      }
    }
    return clone(current, node, options, callback, OasisMessageChannel, value);
  }
  /**
   * @param {!Object} data
   * @param {!Object} node
   * @param {!Object} path
   * @param {string} obj
   * @param {!Function} parent
   * @param {?} template
   * @return {?}
   */
  function clone(data, node, path, obj, parent, template) {
    inject(data, node);
    /** @type {boolean} */
    var rect = 0 !== (64 & node.effectTag);
    if (!obj && !rect) {
      return parent && getChildren(node, path, false), replace(data, node, template);
    }
    obj = node.stateNode;
    /** @type {!Object} */
    attrValue.current = node;
    var opts = rect && "function" !== typeof path.getDerivedStateFromError ? null : obj.render();
    return node.effectTag |= 1, null !== data && rect ? (node.child = fn(node, data.child, null, template), node.child = fn(node, null, opts, template)) : debug(data, node, opts, template), node.memoizedState = obj.state, parent && getChildren(node, path, true), node.child;
  }
  /**
   * @param {(Object|string)} node
   * @return {undefined}
   */
  function split(node) {
    var task = node.stateNode;
    if (task.pendingContext) {
      rec(0, task.pendingContext, task.pendingContext !== task.context);
    } else {
      if (task.context) {
        rec(0, task.context, false);
      }
    }
    height(node, task.containerInfo);
  }
  /**
   * @param {!Object} node
   * @param {!Object} data
   * @param {!Object} obj
   * @return {?}
   */
  function dispatch(node, data, obj) {
    var n;
    var i = data.mode;
    var ret = data.pendingProps;
    /** @type {number} */
    var current = opts.current;
    /** @type {boolean} */
    var child = false;
    if ((n = 0 !== (64 & data.effectTag)) || (n = 0 !== (2 & current) && (null === node || null !== node.memoizedState)), n ? (child = true, data.effectTag &= -65) : null !== node && null === node.memoizedState || void 0 === ret.fallback || true === ret.unstable_avoidThisFallback || (current = current | 1), indexOf(opts, 1 & current), null === node) {
      if (void 0 !== ret.fallback && reducer(data), child) {
        if (child = ret.fallback, (ret = format(null, i, 0, null)).return = data, 0 === (2 & data.mode)) {
          node = null !== data.memoizedState ? data.child.child : data.child;
          /** @type {!Object} */
          ret.child = node;
          for (; null !== node;) {
            node.return = ret;
            node = node.sibling;
          }
        }
        return (obj = format(child, i, obj, null)).return = data, ret.sibling = obj, data.memoizedState = link_el, data.child = ret, obj;
      }
      return i = ret.children, data.memoizedState = null, data.child = x(data, null, i, obj);
    }
    if (null !== node.memoizedState) {
      if (i = (node = node.child).sibling, child) {
        if (ret = ret.fallback, (obj = send(node, node.pendingProps)).return = data, 0 === (2 & data.mode) && (child = null !== data.memoizedState ? data.child.child : data.child) !== node.child) {
          obj.child = child;
          for (; null !== child;) {
            /** @type {!Object} */
            child.return = obj;
            child = child.sibling;
          }
        }
        return (i = send(i, ret)).return = data, obj.sibling = i, obj.childExpirationTime = 0, data.memoizedState = link_el, data.child = obj, i;
      }
      return obj = fn(data, node.child, ret.children, obj), data.memoizedState = null, data.child = obj;
    }
    if (node = node.child, child) {
      if (child = ret.fallback, (ret = format(null, i, 0, null)).return = data, ret.child = node, null !== node && (node.return = ret), 0 === (2 & data.mode)) {
        node = null !== data.memoizedState ? data.child.child : data.child;
        /** @type {!Object} */
        ret.child = node;
        for (; null !== node;) {
          node.return = ret;
          node = node.sibling;
        }
      }
      return (obj = format(child, i, obj, null)).return = data, ret.sibling = obj, obj.effectTag |= 2, ret.childExpirationTime = 0, data.memoizedState = link_el, data.child = ret, obj;
    }
    return data.memoizedState = null, data.child = fn(data, node, ret.children, obj);
  }
  /**
   * @param {!Object} node
   * @param {boolean} n
   * @return {undefined}
   */
  function eliminate(node, n) {
    if (node.expirationTime < n) {
      /** @type {boolean} */
      node.expirationTime = n;
    }
    var p = node.alternate;
    if (null !== p && p.expirationTime < n) {
      /** @type {boolean} */
      p.expirationTime = n;
    }
    visit(node.return, n);
  }
  /**
   * @param {!Object} ctx
   * @param {boolean} values
   * @param {boolean} node
   * @param {!Object} last
   * @param {!Object} i
   * @param {?} cb
   * @return {undefined}
   */
  function process(ctx, values, node, last, i, cb) {
    var self = ctx.memoizedState;
    if (null === self) {
      ctx.memoizedState = {
        isBackwards : values,
        rendering : null,
        renderingStartTime : 0,
        last : last,
        tail : node,
        tailExpiration : 0,
        tailMode : i,
        lastEffect : cb
      };
    } else {
      /** @type {boolean} */
      self.isBackwards = values;
      /** @type {null} */
      self.rendering = null;
      /** @type {number} */
      self.renderingStartTime = 0;
      /** @type {!Object} */
      self.last = last;
      /** @type {boolean} */
      self.tail = node;
      /** @type {number} */
      self.tailExpiration = 0;
      /** @type {!Object} */
      self.tailMode = i;
      self.lastEffect = cb;
    }
  }
  /**
   * @param {!Object} node
   * @param {!Object} el
   * @param {!Object} i
   * @return {?}
   */
  function put(node, el, i) {
    var data = el.pendingProps;
    var child = data.revealOrder;
    var len = data.tail;
    if (debug(node, el, data.children, i), 0 !== (2 & (data = opts.current))) {
      /** @type {number} */
      data = 1 & data | 2;
      el.effectTag |= 64;
    } else {
      if (null !== node && 0 !== (64 & node.effectTag)) {
        node = el.child;
        e: for (; null !== node;) {
          if (13 === node.tag) {
            if (null !== node.memoizedState) {
              eliminate(node, i);
            }
          } else {
            if (19 === node.tag) {
              eliminate(node, i);
            } else {
              if (null !== node.child) {
                /** @type {!Object} */
                node.child.return = node;
                node = node.child;
                continue;
              }
            }
          }
          if (node === el) {
            break e;
          }
          for (; null === node.sibling;) {
            if (null === node.return || node.return === el) {
              break e;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      /** @type {number} */
      data = data & 1;
    }
    if (indexOf(opts, data), 0 === (2 & el.mode)) {
      /** @type {null} */
      el.memoizedState = null;
    } else {
      switch(child) {
        case "forwards":
          i = el.child;
          /** @type {null} */
          child = null;
          for (; null !== i;) {
            if (null !== (node = i.alternate) && null === list(node)) {
              /** @type {!Object} */
              child = i;
            }
            i = i.sibling;
          }
          if (null === (i = child)) {
            child = el.child;
            /** @type {null} */
            el.child = null;
          } else {
            child = i.sibling;
            /** @type {null} */
            i.sibling = null;
          }
          process(el, false, child, i, len, el.lastEffect);
          break;
        case "backwards":
          /** @type {null} */
          i = null;
          child = el.child;
          /** @type {null} */
          el.child = null;
          for (; null !== child;) {
            if (null !== (node = child.alternate) && null === list(node)) {
              el.child = child;
              break;
            }
            node = child.sibling;
            /** @type {!Object} */
            child.sibling = i;
            i = child;
            /** @type {!Object} */
            child = node;
          }
          process(el, true, i, null, len, el.lastEffect);
          break;
        case "together":
          process(el, false, null, null, void 0, el.lastEffect);
          break;
        default:
          /** @type {null} */
          el.memoizedState = null;
      }
    }
    return el.child;
  }
  /**
   * @param {!Object} data
   * @param {!Object} value
   * @param {!Object} node
   * @return {?}
   */
  function replace(data, value, node) {
    if (null !== data) {
      value.dependencies = data.dependencies;
    }
    var i = value.expirationTime;
    if (0 !== i && isPresent(i), value.childExpirationTime < node) {
      return null;
    }
    if (null !== data && value.child !== data.child) {
      throw Error(call(153));
    }
    if (null !== value.child) {
      node = send(data = value.child, data.pendingProps);
      /** @type {!Object} */
      value.child = node;
      /** @type {!Object} */
      node.return = value;
      for (; null !== data.sibling;) {
        data = data.sibling;
        /** @type {!Object} */
        (node = node.sibling = send(data, data.pendingProps)).return = value;
      }
      /** @type {null} */
      node.sibling = null;
    }
    return value.child;
  }
  /**
   * @param {!Object} event
   * @param {!Object} node
   * @return {undefined}
   */
  function toArray(event, node) {
    switch(event.tailMode) {
      case "hidden":
        node = event.tail;
        /** @type {null} */
        var child = null;
        for (; null !== node;) {
          if (null !== node.alternate) {
            /** @type {!Object} */
            child = node;
          }
          node = node.sibling;
        }
        if (null === child) {
          /** @type {null} */
          event.tail = null;
        } else {
          /** @type {null} */
          child.sibling = null;
        }
        break;
      case "collapsed":
        child = event.tail;
        /** @type {null} */
        var nextChild = null;
        for (; null !== child;) {
          if (null !== child.alternate) {
            nextChild = child;
          }
          child = child.sibling;
        }
        if (null === nextChild) {
          if (node || null === event.tail) {
            /** @type {null} */
            event.tail = null;
          } else {
            /** @type {null} */
            event.tail.sibling = null;
          }
        } else {
          /** @type {null} */
          nextChild.sibling = null;
        }
    }
  }
  /**
   * @param {!Object} node
   * @param {!Object} result
   * @param {!Object} value
   * @return {?}
   */
  function render(node, result, value) {
    var data = result.pendingProps;
    switch(result.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null;
      case 1:
        return isFunction(result.type) && required(), null;
      case 3:
        return msgHasId(), isString(nodeList), isString(item), (value = result.stateNode).pendingContext && (value.context = value.pendingContext, value.pendingContext = null), null !== node && null !== node.child || !walk(result) || (result.effectTag |= 4), null;
      case 5:
        updateGroupInfoItem(result);
        value = translate(ret.current);
        var type = result.type;
        if (null !== node && null != result.stateNode) {
          notify(node, result, type, data, value);
          if (node.ref !== result.ref) {
            result.effectTag |= 128;
          }
        } else {
          if (!data) {
            if (null === result.stateNode) {
              throw Error(call(166));
            }
            return null;
          }
          if (node = translate(request.current), walk(result)) {
            data = result.stateNode;
            type = result.type;
            var name = result.memoizedProps;
            switch(data[id] = result, data[k] = name, type) {
              case "iframe":
              case "object":
              case "embed":
                expect("load", data);
                break;
              case "video":
              case "audio":
                /** @type {number} */
                node = 0;
                for (; node < info.length; node++) {
                  expect(info[node], data);
                }
                break;
              case "source":
                expect("error", data);
                break;
              case "img":
              case "image":
              case "link":
                expect("error", data);
                expect("load", data);
                break;
              case "form":
                expect("reset", data);
                expect("submit", data);
                break;
              case "details":
                expect("toggle", data);
                break;
              case "input":
                _handleChange(data, name);
                expect("invalid", data);
                invoke(value, "onChange");
                break;
              case "select":
                data._wrapperState = {
                  wasMultiple : !!name.multiple
                };
                expect("invalid", data);
                invoke(value, "onChange");
                break;
              case "textarea":
                done(data, name);
                expect("invalid", data);
                invoke(value, "onChange");
            }
            var s;
            for (s in has(type, name), node = null, name) {
              if (name.hasOwnProperty(s)) {
                var obj = name[s];
                if ("children" === s) {
                  if ("string" === typeof obj) {
                    if (data.textContent !== obj) {
                      /** @type {!Array} */
                      node = ["children", obj];
                    }
                  } else {
                    if ("number" === typeof obj && data.textContent !== "" + obj) {
                      /** @type {!Array} */
                      node = ["children", "" + obj];
                    }
                  }
                } else {
                  if (dependencies.hasOwnProperty(s) && null != obj) {
                    invoke(value, s);
                  }
                }
              }
            }
            switch(type) {
              case "input":
                Class(data);
                reset(data, name, true);
                break;
              case "textarea":
                Class(data);
                readFile(data);
                break;
              case "select":
              case "option":
                break;
              default:
                if ("function" === typeof name.onClick) {
                  /** @type {function(): undefined} */
                  data.onclick = size;
                }
            }
            /** @type {!Object} */
            value = node;
            /** @type {!Object} */
            result.updateQueue = value;
            if (null !== value) {
              result.effectTag |= 4;
            }
          } else {
            switch(s = 9 === value.nodeType ? value : value.ownerDocument, node === dir && (node = createNode(type)), node === dir ? "script" === type ? ((node = s.createElement("div")).innerHTML = "<script>\x3c/script>", node = node.removeChild(node.firstChild)) : "string" === typeof data.is ? node = s.createElement(type, {
              is : data.is
            }) : (node = s.createElement(type), "select" === type && (s = node, data.multiple ? s.multiple = true : data.size && (s.size = data.size))) : node = s.createElementNS(node, type), node[id] = result, node[k] = data, Section(node, result), result.stateNode = node, s = factory(type, data), type) {
              case "iframe":
              case "object":
              case "embed":
                expect("load", node);
                obj = data;
                break;
              case "video":
              case "audio":
                /** @type {number} */
                obj = 0;
                for (; obj < info.length; obj++) {
                  expect(info[obj], node);
                }
                obj = data;
                break;
              case "source":
                expect("error", node);
                obj = data;
                break;
              case "img":
              case "image":
              case "link":
                expect("error", node);
                expect("load", node);
                obj = data;
                break;
              case "form":
                expect("reset", node);
                expect("submit", node);
                obj = data;
                break;
              case "details":
                expect("toggle", node);
                obj = data;
                break;
              case "input":
                _handleChange(node, data);
                obj = convert(node, data);
                expect("invalid", node);
                invoke(value, "onChange");
                break;
              case "option":
                obj = wrap(node, data);
                break;
              case "select":
                node._wrapperState = {
                  wasMultiple : !!data.multiple
                };
                obj = assign({}, data, {
                  value : void 0
                });
                expect("invalid", node);
                invoke(value, "onChange");
                break;
              case "textarea":
                done(node, data);
                obj = select(node, data);
                expect("invalid", node);
                invoke(value, "onChange");
                break;
              default:
                obj = data;
            }
            has(type, obj);
            var ref = obj;
            for (name in ref) {
              if (ref.hasOwnProperty(name)) {
                var value = ref[name];
                if ("style" === name) {
                  setStyle(node, value);
                } else {
                  if ("dangerouslySetInnerHTML" === name) {
                    if (null != (value = value ? value.__html : void 0)) {
                      warn(node, value);
                    }
                  } else {
                    if ("children" === name) {
                      if ("string" === typeof value) {
                        if ("textarea" !== type || "" !== value) {
                          append(node, value);
                        }
                      } else {
                        if ("number" === typeof value) {
                          append(node, "" + value);
                        }
                      }
                    } else {
                      if ("suppressContentEditableWarning" !== name && "suppressHydrationWarning" !== name && "autoFocus" !== name) {
                        if (dependencies.hasOwnProperty(name)) {
                          if (null != value) {
                            invoke(value, name);
                          }
                        } else {
                          if (null != value) {
                            handler(node, name, value, s);
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            switch(type) {
              case "input":
                Class(node);
                reset(node, data, false);
                break;
              case "textarea":
                Class(node);
                readFile(node);
                break;
              case "option":
                if (null != data.value) {
                  node.setAttribute("value", "" + stringify(data.value));
                }
                break;
              case "select":
                /** @type {boolean} */
                node.multiple = !!data.multiple;
                if (null != (value = data.value)) {
                  updateOptions(node, !!data.multiple, value, false);
                } else {
                  if (null != data.defaultValue) {
                    updateOptions(node, !!data.multiple, data.defaultValue, true);
                  }
                }
                break;
              default:
                if ("function" === typeof obj.onClick) {
                  /** @type {function(): undefined} */
                  node.onclick = size;
                }
            }
            if (focus(type, data)) {
              result.effectTag |= 4;
            }
          }
          if (null !== result.ref) {
            result.effectTag |= 128;
          }
        }
        return null;
      case 6:
        if (node && null != result.stateNode) {
          isValidBSTRecursive(0, result, node.memoizedProps, data);
        } else {
          if ("string" !== typeof data && null === result.stateNode) {
            throw Error(call(166));
          }
          value = translate(ret.current);
          translate(request.current);
          if (walk(result)) {
            value = result.stateNode;
            data = result.memoizedProps;
            /** @type {!Object} */
            value[id] = result;
            if (value.nodeValue !== data) {
              result.effectTag |= 4;
            }
          } else {
            /** @type {!Object} */
            (value = (9 === value.nodeType ? value : value.ownerDocument).createTextNode(data))[id] = result;
            /** @type {!Object} */
            result.stateNode = value;
          }
        }
        return null;
      case 13:
        return isString(opts), data = result.memoizedState, 0 !== (64 & result.effectTag) ? (result.expirationTime = value, result) : (value = null !== data, data = false, null === node ? void 0 !== result.memoizedProps.fallback && walk(result) : (data = null !== (type = node.memoizedState), value || null === type || null !== (type = node.child.sibling) && (null !== (name = result.firstEffect) ? (result.firstEffect = type, type.nextEffect = name) : (result.firstEffect = result.lastEffect = type, 
        type.nextEffect = null), type.effectTag = 8)), value && !data && 0 !== (2 & result.mode) && (null === node && true !== result.memoizedProps.unstable_avoidThisFallback || 0 !== (1 & opts.current) ? index === undefined && (index = startIndex) : (index !== undefined && index !== startIndex || (index = arg1), 0 !== offset && null !== m && (setFont(m, n), _extends(m, offset)))), (value || data) && (result.effectTag |= 4), null);
      case 4:
        return msgHasId(), null;
      case 10:
        return template(result), null;
      case 17:
        return isFunction(result.type) && required(), null;
      case 19:
        if (isString(opts), null === (data = result.memoizedState)) {
          return null;
        }
        if (type = 0 !== (64 & result.effectTag), null === (name = data.rendering)) {
          if (type) {
            toArray(data, false);
          } else {
            if (index !== undefined || null !== node && 0 !== (64 & node.effectTag)) {
              name = result.child;
              for (; null !== name;) {
                if (null !== (node = list(name))) {
                  result.effectTag |= 64;
                  toArray(data, false);
                  if (null !== (type = node.updateQueue)) {
                    result.updateQueue = type;
                    result.effectTag |= 4;
                  }
                  if (null === data.lastEffect) {
                    /** @type {null} */
                    result.firstEffect = null;
                  }
                  result.lastEffect = data.lastEffect;
                  data = result.child;
                  for (; null !== data;) {
                    /** @type {!Object} */
                    name = value;
                    (type = data).effectTag &= 2;
                    /** @type {null} */
                    type.nextEffect = null;
                    /** @type {null} */
                    type.firstEffect = null;
                    /** @type {null} */
                    type.lastEffect = null;
                    if (null === (node = type.alternate)) {
                      /** @type {number} */
                      type.childExpirationTime = 0;
                      type.expirationTime = name;
                      /** @type {null} */
                      type.child = null;
                      /** @type {null} */
                      type.memoizedProps = null;
                      /** @type {null} */
                      type.memoizedState = null;
                      /** @type {null} */
                      type.updateQueue = null;
                      /** @type {null} */
                      type.dependencies = null;
                    } else {
                      type.childExpirationTime = node.childExpirationTime;
                      type.expirationTime = node.expirationTime;
                      type.child = node.child;
                      type.memoizedProps = node.memoizedProps;
                      type.memoizedState = node.memoizedState;
                      type.updateQueue = node.updateQueue;
                      name = node.dependencies;
                      /** @type {(null|{expirationTime: ?, firstContext: ?, responders: ?})} */
                      type.dependencies = null === name ? null : {
                        expirationTime : name.expirationTime,
                        firstContext : name.firstContext,
                        responders : name.responders
                      };
                    }
                    data = data.sibling;
                  }
                  return indexOf(opts, 1 & opts.current | 2), result.child;
                }
                name = name.sibling;
              }
            }
          }
        } else {
          if (!type) {
            if (null !== (node = list(name))) {
              if (result.effectTag |= 64, type = true, null !== (value = node.updateQueue) && (result.updateQueue = value, result.effectTag |= 4), toArray(data, true), null === data.tail && "hidden" === data.tailMode && !name.alternate) {
                return null !== (result = result.lastEffect = data.lastEffect) && (result.nextEffect = null), null;
              }
            } else {
              if (2 * getTime() - data.renderingStartTime > data.tailExpiration && 1 < value) {
                result.effectTag |= 64;
                /** @type {boolean} */
                type = true;
                toArray(data, false);
                /** @type {number} */
                result.expirationTime = result.childExpirationTime = value - 1;
              }
            }
          }
          if (data.isBackwards) {
            name.sibling = result.child;
            result.child = name;
          } else {
            if (null !== (value = data.last)) {
              value.sibling = name;
            } else {
              result.child = name;
            }
            data.last = name;
          }
        }
        return null !== data.tail ? (0 === data.tailExpiration && (data.tailExpiration = getTime() + 500), value = data.tail, data.rendering = value, data.tail = value.sibling, data.lastEffect = result.lastEffect, data.renderingStartTime = getTime(), value.sibling = null, result = opts.current, indexOf(opts, type ? 1 & result | 2 : 1 & result), value) : null;
    }
    throw Error(call(156, result.tag));
  }
  /**
   * @param {!Object} that
   * @return {?}
   */
  function decode(that) {
    switch(that.tag) {
      case 1:
        if (isFunction(that.type)) {
          required();
        }
        var moveListener = that.effectTag;
        return 4096 & moveListener ? (that.effectTag = -4097 & moveListener | 64, that) : null;
      case 3:
        if (msgHasId(), isString(nodeList), isString(item), 0 !== (64 & (moveListener = that.effectTag))) {
          throw Error(call(285));
        }
        return that.effectTag = -4097 & moveListener | 64, that;
      case 5:
        return updateGroupInfoItem(that), null;
      case 13:
        return isString(opts), 4096 & (moveListener = that.effectTag) ? (that.effectTag = -4097 & moveListener | 64, that) : null;
      case 19:
        return isString(opts), null;
      case 4:
        return msgHasId(), null;
      case 10:
        return template(that), null;
      default:
        return null;
    }
  }
  /**
   * @param {!Object} name
   * @param {!Object} data
   * @return {?}
   */
  function Buffer(name, data) {
    return {
      value : name,
      source : data,
      stack : bind(data)
    };
  }
  /**
   * @param {!Object} e
   * @param {string} d
   * @return {undefined}
   */
  function start(e, d) {
    var s = d.source;
    var t = d.stack;
    if (null === t && null !== s) {
      t = bind(s);
    }
    if (null !== s) {
      each(s.type);
    }
    d = d.value;
    if (null !== e && 1 === e.tag) {
      each(e.type);
    }
    try {
      console.error(d);
    } catch (i) {
      setTimeout(function() {
        throw i;
      });
    }
  }
  /**
   * @param {!Object} ev
   * @return {undefined}
   */
  function onFail(ev) {
    var a = ev.ref;
    if (null !== a) {
      if ("function" === typeof a) {
        try {
          a(null);
        } catch (r) {
          extend(ev, r);
        }
      } else {
        /** @type {null} */
        a.current = null;
      }
    }
  }
  /**
   * @param {!Object} current
   * @param {!Object} node
   * @return {undefined}
   */
  function print(current, node) {
    switch(node.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return;
      case 1:
        if (256 & node.effectTag && null !== current) {
          var rule = current.memoizedProps;
          var div = current.memoizedState;
          node = (current = node.stateNode).getSnapshotBeforeUpdate(node.elementType === node.type ? rule : transform(node.type, rule), div);
          /** @type {!Object} */
          current.__reactInternalSnapshotBeforeUpdate = node;
        }
        return;
      case 3:
      case 5:
      case 6:
      case 4:
      case 17:
        return;
    }
    throw Error(call(163));
  }
  /**
   * @param {number} type
   * @param {!Object} s
   * @return {undefined}
   */
  function register(type, s) {
    if (null !== (s = null !== (s = s.updateQueue) ? s.lastEffect : null)) {
      var t = s = s.next;
      do {
        if ((t.tag & type) === type) {
          var d = t.destroy;
          t.destroy = void 0;
          if (void 0 !== d) {
            d();
          }
        }
        t = t.next;
      } while (t !== s);
    }
  }
  /**
   * @param {number} value
   * @param {!Object} target
   * @return {undefined}
   */
  function tokenize(value, target) {
    if (null !== (target = null !== (target = target.updateQueue) ? target.lastEffect : null)) {
      var node = target = target.next;
      do {
        if ((node.tag & value) === value) {
          var create = node.create;
          node.destroy = create();
        }
        node = node.next;
      } while (node !== target);
    }
  }
  /**
   * @param {string} c
   * @param {!Array} data
   * @param {!Object} node
   * @return {?}
   */
  function link(c, data, node) {
    switch(node.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return void tokenize(3, node);
      case 1:
        if (c = node.stateNode, 4 & node.effectTag) {
          if (null === data) {
            c.componentDidMount();
          } else {
            var classRemover = node.elementType === node.type ? data.memoizedProps : transform(node.type, data.memoizedProps);
            c.componentDidUpdate(classRemover, data.memoizedState, c.__reactInternalSnapshotBeforeUpdate);
          }
        }
        return void(null !== (data = node.updateQueue) && hide(node, data, c));
      case 3:
        if (null !== (data = node.updateQueue)) {
          if (c = null, null !== node.child) {
            switch(node.child.tag) {
              case 5:
                c = node.child.stateNode;
                break;
              case 1:
                c = node.child.stateNode;
            }
          }
          hide(node, data, c);
        }
        return;
      case 5:
        return c = node.stateNode, void(null === data && 4 & node.effectTag && focus(node.type, node.memoizedProps) && c.focus());
      case 6:
      case 4:
      case 12:
        return;
      case 13:
        return void(null === node.memoizedState && (node = node.alternate, null !== node && (node = node.memoizedState, null !== node && (node = node.dehydrated, null !== node && _register(node)))));
      case 19:
      case 17:
      case 20:
      case 21:
        return;
    }
    throw Error(call(163));
  }
  /**
   * @param {!Object} target
   * @param {!Object} node
   * @param {number} val
   * @return {undefined}
   */
  function apply(target, node, val) {
    switch("function" === typeof doc && doc(node), node.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        if (null !== (target = node.updateQueue) && null !== (target = target.lastEffect)) {
          var first = target.next;
          drop(97 < val ? 97 : val, function() {
            var last = first;
            do {
              var next = last.destroy;
              if (void 0 !== next) {
                /** @type {!Object} */
                var current = node;
                try {
                  next();
                } catch (o) {
                  extend(current, o);
                }
              }
              last = last.next;
            } while (last !== first);
          });
        }
        break;
      case 1:
        onFail(node);
        if ("function" === typeof(val = node.stateNode).componentWillUnmount) {
          (function(data, instance) {
            try {
              instance.props = data.memoizedProps;
              instance.state = data.memoizedState;
              instance.componentWillUnmount();
            } catch (r) {
              extend(data, r);
            }
          })(node, val);
        }
        break;
      case 5:
        onFail(node);
        break;
      case 4:
        merge(target, node, val);
    }
  }
  /**
   * @param {!Object} node
   * @return {undefined}
   */
  function repeat(node) {
    var alternate = node.alternate;
    /** @type {null} */
    node.return = null;
    /** @type {null} */
    node.child = null;
    /** @type {null} */
    node.memoizedState = null;
    /** @type {null} */
    node.updateQueue = null;
    /** @type {null} */
    node.dependencies = null;
    /** @type {null} */
    node.alternate = null;
    /** @type {null} */
    node.firstEffect = null;
    /** @type {null} */
    node.lastEffect = null;
    /** @type {null} */
    node.pendingProps = null;
    /** @type {null} */
    node.memoizedProps = null;
    /** @type {null} */
    node.stateNode = null;
    if (null !== alternate) {
      repeat(alternate);
    }
  }
  /**
   * @param {!Object} token
   * @return {?}
   */
  function compare(token) {
    return 5 === token.tag || 3 === token.tag || 4 === token.tag;
  }
  /**
   * @param {!Object} obj
   * @return {undefined}
   */
  function wrapper(obj) {
    e: {
      var value = obj.return;
      for (; null !== value;) {
        if (compare(value)) {
          var node = value;
          break e;
        }
        value = value.return;
      }
      throw Error(call(160));
    }
    switch(value = node.stateNode, node.tag) {
      case 5:
        /** @type {boolean} */
        var n = false;
        break;
      case 3:
      case 4:
        value = value.containerInfo;
        /** @type {boolean} */
        n = true;
        break;
      default:
        throw Error(call(161));
    }
    if (16 & node.effectTag) {
      append(value, "");
      node.effectTag &= -17;
    }
    /** @type {!Object} */
    node = obj;
    e: t: for (;;) {
      for (; null === node.sibling;) {
        if (null === node.return || compare(node.return)) {
          /** @type {null} */
          node = null;
          break e;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
      for (; 5 !== node.tag && 6 !== node.tag && 18 !== node.tag;) {
        if (2 & node.effectTag) {
          continue t;
        }
        if (null === node.child || 4 === node.tag) {
          continue t;
        }
        node.child.return = node;
        node = node.child;
      }
      if (!(2 & node.effectTag)) {
        node = node.stateNode;
        break e;
      }
    }
    if (n) {
      (function add(node, p, n) {
        var tag = node.tag;
        /** @type {boolean} */
        var opt_useFirstChild = 5 === tag || 6 === tag;
        if (opt_useFirstChild) {
          node = opt_useFirstChild ? node.stateNode : node.stateNode.instance;
          if (p) {
            if (8 === n.nodeType) {
              n.parentNode.insertBefore(node, p);
            } else {
              n.insertBefore(node, p);
            }
          } else {
            if (8 === n.nodeType) {
              (p = n.parentNode).insertBefore(node, n);
            } else {
              (p = n).appendChild(node);
            }
            if (!(null !== (n = n._reactRootContainer) && void 0 !== n || null !== p.onclick)) {
              /** @type {function(): undefined} */
              p.onclick = size;
            }
          }
        } else {
          if (4 !== tag && null !== (node = node.child)) {
            add(node, p, n);
            node = node.sibling;
            for (; null !== node;) {
              add(node, p, n);
              node = node.sibling;
            }
          }
        }
      })(obj, node, value);
    } else {
      (function start(node, el, options) {
        var tag = node.tag;
        /** @type {boolean} */
        var opt_useFirstChild = 5 === tag || 6 === tag;
        if (opt_useFirstChild) {
          node = opt_useFirstChild ? node.stateNode : node.stateNode.instance;
          if (el) {
            options.insertBefore(node, el);
          } else {
            options.appendChild(node);
          }
        } else {
          if (4 !== tag && null !== (node = node.child)) {
            start(node, el, options);
            node = node.sibling;
            for (; null !== node;) {
              start(node, el, options);
              node = node.sibling;
            }
          }
        }
      })(obj, node, value);
    }
  }
  /**
   * @param {!Object} s
   * @param {!Object} data
   * @param {number} a
   * @return {undefined}
   */
  function merge(s, data, a) {
    var self;
    var i;
    /** @type {!Object} */
    var node = data;
    /** @type {boolean} */
    var inst = false;
    for (;;) {
      if (!inst) {
        inst = node.return;
        e: for (;;) {
          if (null === inst) {
            throw Error(call(160));
          }
          switch(self = inst.stateNode, inst.tag) {
            case 5:
              /** @type {boolean} */
              i = false;
              break e;
            case 3:
            case 4:
              self = self.containerInfo;
              /** @type {boolean} */
              i = true;
              break e;
          }
          inst = inst.return;
        }
        /** @type {boolean} */
        inst = true;
      }
      if (5 === node.tag || 6 === node.tag) {
        /** @type {!Object} */
        var o = s;
        var current = node;
        /** @type {number} */
        var t = a;
        var value = current;
        e: for (;;) {
          if (apply(o, value, t), null !== value.child && 4 !== value.tag) {
            value.child.return = value;
            value = value.child;
          } else {
            if (value === current) {
              break e;
            }
            for (; null === value.sibling;) {
              if (null === value.return || value.return === current) {
                break e;
              }
              value = value.return;
            }
            value.sibling.return = value.return;
            value = value.sibling;
          }
        }
        if (i) {
          o = self;
          current = node.stateNode;
          if (8 === o.nodeType) {
            o.parentNode.removeChild(current);
          } else {
            o.removeChild(current);
          }
        } else {
          self.removeChild(node.stateNode);
        }
      } else {
        if (4 === node.tag) {
          if (null !== node.child) {
            self = node.stateNode.containerInfo;
            /** @type {boolean} */
            i = true;
            node.child.return = node;
            node = node.child;
            continue;
          }
        } else {
          if (apply(s, node, a), null !== node.child) {
            node.child.return = node;
            node = node.child;
            continue;
          }
        }
      }
      if (node === data) {
        break;
      }
      for (; null === node.sibling;) {
        if (null === node.return || node.return === data) {
          return;
        }
        if (4 === (node = node.return).tag) {
          /** @type {boolean} */
          inst = false;
        }
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  }
  /**
   * @param {!Object} node
   * @param {!Object} target
   * @return {?}
   */
  function initialize(node, target) {
    switch(target.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        return void register(3, target);
      case 1:
        return;
      case 5:
        var element = target.stateNode;
        if (null != element) {
          var value = target.memoizedProps;
          var i = null !== node ? node.memoizedProps : value;
          node = target.type;
          var p = target.updateQueue;
          if (target.updateQueue = null, null !== p) {
            element[k] = value;
            if ("input" === node && "radio" === value.type && null != value.name) {
              setAttribute(element, value);
            }
            factory(node, i);
            target = factory(node, value);
            /** @type {number} */
            i = 0;
            for (; i < p.length; i = i + 2) {
              var name = p[i];
              var value = p[i + 1];
              if ("style" === name) {
                setStyle(element, value);
              } else {
                if ("dangerouslySetInnerHTML" === name) {
                  warn(element, value);
                } else {
                  if ("children" === name) {
                    append(element, value);
                  } else {
                    handler(element, name, value, target);
                  }
                }
              }
            }
            switch(node) {
              case "input":
                check(element, value);
                break;
              case "textarea":
                fixElement(element, value);
                break;
              case "select":
                target = element._wrapperState.wasMultiple;
                /** @type {boolean} */
                element._wrapperState.wasMultiple = !!value.multiple;
                if (null != (node = value.value)) {
                  updateOptions(element, !!value.multiple, node, false);
                } else {
                  if (target !== !!value.multiple) {
                    if (null != value.defaultValue) {
                      updateOptions(element, !!value.multiple, value.defaultValue, true);
                    } else {
                      updateOptions(element, !!value.multiple, value.multiple ? [] : "", false);
                    }
                  }
                }
            }
          }
        }
        return;
      case 6:
        if (null === target.stateNode) {
          throw Error(call(162));
        }
        return void(target.stateNode.nodeValue = target.memoizedProps);
      case 3:
        return void((target = target.stateNode).hydrate && (target.hydrate = false, _register(target.containerInfo)));
      case 12:
        return;
      case 13:
        if (element = target, null === target.memoizedState ? value = false : (value = true, element = target.child, startTime = getTime()), null !== element) {
          node = element;
          e: for (;;) {
            if (5 === node.tag) {
              p = node.stateNode;
              if (value) {
                if ("function" === typeof(p = p.style).setProperty) {
                  p.setProperty("display", "none", "important");
                } else {
                  /** @type {string} */
                  p.display = "none";
                }
              } else {
                p = node.stateNode;
                i = void 0 !== (i = node.memoizedProps.style) && null !== i && i.hasOwnProperty("display") ? i.display : null;
                p.style.display = loop("display", i);
              }
            } else {
              if (6 === node.tag) {
                node.stateNode.nodeValue = value ? "" : node.memoizedProps;
              } else {
                if (13 === node.tag && null !== node.memoizedState && null === node.memoizedState.dehydrated) {
                  /** @type {!Object} */
                  (p = node.child.sibling).return = node;
                  node = p;
                  continue;
                }
                if (null !== node.child) {
                  /** @type {!Object} */
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
              }
            }
            if (node === element) {
              break;
            }
            for (; null === node.sibling;) {
              if (null === node.return || node.return === element) {
                break e;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return void Notifier(target);
      case 19:
        return void Notifier(target);
      case 17:
        return;
    }
    throw Error(call(163));
  }
  /**
   * @param {!Object} node
   * @return {undefined}
   */
  function Notifier(node) {
    var resourceData = node.updateQueue;
    if (null !== resourceData) {
      /** @type {null} */
      node.updateQueue = null;
      var r = node.stateNode;
      if (null === r) {
        r = node.stateNode = new action;
      }
      resourceData.forEach(function(f) {
        var n = g.bind(null, node, f);
        if (!r.has(f)) {
          r.add(f);
          f.then(n, n);
        }
      });
    }
  }
  /**
   * @param {!Object} context
   * @param {string} data
   * @param {!Object} obj
   * @return {?}
   */
  function all(context, data, obj) {
    /** @type {number} */
    (obj = parseInt(obj, null)).tag = 3;
    obj.payload = {
      element : null
    };
    var event = data.value;
    return obj.callback = function() {
      if (!ref1$) {
        /** @type {boolean} */
        ref1$ = true;
        realEvent = event;
      }
      start(context, data);
    }, obj;
  }
  /**
   * @param {!Object} node
   * @param {string} data
   * @param {!Object} e
   * @return {?}
   */
  function emit(node, data, e) {
    /** @type {number} */
    (e = parseInt(e, null)).tag = 3;
    var callback = node.type.getDerivedStateFromError;
    if ("function" === typeof callback) {
      var d = data.value;
      /**
       * @return {?}
       */
      e.payload = function() {
        return start(node, data), callback(d);
      };
    }
    var publicInst = node.stateNode;
    return null !== publicInst && "function" === typeof publicInst.componentDidCatch && (e.callback = function() {
      if ("function" !== typeof callback) {
        if (null === observers) {
          /** @type {!Set} */
          observers = new Set([this]);
        } else {
          observers.add(this);
        }
        start(node, data);
      }
      var url = data.stack;
      this.componentDidCatch(data.value, {
        componentStack : null !== url ? url : ""
      });
    }), e;
  }
  /**
   * @return {?}
   */
  function parseFloat() {
    return 0 !== (48 & value) ? 1073741821 - (getTime() / 10 | 0) : 0 !== Vs ? Vs : Vs = 1073741821 - (getTime() / 10 | 0);
  }
  /**
   * @param {number} e
   * @param {number} a
   * @param {!Object} options
   * @return {?}
   */
  function map(e, a, options) {
    if (0 === (2 & (a = a.mode))) {
      return 1073741823;
    }
    var next = then();
    if (0 === (4 & a)) {
      return 99 === next ? 1073741823 : 1073741822;
    }
    if (0 !== (16 & value)) {
      return n;
    }
    if (null !== options) {
      e = calc(e, 0 | options.timeoutMs || 5E3, 250);
    } else {
      switch(next) {
        case 99:
          /** @type {number} */
          e = 1073741823;
          break;
        case 98:
          e = calc(e, 150, 100);
          break;
        case 97:
        case 96:
          e = calc(e, 5E3, 250);
          break;
        case 95:
          /** @type {number} */
          e = 2;
          break;
        default:
          throw Error(call(326));
      }
    }
    return null !== m && e === n && --e, e;
  }
  /**
   * @param {string} a
   * @param {number} i
   * @return {undefined}
   */
  function test(a, i) {
    if (50 < _t$FLIPPED_ALIAS_KEYS) {
      throw _t$FLIPPED_ALIAS_KEYS = 0, caller = null, Error(call(185));
    }
    if (null !== (a = toString(a, i))) {
      var b = then();
      if (1073741823 === i) {
        if (0 !== (8 & value) && 0 === (48 & value)) {
          runTest(a);
        } else {
          exec(a);
          if (0 === value) {
            log();
          }
        }
      } else {
        exec(a);
      }
      if (!(0 === (4 & value) || 98 !== b && 99 !== b)) {
        if (null === cur) {
          /** @type {!Map} */
          cur = new Map([[a, i]]);
        } else {
          if (void 0 === (b = cur.get(a)) || b > i) {
            cur.set(a, i);
          }
        }
      }
    }
  }
  /**
   * @param {!Object} data
   * @param {number} offset
   * @return {?}
   */
  function toString(data, offset) {
    if (data.expirationTime < offset) {
      /** @type {number} */
      data.expirationTime = offset;
    }
    var s = data.alternate;
    if (null !== s && s.expirationTime < offset) {
      /** @type {number} */
      s.expirationTime = offset;
    }
    var node = data.return;
    /** @type {null} */
    var i = null;
    if (null === node && 3 === data.tag) {
      i = data.stateNode;
    } else {
      for (; null !== node;) {
        if (s = node.alternate, node.childExpirationTime < offset && (node.childExpirationTime = offset), null !== s && s.childExpirationTime < offset && (s.childExpirationTime = offset), null === node.return && 3 === node.tag) {
          i = node.stateNode;
          break;
        }
        node = node.return;
      }
    }
    return null !== i && (m === i && (isPresent(offset), index === arg1 && setFont(i, n)), _extends(i, offset)), i;
  }
  /**
   * @param {!Object} x
   * @return {?}
   */
  function parseNumber(x) {
    var val = x.lastExpiredTime;
    if (0 !== val) {
      return val;
    }
    if (!swap(x, val = x.firstPendingTime)) {
      return val;
    }
    var y = x.lastPingedTime;
    return 2 >= (x = y > (x = x.nextKnownPendingLevel) ? y : x) && val !== x ? 0 : x;
  }
  /**
   * @param {!Object} value
   * @return {undefined}
   */
  function exec(value) {
    if (0 !== value.lastExpiredTime) {
      /** @type {number} */
      value.callbackExpirationTime = 1073741823;
      /** @type {number} */
      value.callbackPriority = 99;
      value.callbackNode = success(runTest.bind(null, value));
    } else {
      var number = parseNumber(value);
      var left = value.callbackNode;
      if (0 === number) {
        if (null !== left) {
          /** @type {null} */
          value.callbackNode = null;
          /** @type {number} */
          value.callbackExpirationTime = 0;
          /** @type {number} */
          value.callbackPriority = 90;
        }
      } else {
        var min = parseFloat();
        if (1073741823 === number ? min = 99 : 1 === number || 2 === number ? min = 95 : min = 0 >= (min = 10 * (1073741821 - number) - 10 * (1073741821 - min)) ? 99 : 250 >= min ? 98 : 5250 >= min ? 97 : 95, null !== left) {
          var len = value.callbackPriority;
          if (value.callbackExpirationTime === number && len >= min) {
            return;
          }
          if (left !== origin) {
            concat(left);
          }
        }
        value.callbackExpirationTime = number;
        value.callbackPriority = min;
        number = 1073741823 === number ? success(runTest.bind(null, value)) : multiply(min, parse.bind(null, value), {
          timeout : 10 * (1073741821 - number) - getTime()
        });
        value.callbackNode = number;
      }
    }
  }
  /**
   * @param {!Object} a
   * @param {?} e
   * @return {?}
   */
  function parse(a, e) {
    if (Vs = 0, e) {
      return eq(a, e = parseFloat()), exec(a), null;
    }
    var b = parseNumber(a);
    if (0 !== b) {
      if (e = a.callbackNode, 0 !== (48 & value)) {
        throw Error(call(327));
      }
      if (readFileSync(), a === m && b === n || t(a, b), null !== node) {
        var n = value;
        /** @type {number} */
        value = value | 16;
        var c = moment();
        for (;;) {
          try {
            getPSConfig();
            break;
          } catch (id) {
            end(a, id);
          }
        }
        if (assertConcrete(), value = n, event.current = c, 1 === index) {
          throw e = pdf, t(a, b), setFont(a, b), exec(a), e;
        }
        if (null === node) {
          switch(c = a.finishedWork = a.current.alternate, a.finishedExpirationTime = b, n = index, m = null, n) {
            case undefined:
            case 1:
              throw Error(call(345));
            case 2:
              eq(a, 2 < b ? 2 : b);
              break;
            case startIndex:
              if (setFont(a, b), b === (n = a.lastSuspendedTime) && (a.nextKnownPendingLevel = atob(c)), 1073741823 === r && 10 < (c = startTime + 500 - getTime())) {
                if (Os) {
                  var v = a.lastPingedTime;
                  if (0 === v || v >= b) {
                    a.lastPingedTime = b;
                    t(a, b);
                    break;
                  }
                }
                if (0 !== (v = parseNumber(a)) && v !== b) {
                  break;
                }
                if (0 !== n && n !== b) {
                  a.lastPingedTime = n;
                  break;
                }
                /** @type {number} */
                a.timeoutHandle = equal(save.bind(null, a), c);
                break;
              }
              save(a);
              break;
            case arg1:
              if (setFont(a, b), b === (n = a.lastSuspendedTime) && (a.nextKnownPendingLevel = atob(c)), Os && (0 === (c = a.lastPingedTime) || c >= b)) {
                a.lastPingedTime = b;
                t(a, b);
                break;
              }
              if (0 !== (c = parseNumber(a)) && c !== b) {
                break;
              }
              if (0 !== n && n !== b) {
                a.lastPingedTime = n;
                break;
              }
              if (1073741823 !== l ? n = 10 * (1073741821 - l) - getTime() : 1073741823 === r ? n = 0 : (n = 10 * (1073741821 - r) - 5E3, 0 > (n = (c = getTime()) - n) && (n = 0), (b = 10 * (1073741821 - b) - c) < (n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3E3 > n ? 3E3 : 4320 > n ? 4320 : 1960 * ceil(n / 1960)) - n) && (n = b)), 10 < n) {
                /** @type {number} */
                a.timeoutHandle = equal(save.bind(null, a), n);
                break;
              }
              save(a);
              break;
            case 5:
              if (1073741823 !== r && null !== currentRelations) {
                v = r;
                var addedRelations = currentRelations;
                if (0 >= (n = 0 | addedRelations.busyMinDurationMs) ? n = 0 : (c = 0 | addedRelations.busyDelayMs, n = (v = getTime() - (10 * (1073741821 - v) - (0 | addedRelations.timeoutMs || 5E3))) <= c ? 0 : c + n - v), 10 < n) {
                  setFont(a, b);
                  /** @type {number} */
                  a.timeoutHandle = equal(save.bind(null, a), n);
                  break;
                }
              }
              save(a);
              break;
            default:
              throw Error(call(329));
          }
        }
        if (exec(a), a.callbackNode === e) {
          return parse.bind(null, a);
        }
      }
    }
    return null;
  }
  /**
   * @param {!Object} a
   * @return {?}
   */
  function runTest(a) {
    var b = a.lastExpiredTime;
    if (b = 0 !== b ? b : 1073741823, 0 !== (48 & value)) {
      throw Error(call(327));
    }
    if (readFileSync(), a === m && b === n || t(a, b), null !== node) {
      var c = value;
      /** @type {number} */
      value = value | 16;
      var instance = moment();
      for (;;) {
        try {
          callSetUps();
          break;
        } catch (id) {
          end(a, id);
        }
      }
      if (assertConcrete(), value = c, event.current = instance, 1 === index) {
        throw c = pdf, t(a, b), setFont(a, b), exec(a), c;
      }
      if (null !== node) {
        throw Error(call(261));
      }
      a.finishedWork = a.current.alternate;
      a.finishedExpirationTime = b;
      /** @type {null} */
      m = null;
      save(a);
      exec(a);
    }
    return null;
  }
  /**
   * @param {!Function} callback
   * @param {!Object} event
   * @return {?}
   */
  function track(callback, event) {
    var origValue = value;
    /** @type {number} */
    value = value | 1;
    try {
      return callback(event);
    } finally {
      if (0 === (value = origValue)) {
        log();
      }
    }
  }
  /**
   * @param {!Function} $super
   * @param {?} name
   * @return {?}
   */
  function applyStyle($super, name) {
    var origValue = value;
    /** @type {number} */
    value = value & -2;
    /** @type {number} */
    value = value | 8;
    try {
      return $super(name);
    } finally {
      if (0 === (value = origValue)) {
        log();
      }
    }
  }
  /**
   * @param {!Object} e
   * @param {?} o
   * @return {undefined}
   */
  function t(e, o) {
    /** @type {null} */
    e.finishedWork = null;
    /** @type {number} */
    e.finishedExpirationTime = 0;
    var msg = e.timeoutHandle;
    if (-1 !== msg && (e.timeoutHandle = -1, genI18nJsFile(msg)), null !== node) {
      msg = node.return;
      for (; null !== msg;) {
        var body = msg;
        switch(body.tag) {
          case 1:
            if (null !== (body = body.type.childContextTypes) && void 0 !== body) {
              required();
            }
            break;
          case 3:
            msgHasId();
            isString(nodeList);
            isString(item);
            break;
          case 5:
            updateGroupInfoItem(body);
            break;
          case 4:
            msgHasId();
            break;
          case 13:
          case 19:
            isString(opts);
            break;
          case 10:
            template(body);
        }
        msg = msg.return;
      }
    }
    /** @type {!Object} */
    m = e;
    node = send(e.current, null);
    n = o;
    /** @type {number} */
    index = undefined;
    /** @type {null} */
    pdf = null;
    /** @type {number} */
    l = r = 1073741823;
    /** @type {null} */
    currentRelations = null;
    /** @type {number} */
    offset = 0;
    /** @type {boolean} */
    Os = false;
  }
  /**
   * @param {!Object} options
   * @param {(Object|string)} e
   * @return {?}
   */
  function end(options, e) {
    for (;;) {
      try {
        if (assertConcrete(), water.current = old, Vo) {
          var entry = options.memoizedState;
          for (; null !== entry;) {
            var q = entry.queue;
            if (null !== q) {
              /** @type {null} */
              q.pending = null;
            }
            entry = entry.next;
          }
        }
        if (temp = 0, ctx = message = options = null, Vo = false, null === node || null === node.return) {
          return index = 1, pdf = e, node = null;
        }
        e: {
          /** @type {!Object} */
          var i = options;
          var x = node.return;
          var data = node;
          /** @type {(Object|string)} */
          var s = e;
          if (e = n, data.effectTag |= 2048, data.firstEffect = data.lastEffect = null, null !== s && "object" === typeof s && "function" === typeof s.then) {
            var item = s;
            if (0 === (2 & data.mode)) {
              var body = data.alternate;
              if (body) {
                data.memoizedState = body.memoizedState;
                data.expirationTime = body.expirationTime;
              } else {
                /** @type {null} */
                data.memoizedState = null;
              }
            }
            /** @type {boolean} */
            var branchRenderer = 0 !== (1 & opts.current);
            var value = x;
            do {
              var d;
              if (d = 13 === value.tag) {
                var valueId = value.memoizedState;
                if (null !== valueId) {
                  /** @type {boolean} */
                  d = null !== valueId.dehydrated;
                } else {
                  var result = value.memoizedProps;
                  /** @type {boolean} */
                  d = void 0 !== result.fallback && (true !== result.unstable_avoidThisFallback || !branchRenderer);
                }
              }
              if (d) {
                var special = value.updateQueue;
                if (null === special) {
                  /** @type {!Set} */
                  var select = new Set;
                  select.add(item);
                  /** @type {!Set} */
                  value.updateQueue = select;
                } else {
                  special.add(item);
                }
                if (0 === (2 & value.mode)) {
                  if (value.effectTag |= 64, data.effectTag &= -2981, 1 === data.tag) {
                    if (null === data.alternate) {
                      /** @type {number} */
                      data.tag = 17;
                    } else {
                      var target = parseInt(1073741823, null);
                      /** @type {number} */
                      target.tag = 2;
                      copy(data, target);
                    }
                  }
                  /** @type {number} */
                  data.expirationTime = 1073741823;
                  break e;
                }
                s = void 0;
                /** @type {(Object|string)} */
                data = e;
                var o = i.pingCache;
                if (null === o ? (o = i.pingCache = new Date, s = new Set, o.set(item, s)) : void 0 === (s = o.get(item)) && (s = new Set, o.set(item, s)), !s.has(data)) {
                  s.add(data);
                  var result = bubble.bind(null, i, item, data);
                  item.then(result, result);
                }
                value.effectTag |= 4096;
                /** @type {(Object|string)} */
                value.expirationTime = e;
                break e;
              }
              value = value.return;
            } while (null !== value);
            /** @type {!Error} */
            s = Error((each(data.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." + bind(data));
          }
          if (5 !== index) {
            /** @type {number} */
            index = 2;
          }
          s = Buffer(s, data);
          value = x;
          do {
            switch(value.tag) {
              case 3:
                item = s;
                value.effectTag |= 4096;
                /** @type {(Object|string)} */
                value.expirationTime = e;
                reduce(value, all(value, item, e));
                break e;
              case 1:
                item = s;
                var Type = value.type;
                var i = value.stateNode;
                if (0 === (64 & value.effectTag) && ("function" === typeof Type.getDerivedStateFromError || null !== i && "function" === typeof i.componentDidCatch && (null === observers || !observers.has(i)))) {
                  value.effectTag |= 4096;
                  /** @type {(Object|string)} */
                  value.expirationTime = e;
                  reduce(value, emit(value, item, e));
                  break e;
                }
            }
            value = value.return;
          } while (null !== value);
        }
        node = isExpired(node);
      } catch (f) {
        e = f;
        continue;
      }
      break;
    }
  }
  /**
   * @return {?}
   */
  function moment() {
    var original = event.current;
    return event.current = old, null === original ? old : original;
  }
  /**
   * @param {number} i
   * @param {!Object} j
   * @return {undefined}
   */
  function hash(i, j) {
    if (i < r && 2 < i) {
      /** @type {number} */
      r = i;
    }
    if (null !== j && i < l && 2 < i) {
      /** @type {number} */
      l = i;
      /** @type {!Object} */
      currentRelations = j;
    }
  }
  /**
   * @param {number} x
   * @return {undefined}
   */
  function isPresent(x) {
    if (x > offset) {
      /** @type {number} */
      offset = x;
    }
  }
  /**
   * @return {undefined}
   */
  function callSetUps() {
    for (; null !== node;) {
      node = first(node);
    }
  }
  /**
   * @return {undefined}
   */
  function getPSConfig() {
    for (; null !== node && !prevPage();) {
      node = first(node);
    }
  }
  /**
   * @param {!Object} obj
   * @return {?}
   */
  function first(obj) {
    var res = update(obj.alternate, obj, n);
    return obj.memoizedProps = obj.pendingProps, null === res && (res = isExpired(obj)), dashboard.current = null, res;
  }
  /**
   * @param {!Object} value
   * @return {?}
   */
  function isExpired(value) {
    /** @type {!Object} */
    node = value;
    do {
      var result = node.alternate;
      if (value = node.return, 0 === (2048 & node.effectTag)) {
        if (result = render(result, node, n), 1 === n || 1 !== node.childExpirationTime) {
          /** @type {number} */
          var offset = 0;
          var child = node.child;
          for (; null !== child;) {
            var i = child.expirationTime;
            var position = child.childExpirationTime;
            if (i > offset) {
              offset = i;
            }
            if (position > offset) {
              offset = position;
            }
            child = child.sibling;
          }
          node.childExpirationTime = offset;
        }
        if (null !== result) {
          return result;
        }
        if (null !== value && 0 === (2048 & value.effectTag)) {
          if (null === value.firstEffect) {
            value.firstEffect = node.firstEffect;
          }
          if (null !== node.lastEffect) {
            if (null !== value.lastEffect) {
              value.lastEffect.nextEffect = node.firstEffect;
            }
            value.lastEffect = node.lastEffect;
          }
          if (1 < node.effectTag) {
            if (null !== value.lastEffect) {
              value.lastEffect.nextEffect = node;
            } else {
              value.firstEffect = node;
            }
            value.lastEffect = node;
          }
        }
      } else {
        if (null !== (result = decode(node))) {
          return result.effectTag &= 2047, result;
        }
        if (null !== value) {
          /** @type {null} */
          value.firstEffect = value.lastEffect = null;
          value.effectTag |= 2048;
        }
      }
      if (null !== (result = node.sibling)) {
        return result;
      }
      /** @type {!Object} */
      node = value;
    } while (null !== node);
    return index === undefined && (index = 5), null;
  }
  /**
   * @param {!Object} a
   * @return {?}
   */
  function atob(a) {
    var h = a.expirationTime;
    return h > (a = a.childExpirationTime) ? h : a;
  }
  /**
   * @param {!Object} type
   * @return {?}
   */
  function save(type) {
    var message = then();
    return drop(99, init.bind(null, type, message)), null;
  }
  /**
   * @param {!Object} e
   * @param {number} p
   * @return {?}
   */
  function init(e, p) {
    do {
      readFileSync();
    } while (null !== point);
    if (0 !== (48 & value)) {
      throw Error(call(327));
    }
    var data = e.finishedWork;
    var xhr = e.finishedExpirationTime;
    if (null === data) {
      return null;
    }
    if (e.finishedWork = null, e.finishedExpirationTime = 0, data === e.current) {
      throw Error(call(177));
    }
    /** @type {null} */
    e.callbackNode = null;
    /** @type {number} */
    e.callbackExpirationTime = 0;
    /** @type {number} */
    e.callbackPriority = 90;
    /** @type {number} */
    e.nextKnownPendingLevel = 0;
    var str = atob(data);
    if (e.firstPendingTime = str, xhr <= e.lastSuspendedTime ? e.firstSuspendedTime = e.lastSuspendedTime = e.nextKnownPendingLevel = 0 : xhr <= e.firstSuspendedTime && (e.firstSuspendedTime = xhr - 1), xhr <= e.lastPingedTime && (e.lastPingedTime = 0), xhr <= e.lastExpiredTime && (e.lastExpiredTime = 0), e === m && (node = m = null, n = 0), 1 < data.effectTag ? null !== data.lastEffect ? (data.lastEffect.nextEffect = data, str = data.firstEffect) : str = data : str = data.firstEffect, null !== str) {
      var origValue = value;
      /** @type {number} */
      value = value | 32;
      /** @type {null} */
      dashboard.current = null;
      interestingPoint = viewportCenter;
      var element = addScript();
      if (handleKeyEvent(element)) {
        if ("selectionStart" in element) {
          var node = {
            start : element.selectionStart,
            end : element.selectionEnd
          };
        } else {
          e: {
            var sel = (node = (node = element.ownerDocument) && node.defaultView || window).getSelection && node.getSelection();
            if (sel && 0 !== sel.rangeCount) {
              node = sel.anchorNode;
              var value = sel.anchorOffset;
              var data = sel.focusNode;
              sel = sel.focusOffset;
              try {
                node.nodeType;
                data.nodeType;
              } catch (M) {
                /** @type {null} */
                node = null;
                break e;
              }
              /** @type {number} */
              var prefix = 0;
              /** @type {number} */
              var s = -1;
              /** @type {number} */
              var e = -1;
              /** @type {number} */
              var i = 0;
              /** @type {number} */
              var m = 0;
              var el = element;
              /** @type {null} */
              var target = null;
              t: for (;;) {
                var sib;
                for (; el !== node || 0 !== value && 3 !== el.nodeType || (s = prefix + value), el !== data || 0 !== sel && 3 !== el.nodeType || (e = prefix + sel), 3 === el.nodeType && (prefix = prefix + el.nodeValue.length), null !== (sib = el.firstChild);) {
                  target = el;
                  el = sib;
                }
                for (;;) {
                  if (el === element) {
                    break t;
                  }
                  if (target === node && ++i === value && (s = prefix), target === data && ++m === sel && (e = prefix), null !== (sib = el.nextSibling)) {
                    break;
                  }
                  target = (el = target).parentNode;
                }
                el = sib;
              }
              /** @type {(null|{end: ?, start: ?})} */
              node = -1 === s || -1 === e ? null : {
                start : s,
                end : e
              };
            } else {
              /** @type {null} */
              node = null;
            }
          }
        }
        /** @type {({end: ?, start: ?}|{end: number, start: number})} */
        node = node || {
          start : 0,
          end : 0
        };
      } else {
        /** @type {null} */
        node = null;
      }
      temTarget = {
        activeElementDetached : null,
        focusedElem : element,
        selectionRange : node
      };
      /** @type {boolean} */
      viewportCenter = false;
      obj = str;
      do {
        try {
          setupSharedHelpers();
        } catch (aCommands) {
          if (null === obj) {
            throw Error(call(330));
          }
          extend(obj, aCommands);
          obj = obj.nextEffect;
        }
      } while (null !== obj);
      obj = str;
      do {
        try {
          /** @type {!Object} */
          element = e;
          /** @type {number} */
          node = p;
          for (; null !== obj;) {
            var el = obj.effectTag;
            if (16 & el && append(obj.stateNode, ""), 128 & el) {
              var s = obj.alternate;
              if (null !== s) {
                var target = s.ref;
                if (null !== target) {
                  if ("function" === typeof target) {
                    target(null);
                  } else {
                    /** @type {null} */
                    target.current = null;
                  }
                }
              }
            }
            switch(1038 & el) {
              case 2:
                wrapper(obj);
                obj.effectTag &= -3;
                break;
              case 6:
                wrapper(obj);
                obj.effectTag &= -3;
                initialize(obj.alternate, obj);
                break;
              case 1024:
                obj.effectTag &= -1025;
                break;
              case 1028:
                obj.effectTag &= -1025;
                initialize(obj.alternate, obj);
                break;
              case 4:
                initialize(obj.alternate, obj);
                break;
              case 8:
                merge(element, value = obj, node);
                repeat(value);
            }
            obj = obj.nextEffect;
          }
        } catch (aCommands) {
          if (null === obj) {
            throw Error(call(330));
          }
          extend(obj, aCommands);
          obj = obj.nextEffect;
        }
      } while (null !== obj);
      if (target = temTarget, s = addScript(), el = target.focusedElem, node = target.selectionRange, s !== el && el && el.ownerDocument && function contains(b, a) {
        return !(!b || !a) && (b === a || (!b || 3 !== b.nodeType) && (a && 3 === a.nodeType ? contains(b, a.parentNode) : "contains" in b ? b.contains(a) : !!b.compareDocumentPosition && !!(16 & b.compareDocumentPosition(a))));
      }(el.ownerDocument.documentElement, el)) {
        if (null !== node && handleKeyEvent(el)) {
          s = node.start;
          if (void 0 === (target = node.end)) {
            target = s;
          }
          if ("selectionStart" in el) {
            el.selectionStart = s;
            /** @type {number} */
            el.selectionEnd = Math.min(target, el.value.length);
          } else {
            if ((target = (s = el.ownerDocument || document) && s.defaultView || window).getSelection) {
              target = target.getSelection();
              value = el.textContent.length;
              /** @type {number} */
              element = Math.min(node.start, value);
              /** @type {number} */
              node = void 0 === node.end ? element : Math.min(node.end, value);
              if (!target.extend && element > node) {
                /** @type {number} */
                value = node;
                /** @type {number} */
                node = element;
                /** @type {number} */
                element = value;
              }
              value = _findDomPosition(el, element);
              data = _findDomPosition(el, node);
              if (value && data && (1 !== target.rangeCount || target.anchorNode !== value.node || target.anchorOffset !== value.offset || target.focusNode !== data.node || target.focusOffset !== data.offset)) {
                (s = s.createRange()).setStart(value.node, value.offset);
                target.removeAllRanges();
                if (element > node) {
                  target.addRange(s);
                  target.extend(data.node, data.offset);
                } else {
                  s.setEnd(data.node, data.offset);
                  target.addRange(s);
                }
              }
            }
          }
        }
        /** @type {!Array} */
        s = [];
        target = el;
        for (; target = target.parentNode;) {
          if (1 === target.nodeType) {
            s.push({
              element : target,
              left : target.scrollLeft,
              top : target.scrollTop
            });
          }
        }
        if ("function" === typeof el.focus) {
          el.focus();
        }
        /** @type {number} */
        el = 0;
        for (; el < s.length; el++) {
          (target = s[el]).element.scrollLeft = target.left;
          target.element.scrollTop = target.top;
        }
      }
      /** @type {boolean} */
      viewportCenter = !!interestingPoint;
      /** @type {null} */
      temTarget = interestingPoint = null;
      e.current = data;
      obj = str;
      do {
        try {
          /** @type {!Object} */
          el = e;
          for (; null !== obj;) {
            var hitBreakpoints = obj.effectTag;
            if (36 & hitBreakpoints && link(el, obj.alternate, obj), 128 & hitBreakpoints) {
              s = void 0;
              var a = obj.ref;
              if (null !== a) {
                var sql = obj.stateNode;
                switch(obj.tag) {
                  case 5:
                    s = sql;
                    break;
                  default:
                    s = sql;
                }
                if ("function" === typeof a) {
                  a(s);
                } else {
                  a.current = s;
                }
              }
            }
            obj = obj.nextEffect;
          }
        } catch (aCommands) {
          if (null === obj) {
            throw Error(call(330));
          }
          extend(obj, aCommands);
          obj = obj.nextEffect;
        }
      } while (null !== obj);
      /** @type {null} */
      obj = null;
      parseStoreDir();
      value = origValue;
    } else {
      e.current = data;
    }
    if (zs) {
      /** @type {boolean} */
      zs = false;
      /** @type {!Object} */
      point = e;
      /** @type {number} */
      p2 = p;
    } else {
      obj = str;
      for (; null !== obj;) {
        p = obj.nextEffect;
        /** @type {null} */
        obj.nextEffect = null;
        /** @type {number} */
        obj = p;
      }
    }
    if (0 === (p = e.firstPendingTime) && (observers = null), 1073741823 === p ? e === caller ? _t$FLIPPED_ALIAS_KEYS++ : (_t$FLIPPED_ALIAS_KEYS = 0, caller = e) : _t$FLIPPED_ALIAS_KEYS = 0, "function" === typeof onComplete && onComplete(data.stateNode, xhr), exec(e), ref1$) {
      throw ref1$ = false, e = realEvent, realEvent = null, e;
    }
    return 0 !== (8 & value) || log(), null;
  }
  /**
   * @return {undefined}
   */
  function setupSharedHelpers() {
    for (; null !== obj;) {
      var hitBreakpoints = obj.effectTag;
      if (0 !== (256 & hitBreakpoints)) {
        print(obj.alternate, obj);
      }
      if (!(0 === (512 & hitBreakpoints) || zs)) {
        /** @type {boolean} */
        zs = true;
        multiply(97, function() {
          return readFileSync(), null;
        });
      }
      obj = obj.nextEffect;
    }
  }
  /**
   * @return {?}
   */
  function readFileSync() {
    if (90 !== p2) {
      var id = 97 < p2 ? 97 : p2;
      return p2 = 90, drop(id, del);
    }
  }
  /**
   * @return {?}
   */
  function del() {
    if (null === point) {
      return false;
    }
    var current = point;
    if (point = null, 0 !== (48 & value)) {
      throw Error(call(331));
    }
    var origValue = value;
    /** @type {number} */
    value = value | 32;
    current = current.current.firstEffect;
    for (; null !== current;) {
      try {
        var i = current;
        if (0 !== (512 & i.effectTag)) {
          switch(i.tag) {
            case 0:
            case 11:
            case 15:
            case 22:
              register(5, i);
              tokenize(5, i);
          }
        }
      } catch (aCommands) {
        if (null === current) {
          throw Error(call(330));
        }
        extend(current, aCommands);
      }
      i = current.nextEffect;
      /** @type {null} */
      current.nextEffect = null;
      current = i;
    }
    return value = origValue, log(), true;
  }
  /**
   * @param {!Object} node
   * @param {!Object} data
   * @param {!Object} key
   * @return {undefined}
   */
  function length(node, data, key) {
    copy(node, data = all(node, data = Buffer(key, data), 1073741823));
    if (null !== (node = toString(node, 1073741823))) {
      exec(node);
    }
  }
  /**
   * @param {!Object} data
   * @param {!Object} count
   * @return {undefined}
   */
  function extend(data, count) {
    if (3 === data.tag) {
      length(data, data, count);
    } else {
      var node = data.return;
      for (; null !== node;) {
        if (3 === node.tag) {
          length(node, data, count);
          break;
        }
        if (1 === node.tag) {
          var key = node.stateNode;
          if ("function" === typeof node.type.getDerivedStateFromError || "function" === typeof key.componentDidCatch && (null === observers || !observers.has(key))) {
            copy(node, data = emit(node, data = Buffer(count, data), 1073741823));
            if (null !== (node = toString(node, 1073741823))) {
              exec(node);
            }
            break;
          }
        }
        node = node.return;
      }
    }
  }
  /**
   * @param {undefined} data
   * @param {string} x
   * @param {string} r
   * @return {undefined}
   */
  function bubble(data, x, r) {
    var index = data.pingCache;
    if (null !== index) {
      index.delete(x);
    }
    if (m === data && n === r) {
      if (index === arg1 || index === startIndex && 1073741823 === r && getTime() - startTime < 500) {
        t(data, n);
      } else {
        /** @type {boolean} */
        Os = true;
      }
    } else {
      if (swap(data, r)) {
        if (!(0 !== (x = data.lastPingedTime) && x < r)) {
          /** @type {string} */
          data.lastPingedTime = r;
          exec(data);
        }
      }
    }
  }
  /**
   * @param {!Array} node
   * @param {number} value
   * @return {undefined}
   */
  function g(node, value) {
    var r = node.stateNode;
    if (null !== r) {
      r.delete(value);
    }
    if (0 === (value = 0)) {
      value = map(value = parseFloat(), node, null);
    }
    if (null !== (node = toString(node, value))) {
      exec(node);
    }
  }
  /**
   * @param {string} tag
   * @param {?} classes
   * @param {string} name
   * @param {number} type
   * @return {undefined}
   */
  function Node(tag, classes, name, type) {
    /** @type {string} */
    this.tag = tag;
    /** @type {string} */
    this.key = name;
    /** @type {null} */
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    /** @type {number} */
    this.index = 0;
    /** @type {null} */
    this.ref = null;
    this.pendingProps = classes;
    /** @type {null} */
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    /** @type {number} */
    this.mode = type;
    /** @type {number} */
    this.effectTag = 0;
    /** @type {null} */
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    /** @type {number} */
    this.childExpirationTime = this.expirationTime = 0;
    /** @type {null} */
    this.alternate = null;
  }
  /**
   * @param {number} token
   * @param {!Object} type
   * @param {!Object} def
   * @param {number} name
   * @return {?}
   */
  function f(token, type, def, name) {
    return new Node(token, type, def, name);
  }
  /**
   * @param {!Object} x
   * @return {?}
   */
  function createElement(x) {
    return !(!(x = x.prototype) || !x.isReactComponent);
  }
  /**
   * @param {!Object} options
   * @param {!Object} value
   * @return {?}
   */
  function send(options, value) {
    var node = options.alternate;
    return null === node ? ((node = f(options.tag, value, options.key, options.mode)).elementType = options.elementType, node.type = options.type, node.stateNode = options.stateNode, node.alternate = options, options.alternate = node) : (node.pendingProps = value, node.effectTag = 0, node.nextEffect = null, node.firstEffect = null, node.lastEffect = null), node.childExpirationTime = options.childExpirationTime, node.expirationTime = options.expirationTime, node.child = options.child, node.memoizedProps = 
    options.memoizedProps, node.memoizedState = options.memoizedState, node.updateQueue = options.updateQueue, value = options.dependencies, node.dependencies = null === value ? null : {
      expirationTime : value.expirationTime,
      firstContext : value.firstContext,
      responders : value.responders
    }, node.sibling = options.sibling, node.index = options.index, node.ref = options.ref, node;
  }
  /**
   * @param {!Object} node
   * @param {!Object} value
   * @param {!Object} opts
   * @param {!Object} a
   * @param {number} t
   * @param {!Object} i
   * @return {?}
   */
  function func(node, value, opts, a, t, i) {
    /** @type {number} */
    var s = 2;
    if (a = node, "function" === typeof node) {
      if (createElement(node)) {
        /** @type {number} */
        s = 1;
      }
    } else {
      if ("string" === typeof node) {
        /** @type {number} */
        s = 5;
      } else {
        e: {
          switch(node) {
            case string:
              return format(opts.children, t, i, value);
            case edge:
              /** @type {number} */
              s = 8;
              /** @type {number} */
              t = t | 7;
              break;
            case binary:
              /** @type {number} */
              s = 8;
              /** @type {number} */
              t = t | 1;
              break;
            case type:
              return (node = f(12, opts, value, 8 | t)).elementType = type, node.type = type, node.expirationTime = i, node;
            case NODE_RULE_VALUE:
              return (node = f(13, opts, value, t)).type = NODE_RULE_VALUE, node.elementType = NODE_RULE_VALUE, node.expirationTime = i, node;
            case tempMatch:
              return (node = f(19, opts, value, t)).elementType = tempMatch, node.expirationTime = i, node;
            default:
              if ("object" === typeof node && null !== node) {
                switch(node.$$typeof) {
                  case box:
                    /** @type {number} */
                    s = 10;
                    break e;
                  case xmlstring:
                    /** @type {number} */
                    s = 9;
                    break e;
                  case column:
                    /** @type {number} */
                    s = 11;
                    break e;
                  case years:
                    /** @type {number} */
                    s = 14;
                    break e;
                  case MUTATE_INSERT:
                    /** @type {number} */
                    s = 16;
                    /** @type {null} */
                    a = null;
                    break e;
                  case getScriptLexicalStructure:
                    /** @type {number} */
                    s = 22;
                    break e;
                }
              }
              throw Error(call(130, null == node ? node : typeof node, ""));
          }
        }
      }
    }
    return (value = f(s, opts, value, t)).elementType = node, value.type = a, value.expirationTime = i, value;
  }
  /**
   * @param {string} result
   * @param {number} message
   * @param {!Object} source
   * @param {!Object} d
   * @return {?}
   */
  function format(result, message, source, d) {
    return (result = f(7, result, d, message)).expirationTime = source, result;
  }
  /**
   * @param {!Object} y
   * @param {undefined} p
   * @param {!Object} c
   * @return {?}
   */
  function cb(y, p, c) {
    return (y = f(6, y, null, p)).expirationTime = c, y;
  }
  /**
   * @param {!Object} self
   * @param {number} message
   * @param {!Object} elem
   * @return {?}
   */
  function change(self, message, elem) {
    return (message = f(4, null !== self.children ? self.children : [], self.key, message)).expirationTime = elem, message.stateNode = {
      containerInfo : self.containerInfo,
      pendingChildren : null,
      implementation : self.implementation
    }, message;
  }
  /**
   * @param {?} prefix
   * @param {string} tag
   * @param {?} extra
   * @return {undefined}
   */
  function Element(prefix, tag, extra) {
    /** @type {string} */
    this.tag = tag;
    /** @type {null} */
    this.current = null;
    this.containerInfo = prefix;
    /** @type {null} */
    this.pingCache = this.pendingChildren = null;
    /** @type {number} */
    this.finishedExpirationTime = 0;
    /** @type {null} */
    this.finishedWork = null;
    /** @type {number} */
    this.timeoutHandle = -1;
    /** @type {null} */
    this.pendingContext = this.context = null;
    this.hydrate = extra;
    /** @type {null} */
    this.callbackNode = null;
    /** @type {number} */
    this.callbackPriority = 90;
    /** @type {number} */
    this.lastExpiredTime = this.lastPingedTime = this.nextKnownPendingLevel = this.lastSuspendedTime = this.firstSuspendedTime = this.firstPendingTime = 0;
  }
  /**
   * @param {!Object} i
   * @param {!Object} n
   * @return {?}
   */
  function swap(i, n) {
    var j = i.firstSuspendedTime;
    return i = i.lastSuspendedTime, 0 !== j && j >= n && i <= n;
  }
  /**
   * @param {!Object} b
   * @param {!Object} a
   * @return {undefined}
   */
  function setFont(b, a) {
    var x = b.firstSuspendedTime;
    var i = b.lastSuspendedTime;
    if (x < a) {
      /** @type {!Object} */
      b.firstSuspendedTime = a;
    }
    if (i > a || 0 === x) {
      /** @type {!Object} */
      b.lastSuspendedTime = a;
    }
    if (a <= b.lastPingedTime) {
      /** @type {number} */
      b.lastPingedTime = 0;
    }
    if (a <= b.lastExpiredTime) {
      /** @type {number} */
      b.lastExpiredTime = 0;
    }
  }
  /**
   * @param {!Object} p
   * @param {number} x
   * @return {undefined}
   */
  function _extends(p, x) {
    if (x > p.firstPendingTime) {
      /** @type {number} */
      p.firstPendingTime = x;
    }
    var mx = p.firstSuspendedTime;
    if (0 !== mx) {
      if (x >= mx) {
        /** @type {number} */
        p.firstSuspendedTime = p.lastSuspendedTime = p.nextKnownPendingLevel = 0;
      } else {
        if (x >= p.lastSuspendedTime) {
          p.lastSuspendedTime = x + 1;
        }
      }
      if (x > p.nextKnownPendingLevel) {
        /** @type {number} */
        p.nextKnownPendingLevel = x;
      }
    }
  }
  /**
   * @param {!Object} elem
   * @param {?} val
   * @return {undefined}
   */
  function eq(elem, val) {
    var index = elem.lastExpiredTime;
    if (0 === index || index > val) {
      elem.lastExpiredTime = val;
    }
  }
  /**
   * @param {string} el
   * @param {!Object} item
   * @param {!Object} data
   * @param {string} fn
   * @return {?}
   */
  function filter(el, item, data, fn) {
    var date = item.current;
    var index = parseFloat();
    var i = config.suspense;
    index = map(index, date, i);
    e: {
      if (data) {
        t: {
          if (assert(data = data._reactInternalFiber) !== data || 1 !== data.tag) {
            throw Error(call(170));
          }
          /** @type {!Object} */
          var value = data;
          do {
            switch(value.tag) {
              case 3:
                value = value.stateNode.context;
                break t;
              case 1:
                if (isFunction(value.type)) {
                  value = value.stateNode.__reactInternalMemoizedMergedChildContext;
                  break t;
                }
            }
            value = value.return;
          } while (null !== value);
          throw Error(call(171));
        }
        if (1 === data.tag) {
          var actions = data.type;
          if (isFunction(actions)) {
            data = store(data, actions, value);
            break e;
          }
        }
        data = value;
      } else {
        data = root;
      }
    }
    return null === item.context ? item.context = data : item.pendingContext = data, (item = parseInt(index, i)).payload = {
      element : el
    }, null !== (fn = void 0 === fn ? null : fn) && (item.callback = fn), copy(date, item), test(date, index), index;
  }
  /**
   * @param {!Object} data
   * @return {?}
   */
  function evaluate(data) {
    if (!(data = data.current).child) {
      return null;
    }
    switch(data.child.tag) {
      case 5:
      default:
        return data.child.stateNode;
    }
  }
  /**
   * @param {(Object|string)} current
   * @param {number} value
   * @return {undefined}
   */
  function move(current, value) {
    if (null !== (current = current.memoizedState) && null !== current.dehydrated && current.retryTime < value) {
      /** @type {number} */
      current.retryTime = value;
    }
  }
  /**
   * @param {!Object} node
   * @param {number} data
   * @return {undefined}
   */
  function unshift(node, data) {
    move(node, data);
    if (node = node.alternate) {
      move(node, data);
    }
  }
  /**
   * @param {!Element} target
   * @param {number} options
   * @param {!Object} data
   * @return {undefined}
   */
  function a(target, options, data) {
    var result = new Element(target, options, data = null != data && true === data.hydrate);
    var message = f(3, null, null, 2 === options ? 7 : 1 === options ? 3 : 0);
    result.current = message;
    message.stateNode = result;
    ok(message);
    target[key] = result.current;
    if (data && 0 !== options) {
      (function(addedRenderer, obj) {
        var opts = setOptions(obj);
        related_node_ids.forEach(function(e) {
          get(e, obj, opts);
        });
        pipelets.forEach(function(e) {
          get(e, obj, opts);
        });
      })(0, 9 === target.nodeType ? target : target.ownerDocument);
    }
    this._internalRoot = result;
  }
  /**
   * @param {!Object} dom
   * @return {?}
   */
  function extract(dom) {
    return !(!dom || 1 !== dom.nodeType && 9 !== dom.nodeType && 11 !== dom.nodeType && (8 !== dom.nodeType || " react-mount-point-unstable " !== dom.nodeValue));
  }
  /**
   * @param {!Object} i
   * @param {string} fn
   * @param {string} result
   * @param {string} pos
   * @param {!Function} callback
   * @return {?}
   */
  function show(i, fn, result, pos, callback) {
    var content = result._reactRootContainer;
    if (content) {
      var element = content._internalRoot;
      if ("function" === typeof callback) {
        /** @type {!Function} */
        var fn = callback;
        /**
         * @return {undefined}
         */
        callback = function() {
          var val = evaluate(element);
          fn.call(val);
        };
      }
      filter(fn, element, i, callback);
    } else {
      if (content = result._reactRootContainer = function(p, s) {
        if (s || (s = !(!(s = p ? 9 === p.nodeType ? p.documentElement : p.firstChild : null) || 1 !== s.nodeType || !s.hasAttribute("data-reactroot"))), !s) {
          var prev;
          for (; prev = p.lastChild;) {
            p.removeChild(prev);
          }
        }
        return new a(p, 0, s ? {
          hydrate : true
        } : void 0);
      }(result, pos), element = content._internalRoot, "function" === typeof callback) {
        /** @type {!Function} */
        var fn = callback;
        /**
         * @return {undefined}
         */
        callback = function() {
          var val = evaluate(element);
          fn.call(val);
        };
      }
      applyStyle(function() {
        filter(fn, element, i, callback);
      });
    }
    return evaluate(element);
  }
  /**
   * @param {!Array} headers
   * @param {!Object} fn
   * @param {!Object} data
   * @return {?}
   */
  function when(headers, fn, data) {
    var title = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof : array,
      key : null == title ? null : "" + title,
      children : headers,
      containerInfo : fn,
      implementation : data
    };
  }
  /**
   * @param {!Array} data
   * @param {!Object} name
   * @return {?}
   */
  function loader(data, name) {
    var progress = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!extract(name)) {
      throw Error(call(200));
    }
    return when(data, name, null, progress);
  }
  var React = __webpack_require__(0);
  var assign = __webpack_require__(61);
  var app = __webpack_require__(113);
  if (!React) {
    throw Error(call(227));
  }
  /** @type {boolean} */
  var res = false;
  /** @type {null} */
  var active = null;
  /** @type {boolean} */
  var $b = false;
  /** @type {null} */
  var location = null;
  var date = {
    onError : function(xhr) {
      /** @type {boolean} */
      res = true;
      /** @type {!Object} */
      active = xhr;
    }
  };
  /** @type {null} */
  var parent = null;
  /** @type {null} */
  var markNodeAsRequired = null;
  /** @type {null} */
  var warning = null;
  var me = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  if (!me.hasOwnProperty("ReactCurrentDispatcher")) {
    me.ReactCurrentDispatcher = {
      current : null
    };
  }
  if (!me.hasOwnProperty("ReactCurrentBatchConfig")) {
    me.ReactCurrentBatchConfig = {
      suspense : null
    };
  }
  /** @type {!RegExp} */
  var inputRegExp = /^(.*)[\\\/]/;
  /** @type {(boolean|function(string): (?|undefined))} */
  var isDeep = "function" === typeof Symbol && Symbol.for;
  var buffer = isDeep ? Symbol.for("react.element") : 60103;
  var array = isDeep ? Symbol.for("react.portal") : 60106;
  var string = isDeep ? Symbol.for("react.fragment") : 60107;
  var binary = isDeep ? Symbol.for("react.strict_mode") : 60108;
  var type = isDeep ? Symbol.for("react.profiler") : 60114;
  var box = isDeep ? Symbol.for("react.provider") : 60109;
  var xmlstring = isDeep ? Symbol.for("react.context") : 60110;
  var edge = isDeep ? Symbol.for("react.concurrent_mode") : 60111;
  var column = isDeep ? Symbol.for("react.forward_ref") : 60112;
  var NODE_RULE_VALUE = isDeep ? Symbol.for("react.suspense") : 60113;
  var tempMatch = isDeep ? Symbol.for("react.suspense_list") : 60120;
  var years = isDeep ? Symbol.for("react.memo") : 60115;
  var MUTATE_INSERT = isDeep ? Symbol.for("react.lazy") : 60116;
  var getScriptLexicalStructure = isDeep ? Symbol.for("react.block") : 60121;
  var special = "function" === typeof Symbol && Symbol.iterator;
  /** @type {null} */
  var exact_keys = null;
  var state = {};
  /** @type {!Array} */
  var rels = [];
  var lstnrs = {};
  var dependencies = {};
  var props = {};
  /** @type {boolean} */
  var val = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
  /** @type {null} */
  var callback = null;
  /** @type {null} */
  var localCanvas = null;
  /** @type {null} */
  var images = null;
  /** @type {function(!Function, !Object): ?} */
  var cmd = command;
  /** @type {boolean} */
  var searchScope = false;
  /** @type {boolean} */
  var ae = false;
  /** @type {!RegExp} */
  var VALID_IDENTIFIER_EXPR = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
  /** @type {function(this:Object, *): boolean} */
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var eddy = {};
  var formattedConfig = {};
  var args = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
    args[e] = new ProjectionPlan(e, 0, false, e, null, false);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(nameAndE) {
    var e = nameAndE[0];
    args[e] = new ProjectionPlan(e, 1, false, nameAndE[1], null, false);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 2, false, e.toLowerCase(), null, false);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 2, false, e, null, false);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
    args[e] = new ProjectionPlan(e, 3, false, e.toLowerCase(), null, false);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 3, true, e, null, false);
  });
  ["capture", "download"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 4, false, e, null, false);
  });
  ["cols", "rows", "size", "span"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 6, false, e, null, false);
  });
  ["rowSpan", "start"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 5, false, e.toLowerCase(), null, false);
  });
  /** @type {!RegExp} */
  var R_TIMEZONE = /[\-:]([a-z])/g;
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(originalBaseURL) {
    /** @type {string} */
    var e = originalBaseURL.replace(R_TIMEZONE, base);
    args[e] = new ProjectionPlan(e, 1, false, originalBaseURL, null, false);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(originalBaseURL) {
    /** @type {string} */
    var e = originalBaseURL.replace(R_TIMEZONE, base);
    args[e] = new ProjectionPlan(e, 1, false, originalBaseURL, "http://www.w3.org/1999/xlink", false);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function(originalBaseURL) {
    var e = originalBaseURL.replace(R_TIMEZONE, base);
    args[e] = new ProjectionPlan(e, 1, false, originalBaseURL, "http://www.w3.org/XML/1998/namespace", false);
  });
  ["tabIndex", "crossOrigin"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 1, false, e.toLowerCase(), null, false);
  });
  args.xlinkHref = new ProjectionPlan("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true);
  ["src", "href", "action", "formAction"].forEach(function(e) {
    args[e] = new ProjectionPlan(e, 1, false, e.toLowerCase(), null, true);
  });
  /** @type {string} */
  var UnknownUnknown = "http://www.w3.org/1999/xhtml";
  /** @type {string} */
  var stylens = "http://www.w3.org/2000/svg";
  var summary;
  var warn = function(cb) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(obsOrValue, password, n, i) {
      MSApp.execUnsafeLocalFunction(function() {
        return cb(obsOrValue, password);
      });
    } : cb;
  }(function(target, key) {
    if (target.namespaceURI !== stylens || "innerHTML" in target) {
      /** @type {!Object} */
      target.innerHTML = key;
    } else {
      /** @type {string} */
      (summary = summary || document.createElement("div")).innerHTML = "<svg>" + key.valueOf().toString() + "</svg>";
      key = summary.firstChild;
      for (; target.firstChild;) {
        target.removeChild(target.firstChild);
      }
      for (; key.firstChild;) {
        target.appendChild(key.firstChild);
      }
    }
  });
  var EVENT_NAME_MAP = {
    animationend : _prefixedEvent("Animation", "AnimationEnd"),
    animationiteration : _prefixedEvent("Animation", "AnimationIteration"),
    animationstart : _prefixedEvent("Animation", "AnimationStart"),
    transitionend : _prefixedEvent("Transition", "TransitionEnd")
  };
  var dict = {};
  var elem = {};
  if (val) {
    /** @type {!CSSStyleDeclaration} */
    elem = document.createElement("div").style;
    if (!("AnimationEvent" in window)) {
      delete EVENT_NAME_MAP.animationend.animation;
      delete EVENT_NAME_MAP.animationiteration.animation;
      delete EVENT_NAME_MAP.animationstart.animation;
    }
    if (!("TransitionEvent" in window)) {
      delete EVENT_NAME_MAP.transitionend.transition;
    }
  }
  var firstListItemStyle = getComputedStyle("animationend");
  var scatterChart = getComputedStyle("animationiteration");
  var string_object_array = getComputedStyle("animationstart");
  var transEnd = getComputedStyle("transitionend");
  /** @type {!Array<string>} */
  var info = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
  var ss = new ("function" === typeof WeakMap ? WeakMap : Map);
  /** @type {null} */
  var c = null;
  /** @type {!Array} */
  var deadPool = [];
  var draw;
  var flatten;
  var match;
  /** @type {boolean} */
  var vt = false;
  /** @type {!Array} */
  var data = [];
  /** @type {null} */
  var result = null;
  /** @type {null} */
  var url = null;
  /** @type {null} */
  var v = null;
  /** @type {!Map} */
  var target = new Map;
  /** @type {!Map} */
  var cache = new Map;
  /** @type {!Array} */
  var params = [];
  /** @type {!Array<string>} */
  var related_node_ids = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" ");
  /** @type {!Array<string>} */
  var pipelets = "focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" ");
  var eventTypes = {};
  /** @type {!Map} */
  var executionContextNamesByOrigin = new Map;
  /** @type {!Map} */
  var span = new Map;
  /** @type {!Array} */
  var events = ["abort", "abort", firstListItemStyle, "animationEnd", scatterChart, "animationIteration", string_object_array, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", 
  "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", transEnd, "transitionEnd", "waiting", "waiting"];
  dispatchEvent("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 
  0);
  dispatchEvent("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
  dispatchEvent(events, 2);
  /** @type {!Array<string>} */
  var datas = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" ");
  /** @type {number} */
  var ii = 0;
  for (; ii < datas.length; ii++) {
    span.set(datas[ii], 0);
  }
  var p = app.unstable_UserBlockingPriority;
  var skip = app.unstable_runWithPriority;
  /** @type {boolean} */
  var viewportCenter = true;
  var isUnitlessNumber = {
    animationIterationCount : true,
    borderImageOutset : true,
    borderImageSlice : true,
    borderImageWidth : true,
    boxFlex : true,
    boxFlexGroup : true,
    boxOrdinalGroup : true,
    columnCount : true,
    columns : true,
    flex : true,
    flexGrow : true,
    flexPositive : true,
    flexShrink : true,
    flexNegative : true,
    flexOrder : true,
    gridArea : true,
    gridRow : true,
    gridRowEnd : true,
    gridRowSpan : true,
    gridRowStart : true,
    gridColumn : true,
    gridColumnEnd : true,
    gridColumnSpan : true,
    gridColumnStart : true,
    fontWeight : true,
    lineClamp : true,
    lineHeight : true,
    opacity : true,
    order : true,
    orphans : true,
    tabSize : true,
    widows : true,
    zIndex : true,
    zoom : true,
    fillOpacity : true,
    floodOpacity : true,
    stopOpacity : true,
    strokeDasharray : true,
    strokeDashoffset : true,
    strokeMiterlimit : true,
    strokeOpacity : true,
    strokeWidth : true
  };
  /** @type {!Array} */
  var prefixes = ["Webkit", "ms", "Moz", "O"];
  Object.keys(isUnitlessNumber).forEach(function(prop) {
    prefixes.forEach(function(key) {
      /** @type {string} */
      key = key + prop.charAt(0).toUpperCase() + prop.substring(1);
      isUnitlessNumber[key] = isUnitlessNumber[prop];
    });
  });
  var minimizeOptions = assign({
    menuitem : true
  }, {
    area : true,
    base : true,
    br : true,
    col : true,
    embed : true,
    hr : true,
    img : true,
    input : true,
    keygen : true,
    link : true,
    meta : true,
    param : true,
    source : true,
    track : true,
    wbr : true
  });
  /** @type {string} */
  var dir = UnknownUnknown;
  /** @type {null} */
  var interestingPoint = null;
  /** @type {null} */
  var temTarget = null;
  /** @type {(function((!Function|null|string), number=, ...*): number|undefined)} */
  var equal = "function" === typeof setTimeout ? setTimeout : void 0;
  /** @type {(function((null|number|undefined)): undefined|undefined)} */
  var genI18nJsFile = "function" === typeof clearTimeout ? clearTimeout : void 0;
  /** @type {string} */
  var timestamp = Math.random().toString(36).slice(2);
  /** @type {string} */
  var id = "__reactInternalInstance$" + timestamp;
  /** @type {string} */
  var k = "__reactEventHandlers$" + timestamp;
  /** @type {string} */
  var key = "__reactContainere$" + timestamp;
  /** @type {null} */
  var cursor = null;
  /** @type {null} */
  var storeOptions = null;
  /** @type {null} */
  var actions = null;
  assign(Event.prototype, {
    preventDefault : function() {
      /** @type {boolean} */
      this.defaultPrevented = true;
      var event = this.nativeEvent;
      if (event) {
        if (event.preventDefault) {
          event.preventDefault();
        } else {
          if ("unknown" !== typeof event.returnValue) {
            /** @type {boolean} */
            event.returnValue = false;
          }
        }
        /** @type {function(): ?} */
        this.isDefaultPrevented = returnTrue;
      }
    },
    stopPropagation : function() {
      var event = this.nativeEvent;
      if (event) {
        if (event.stopPropagation) {
          event.stopPropagation();
        } else {
          if ("unknown" !== typeof event.cancelBubble) {
            /** @type {boolean} */
            event.cancelBubble = true;
          }
        }
        /** @type {function(): ?} */
        this.isPropagationStopped = returnTrue;
      }
    },
    persist : function() {
      /** @type {function(): ?} */
      this.isPersistent = returnTrue;
    },
    isPersistent : returnFalse,
    destructor : function() {
      var propName;
      var Interface = this.constructor.Interface;
      for (propName in Interface) {
        /** @type {null} */
        this[propName] = null;
      }
      /** @type {null} */
      this.nativeEvent = this._targetInst = this.dispatchConfig = null;
      /** @type {function(): ?} */
      this.isPropagationStopped = this.isDefaultPrevented = returnFalse;
      /** @type {null} */
      this._dispatchInstances = this._dispatchListeners = null;
    }
  });
  Event.Interface = {
    type : null,
    target : null,
    currentTarget : function() {
      return null;
    },
    eventPhase : null,
    bubbles : null,
    cancelable : null,
    timeStamp : function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented : null,
    isTrusted : null
  };
  /**
   * @param {?} id
   * @return {?}
   */
  Event.extend = function(id) {
    /**
     * @return {undefined}
     */
    function F() {
    }
    /**
     * @return {?}
     */
    function Class() {
      return Super.apply(this, arguments);
    }
    var Super = this;
    F.prototype = Super.prototype;
    var o = new F;
    return assign(o, Class.prototype), Class.prototype = o, Class.prototype.constructor = Class, Class.Interface = assign({}, Super.Interface, id), Class.extend = Super.extend, inherits(Class), Class;
  };
  inherits(Event);
  var goog = Event.extend({
    data : null
  });
  var that = Event.extend({
    data : null
  });
  /** @type {!Array} */
  var allowedCodes = [9, 13, 27, 32];
  /** @type {boolean} */
  var modifier = val && "CompositionEvent" in window;
  /** @type {null} */
  var version = null;
  if (val && "documentMode" in document) {
    version = document.documentMode;
  }
  /** @type {boolean} */
  var hasLocalStorage = val && "TextEvent" in window && !version;
  var elementEvent = val && (!modifier || version && 8 < version && 11 >= version);
  /** @type {string} */
  var mmaModChoiceResultsAfterAnswer = String.fromCharCode(32);
  var Events = {
    beforeInput : {
      phasedRegistrationNames : {
        bubbled : "onBeforeInput",
        captured : "onBeforeInputCapture"
      },
      dependencies : ["compositionend", "keypress", "textInput", "paste"]
    },
    compositionEnd : {
      phasedRegistrationNames : {
        bubbled : "onCompositionEnd",
        captured : "onCompositionEndCapture"
      },
      dependencies : "blur compositionend keydown keypress keyup mousedown".split(" ")
    },
    compositionStart : {
      phasedRegistrationNames : {
        bubbled : "onCompositionStart",
        captured : "onCompositionStartCapture"
      },
      dependencies : "blur compositionstart keydown keypress keyup mousedown".split(" ")
    },
    compositionUpdate : {
      phasedRegistrationNames : {
        bubbled : "onCompositionUpdate",
        captured : "onCompositionUpdateCapture"
      },
      dependencies : "blur compositionupdate keydown keypress keyup mousedown".split(" ")
    }
  };
  /** @type {boolean} */
  var callerScope = false;
  /** @type {boolean} */
  var isSrcArr = false;
  var BeforeInputEventPlugin = {
    eventTypes : Events,
    extractEvents : function(name, error, value, target) {
      var err;
      if (modifier) {
        e: {
          switch(name) {
            case "compositionstart":
              var result = Events.compositionStart;
              break e;
            case "compositionend":
              result = Events.compositionEnd;
              break e;
            case "compositionupdate":
              result = Events.compositionUpdate;
              break e;
          }
          result = void 0;
        }
      } else {
        if (isSrcArr) {
          if (inArray(name, value)) {
            result = Events.compositionEnd;
          }
        } else {
          if ("keydown" === name && 229 === value.keyCode) {
            result = Events.compositionStart;
          }
        }
      }
      return result ? (elementEvent && "ko" !== value.locale && (isSrcArr || result !== Events.compositionStart ? result === Events.compositionEnd && isSrcArr && (err = commit()) : (storeOptions = "value" in (cursor = target) ? cursor.value : cursor.textContent, isSrcArr = true)), result = goog.getPooled(result, error, value, target), err ? result.data = err : null !== (err = on(value)) && (result.data = err), trigger(result), err = result) : err = null, (name = hasLocalStorage ? function(params, 
      event) {
        switch(params) {
          case "compositionend":
            return on(event);
          case "keypress":
            return 32 !== event.which ? null : (callerScope = true, mmaModChoiceResultsAfterAnswer);
          case "textInput":
            return (params = event.data) === mmaModChoiceResultsAfterAnswer && callerScope ? null : params;
          default:
            return null;
        }
      }(name, value) : function(key, event) {
        if (isSrcArr) {
          return "compositionend" === key || !modifier && inArray(key, event) ? (key = commit(), actions = storeOptions = cursor = null, isSrcArr = false, key) : null;
        }
        switch(key) {
          case "paste":
            return null;
          case "keypress":
            if (!(event.ctrlKey || event.altKey || event.metaKey) || event.ctrlKey && event.altKey) {
              if (event.char && 1 < event.char.length) {
                return event.char;
              }
              if (event.which) {
                return String.fromCharCode(event.which);
              }
            }
            return null;
          case "compositionend":
            return elementEvent && "ko" !== event.locale ? null : event.data;
          default:
            return null;
        }
      }(name, value)) ? ((error = that.getPooled(Events.beforeInput, error, value, target)).data = name, trigger(error)) : error = null, null === err ? error : null === error ? err : [err, error];
    }
  };
  var $inputTypes = {
    color : true,
    date : true,
    datetime : true,
    "datetime-local" : true,
    email : true,
    month : true,
    number : true,
    password : true,
    range : true,
    search : true,
    tel : true,
    text : true,
    time : true,
    url : true,
    week : true
  };
  var listeners = {
    change : {
      phasedRegistrationNames : {
        bubbled : "onChange",
        captured : "onChangeCapture"
      },
      dependencies : "blur change click focus input keydown keyup selectionchange".split(" ")
    }
  };
  /** @type {null} */
  var self = null;
  /** @type {null} */
  var name = null;
  /** @type {boolean} */
  var yn = false;
  if (val) {
    yn = makeResultContainer("input") && (!document.documentMode || 9 < document.documentMode);
  }
  var ChangeEventPlugin = {
    eventTypes : listeners,
    _isInputEventSupported : yn,
    extractEvents : function(type, name, obj, key) {
      var node = name ? getProperty(name) : window;
      var tagName = node.nodeName && node.nodeName.toLowerCase();
      if ("select" === tagName || "input" === tagName && "file" === node.type) {
        /** @type {function(string, boolean): ?} */
        var value = source;
      } else {
        if (targetNeedsFocus(node)) {
          if (yn) {
            /** @type {function(string, ?): ?} */
            value = structureExtras;
          } else {
            /** @type {function(string): ?} */
            value = initEvents;
            /** @type {function(string, !Element, string): undefined} */
            var f = main;
          }
        } else {
          if ((tagName = node.nodeName) && "input" === tagName.toLowerCase() && ("checkbox" === node.type || "radio" === node.type)) {
            /** @type {function(string, ?): ?} */
            value = isClickableElement;
          }
        }
      }
      if (value && (value = value(type, name))) {
        return write(value, obj, key);
      }
      if (f) {
        f(type, node, name);
      }
      if ("blur" === type && (type = node._wrapperState) && type.controlled && "number" === node.type) {
        validator(node, "number", node.value);
      }
    }
  };
  var touchList = Event.extend({
    view : null,
    detail : null
  });
  var keymap = {
    Alt : "altKey",
    Control : "ctrlKey",
    Meta : "metaKey",
    Shift : "shiftKey"
  };
  /** @type {number} */
  var lastScreenX = 0;
  /** @type {number} */
  var y = 0;
  /** @type {boolean} */
  var named = false;
  /** @type {boolean} */
  var Rn = false;
  var block = touchList.extend({
    screenX : null,
    screenY : null,
    clientX : null,
    clientY : null,
    pageX : null,
    pageY : null,
    ctrlKey : null,
    shiftKey : null,
    altKey : null,
    metaKey : null,
    getModifierState : movementCost,
    button : null,
    buttons : null,
    relatedTarget : function(obj) {
      return obj.relatedTarget || (obj.fromElement === obj.srcElement ? obj.toElement : obj.fromElement);
    },
    movementX : function(event) {
      if ("movementX" in event) {
        return event.movementX;
      }
      var prevScreenX = lastScreenX;
      return lastScreenX = event.screenX, named ? "mousemove" === event.type ? event.screenX - prevScreenX : 0 : (named = true, 0);
    },
    movementY : function(event) {
      if ("movementY" in event) {
        return event.movementY;
      }
      var origY = y;
      return y = event.screenY, Rn ? "mousemove" === event.type ? event.screenY - origY : 0 : (Rn = true, 0);
    }
  });
  var tree = block.extend({
    pointerId : null,
    width : null,
    height : null,
    pressure : null,
    tangentialPressure : null,
    tiltX : null,
    tiltY : null,
    twist : null,
    pointerType : null,
    isPrimary : null
  });
  var $scope = {
    mouseEnter : {
      registrationName : "onMouseEnter",
      dependencies : ["mouseout", "mouseover"]
    },
    mouseLeave : {
      registrationName : "onMouseLeave",
      dependencies : ["mouseout", "mouseover"]
    },
    pointerEnter : {
      registrationName : "onPointerEnter",
      dependencies : ["pointerout", "pointerover"]
    },
    pointerLeave : {
      registrationName : "onPointerLeave",
      dependencies : ["pointerout", "pointerover"]
    }
  };
  var EnterLeaveEventPlugin = {
    eventTypes : $scope,
    extractEvents : function(state, data, event, target, name) {
      /** @type {boolean} */
      var el = "mouseover" === state || "pointerover" === state;
      /** @type {boolean} */
      var value = "mouseout" === state || "pointerout" === state;
      if (el && 0 === (32 & name) && (event.relatedTarget || event.fromElement) || !value && !el) {
        return null;
      }
      if (el = target.window === target ? target : (el = target.ownerDocument) ? el.defaultView || el.parentWindow : window, value) {
        /** @type {number} */
        value = data;
        if (null !== (data = (data = event.relatedTarget || event.toElement) ? recurse(data) : null) && (data !== assert(data) || 5 !== data.tag && 6 !== data.tag)) {
          /** @type {null} */
          data = null;
        }
      } else {
        /** @type {null} */
        value = null;
      }
      if (value === data) {
        return null;
      }
      if ("mouseout" === state || "mouseover" === state) {
        var node = block;
        var result = $scope.mouseLeave;
        var type = $scope.mouseEnter;
        /** @type {string} */
        var x = "mouse";
      } else {
        if (!("pointerout" !== state && "pointerover" !== state)) {
          node = tree;
          result = $scope.pointerLeave;
          type = $scope.pointerEnter;
          /** @type {string} */
          x = "pointer";
        }
      }
      if (state = null == value ? el : getProperty(value), el = null == data ? el : getProperty(data), (result = node.getPooled(result, value, event, target)).type = x + "leave", result.target = state, result.relatedTarget = el, (event = node.getPooled(type, data, event, target)).type = x + "enter", event.target = el, event.relatedTarget = state, x = data, (target = value) && x) {
        e: {
          type = x;
          /** @type {number} */
          value = 0;
          /** @type {boolean} */
          state = node = target;
          for (; state; state = isNaN(state)) {
            value++;
          }
          /** @type {number} */
          state = 0;
          data = type;
          for (; data; data = isNaN(data)) {
            state++;
          }
          for (; 0 < value - state;) {
            node = isNaN(node);
            value--;
          }
          for (; 0 < state - value;) {
            type = isNaN(type);
            state--;
          }
          for (; value--;) {
            if (node === type || node === type.alternate) {
              break e;
            }
            node = isNaN(node);
            type = isNaN(type);
          }
          /** @type {null} */
          node = null;
        }
      } else {
        /** @type {null} */
        node = null;
      }
      type = node;
      /** @type {!Array} */
      node = [];
      for (; target && target !== type && (null === (value = target.alternate) || value !== type);) {
        node.push(target);
        target = isNaN(target);
      }
      /** @type {!Array} */
      target = [];
      for (; x && x !== type && (null === (value = x.alternate) || value !== type);) {
        target.push(x);
        x = isNaN(x);
      }
      /** @type {number} */
      x = 0;
      for (; x < node.length; x++) {
        accumulateDispatches(node[x], "bubbled", result);
      }
      /** @type {number} */
      x = target.length;
      for (; 0 < x--;) {
        accumulateDispatches(target[x], "captured", event);
      }
      return 0 === (64 & name) ? [result] : [result, event];
    }
  };
  /** @type {!Function} */
  var deepEqual = "function" === typeof Object.is ? Object.is : function(value, other) {
    return value === other && (0 !== value || 1 / value === 1 / other) || value !== value && other !== other;
  };
  /** @type {function(this:Object, *): boolean} */
  var hasOwn = Object.prototype.hasOwnProperty;
  /** @type {boolean} */
  var Un = val && "documentMode" in document && 11 >= document.documentMode;
  var panel = {
    select : {
      phasedRegistrationNames : {
        bubbled : "onSelect",
        captured : "onSelectCapture"
      },
      dependencies : "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")
    }
  };
  /** @type {null} */
  var s = null;
  /** @type {null} */
  var payload = null;
  /** @type {null} */
  var err = null;
  /** @type {boolean} */
  var files = false;
  var SelectEventPlugin = {
    eventTypes : panel,
    extractEvents : function($input, name, mode, nativeEventTarget, options, data) {
      if (!(data = !(options = data || (nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument)))) {
        e: {
          options = setOptions(options);
          data = props.onSelect;
          /** @type {number} */
          var i = 0;
          for (; i < data.length; i++) {
            if (!options.has(data[i])) {
              /** @type {boolean} */
              options = false;
              break e;
            }
          }
          /** @type {boolean} */
          options = true;
        }
        /** @type {boolean} */
        data = !options;
      }
      if (data) {
        return null;
      }
      switch(options = name ? getProperty(name) : window, $input) {
        case "focus":
          if (targetNeedsFocus(options) || "true" === options.contentEditable) {
            /** @type {!Object} */
            s = options;
            /** @type {number} */
            payload = name;
            /** @type {null} */
            err = null;
          }
          break;
        case "blur":
          /** @type {null} */
          err = payload = s = null;
          break;
        case "mousedown":
          /** @type {boolean} */
          files = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          return files = false, getSelection(mode, nativeEventTarget);
        case "selectionchange":
          if (Un) {
            break;
          }
        case "keydown":
        case "keyup":
          return getSelection(mode, nativeEventTarget);
      }
      return null;
    }
  };
  var plsql_keyword = Event.extend({
    animationName : null,
    elapsedTime : null,
    pseudoElement : null
  });
  var plsql_function = Event.extend({
    clipboardData : function(event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  });
  var plsql_type = touchList.extend({
    relatedTarget : null
  });
  var keyFixTable = {
    Esc : "Escape",
    Spacebar : " ",
    Left : "ArrowLeft",
    Up : "ArrowUp",
    Right : "ArrowRight",
    Down : "ArrowDown",
    Del : "Delete",
    Win : "OS",
    Menu : "ContextMenu",
    Apps : "ContextMenu",
    Scroll : "ScrollLock",
    MozPrintableKey : "Unidentified"
  };
  var key_map = {
    8 : "Backspace",
    9 : "Tab",
    12 : "Clear",
    13 : "Enter",
    16 : "Shift",
    17 : "Control",
    18 : "Alt",
    19 : "Pause",
    20 : "CapsLock",
    27 : "Escape",
    32 : " ",
    33 : "PageUp",
    34 : "PageDown",
    35 : "End",
    36 : "Home",
    37 : "ArrowLeft",
    38 : "ArrowUp",
    39 : "ArrowRight",
    40 : "ArrowDown",
    45 : "Insert",
    46 : "Delete",
    112 : "F1",
    113 : "F2",
    114 : "F3",
    115 : "F4",
    116 : "F5",
    117 : "F6",
    118 : "F7",
    119 : "F8",
    120 : "F9",
    121 : "F10",
    122 : "F11",
    123 : "F12",
    144 : "NumLock",
    145 : "ScrollLock",
    224 : "Meta"
  };
  var sonos_stream = touchList.extend({
    key : function(key) {
      if (key.key) {
        var valueType = keyFixTable[key.key] || key.key;
        if ("Unidentified" !== valueType) {
          return valueType;
        }
      }
      return "keypress" === key.type ? 13 === (key = getKey(key)) ? "Enter" : String.fromCharCode(key) : "keydown" === key.type || "keyup" === key.type ? key_map[key.keyCode] || "Unidentified" : "";
    },
    location : null,
    ctrlKey : null,
    shiftKey : null,
    altKey : null,
    metaKey : null,
    repeat : null,
    locale : null,
    getModifierState : movementCost,
    charCode : function(event) {
      return "keypress" === event.type ? getKey(event) : 0;
    },
    keyCode : function(e) {
      return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0;
    },
    which : function(e) {
      return "keypress" === e.type ? getKey(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0;
    }
  });
  var abortActionType = block.extend({
    dataTransfer : null
  });
  var Masses = touchList.extend({
    touches : null,
    targetTouches : null,
    changedTouches : null,
    altKey : null,
    metaKey : null,
    ctrlKey : null,
    shiftKey : null,
    getModifierState : movementCost
  });
  var Parishes = Event.extend({
    propertyName : null,
    elapsedTime : null,
    pseudoElement : null
  });
  var plsql_operator = block.extend({
    deltaX : function(event) {
      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
    },
    deltaY : function(event) {
      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
    },
    deltaZ : null,
    deltaMode : null
  });
  var SimpleEventPlugin = {
    eventTypes : eventTypes,
    extractEvents : function(type, data, obj, nativeEventTarget) {
      var input = executionContextNamesByOrigin.get(type);
      if (!input) {
        return null;
      }
      switch(type) {
        case "keypress":
          if (0 === getKey(obj)) {
            return null;
          }
        case "keydown":
        case "keyup":
          type = sonos_stream;
          break;
        case "blur":
        case "focus":
          type = plsql_type;
          break;
        case "click":
          if (2 === obj.button) {
            return null;
          }
        case "auxclick":
        case "dblclick":
        case "mousedown":
        case "mousemove":
        case "mouseup":
        case "mouseout":
        case "mouseover":
        case "contextmenu":
          type = block;
          break;
        case "drag":
        case "dragend":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "dragstart":
        case "drop":
          type = abortActionType;
          break;
        case "touchcancel":
        case "touchend":
        case "touchmove":
        case "touchstart":
          type = Masses;
          break;
        case firstListItemStyle:
        case scatterChart:
        case string_object_array:
          type = plsql_keyword;
          break;
        case transEnd:
          type = Parishes;
          break;
        case "scroll":
          type = touchList;
          break;
        case "wheel":
          type = plsql_operator;
          break;
        case "copy":
        case "cut":
        case "paste":
          type = plsql_function;
          break;
        case "gotpointercapture":
        case "lostpointercapture":
        case "pointercancel":
        case "pointerdown":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerup":
          type = tree;
          break;
        default:
          /** @type {function(!Object, ?, !Object, string): ?} */
          type = Event;
      }
      return trigger(data = type.getPooled(input, data, obj, nativeEventTarget)), data;
    }
  };
  if (exact_keys) {
    throw Error(call(101));
  }
  /** @type {!Array<?>} */
  exact_keys = Array.prototype.slice.call("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
  publishEventForPlugin();
  /** @type {function(!Object): ?} */
  parent = b;
  /** @type {function(!Object): ?} */
  markNodeAsRequired = matches;
  /** @type {function(?): ?} */
  warning = getProperty;
  every({
    SimpleEventPlugin : SimpleEventPlugin,
    EnterLeaveEventPlugin : EnterLeaveEventPlugin,
    ChangeEventPlugin : ChangeEventPlugin,
    SelectEventPlugin : SelectEventPlugin,
    BeforeInputEventPlugin : BeforeInputEventPlugin
  });
  /** @type {!Array} */
  var fields = [];
  /** @type {number} */
  var i = -1;
  var root = {};
  var item = {
    current : root
  };
  var nodeList = {
    current : false
  };
  var form = root;
  var D = app.unstable_runWithPriority;
  var u = app.unstable_scheduleCallback;
  var concat = app.unstable_cancelCallback;
  var extIds = app.unstable_requestPaint;
  var _dateAsInt = app.unstable_now;
  var onWait = app.unstable_getCurrentPriorityLevel;
  var e = app.unstable_ImmediatePriority;
  var output = app.unstable_UserBlockingPriority;
  var curDoc = app.unstable_NormalPriority;
  var tasks = app.unstable_LowPriority;
  var collection = app.unstable_IdlePriority;
  var origin = {};
  var prevPage = app.unstable_shouldYield;
  var parseStoreDir = void 0 !== extIds ? extIds : function() {
  };
  /** @type {null} */
  var number = null;
  /** @type {null} */
  var el = null;
  /** @type {boolean} */
  var address = false;
  var _firstDayOfMonthAsInt = _dateAsInt();
  var getTime = 1E4 > _firstDayOfMonthAsInt ? _dateAsInt : function() {
    return _dateAsInt() - _firstDayOfMonthAsInt;
  };
  var status = {
    current : null
  };
  /** @type {null} */
  var top = null;
  /** @type {null} */
  var current = null;
  /** @type {null} */
  var prev = null;
  /** @type {boolean} */
  var layout = false;
  var config = me.ReactCurrentBatchConfig;
  var refs = (new React.Component).refs;
  var _ = {
    isMounted : function(item) {
      return !!(item = item._reactInternalFiber) && assert(item) === item;
    },
    enqueueSetState : function(item, partialState, callback) {
      item = item._reactInternalFiber;
      var index = parseFloat();
      var i = config.suspense;
      /** @type {string} */
      (i = parseInt(index = map(index, item, i), i)).payload = partialState;
      if (void 0 !== callback && null !== callback) {
        /** @type {string} */
        i.callback = callback;
      }
      copy(item, i);
      test(item, index);
    },
    enqueueReplaceState : function(item, url, callback) {
      item = item._reactInternalFiber;
      var index = parseFloat();
      var i = config.suspense;
      /** @type {number} */
      (i = parseInt(index = map(index, item, i), i)).tag = 1;
      /** @type {string} */
      i.payload = url;
      if (void 0 !== callback && null !== callback) {
        /** @type {number} */
        i.callback = callback;
      }
      copy(item, i);
      test(item, index);
    },
    enqueueForceUpdate : function(item, callback) {
      item = item._reactInternalFiber;
      var index = parseFloat();
      var i = config.suspense;
      /** @type {number} */
      (i = parseInt(index = map(index, item, i), i)).tag = 2;
      if (void 0 !== callback && null !== callback) {
        /** @type {string} */
        i.callback = callback;
      }
      copy(item, i);
      test(item, index);
    }
  };
  /** @type {function(*): boolean} */
  var isArray = Array.isArray;
  var fn = run(true);
  var x = run(false);
  var rate = {};
  var request = {
    current : rate
  };
  var element = {
    current : rate
  };
  var ret = {
    current : rate
  };
  var opts = {
    current : 0
  };
  var water = me.ReactCurrentDispatcher;
  var $rootScope = me.ReactCurrentBatchConfig;
  /** @type {number} */
  var temp = 0;
  /** @type {null} */
  var options = null;
  /** @type {null} */
  var message = null;
  /** @type {null} */
  var ctx = null;
  /** @type {boolean} */
  var Vo = false;
  var old = {
    readContext : require,
    useCallback : LOFOX,
    useContext : LOFOX,
    useEffect : LOFOX,
    useImperativeHandle : LOFOX,
    useLayoutEffect : LOFOX,
    useMemo : LOFOX,
    useReducer : LOFOX,
    useRef : LOFOX,
    useState : LOFOX,
    useDebugValue : LOFOX,
    useResponder : LOFOX,
    useDeferredValue : LOFOX,
    useTransition : LOFOX
  };
  var pageX = {
    readContext : require,
    useCallback : spawn,
    useContext : require,
    useEffect : pluginHandle,
    useImperativeHandle : function(fn, key, e) {
      return e = null !== e && void 0 !== e ? e.concat([fn]) : null, fire(4, 2, go.bind(null, key, fn), e);
    },
    useLayoutEffect : function(target, e) {
      return fire(4, 2, target, e);
    },
    useMemo : function(data, id) {
      var map = jQuery();
      return id = void 0 === id ? null : id, data = data(), map.memoizedState = [data, id], data;
    },
    useReducer : function(path, node, doc) {
      var self = jQuery();
      return node = void 0 !== doc ? doc(node) : node, self.memoizedState = self.baseState = node, path = (path = self.queue = {
        pending : null,
        dispatch : null,
        lastRenderedReducer : path,
        lastRenderedState : node
      }).dispatch = join.bind(null, options, path), [self.memoizedState, path];
    },
    useRef : function(obj) {
      return obj = {
        current : obj
      }, jQuery().memoizedState = obj;
    },
    useState : click,
    useDebugValue : ca,
    useResponder : setToSystem,
    useDeferredValue : function(name, data) {
      var r = click(name);
      var tx_ver = r[0];
      var hashed = r[1];
      return pluginHandle(function() {
        var originalBackFunction = $rootScope.suspense;
        $rootScope.suspense = void 0 === data ? null : data;
        try {
          hashed(name);
        } finally {
          $rootScope.suspense = originalBackFunction;
        }
      }, [name, data]), tx_ver;
    },
    useTransition : function(name) {
      var args = click(false);
      var contextArgs = args[0];
      return args = args[1], [spawn(plugin.bind(null, args, name), [args, name]), contextArgs];
    }
  };
  var retryCounter = {
    readContext : require,
    useCallback : insert,
    useContext : require,
    useEffect : interpolate,
    useImperativeHandle : enter,
    useLayoutEffect : open,
    useMemo : extractPresetLocal,
    useReducer : resolve,
    useRef : findBlocksToIndentFromRange,
    useState : function() {
      return resolve(context);
    },
    useDebugValue : ca,
    useResponder : setToSystem,
    useDeferredValue : function(name, data) {
      var resolved = resolve(context);
      var fn = resolved[0];
      var filename = resolved[1];
      return interpolate(function() {
        var originalBackFunction = $rootScope.suspense;
        $rootScope.suspense = void 0 === data ? null : data;
        try {
          filename(name);
        } finally {
          $rootScope.suspense = originalBackFunction;
        }
      }, [name, data]), fn;
    },
    useTransition : function(name) {
      var item = resolve(context);
      var amount0 = item[0];
      return item = item[1], [insert(plugin.bind(null, item, name), [item, name]), amount0];
    }
  };
  var h2o = {
    readContext : require,
    useCallback : insert,
    useContext : require,
    useEffect : interpolate,
    useImperativeHandle : enter,
    useLayoutEffect : open,
    useMemo : extractPresetLocal,
    useReducer : clear,
    useRef : findBlocksToIndentFromRange,
    useState : function() {
      return clear(context);
    },
    useDebugValue : ca,
    useResponder : setToSystem,
    useDeferredValue : function(name, data) {
      var localContext = clear(context);
      var originalVarValue = localContext[0];
      var _doLoad = localContext[1];
      return interpolate(function() {
        var originalBackFunction = $rootScope.suspense;
        $rootScope.suspense = void 0 === data ? null : data;
        try {
          _doLoad(name);
        } finally {
          $rootScope.suspense = originalBackFunction;
        }
      }, [name, data]), originalVarValue;
    },
    useTransition : function(name) {
      var id = clear(context);
      var ident = id[0];
      return id = id[1], [insert(plugin.bind(null, id, name), [id, name]), ident];
    }
  };
  /** @type {null} */
  var before = null;
  /** @type {null} */
  var nextNode = null;
  /** @type {boolean} */
  var abort = false;
  var attrValue = me.ReactCurrentOwner;
  /** @type {boolean} */
  var property = false;
  var Section;
  var notify;
  var isValidBSTRecursive;
  var link_el = {
    dehydrated : null,
    retryTime : 0
  };
  /**
   * @param {!Object} selector
   * @param {!Object} parent
   * @return {undefined}
   */
  Section = function(selector, parent) {
    var node = parent.child;
    for (; null !== node;) {
      if (5 === node.tag || 6 === node.tag) {
        selector.appendChild(node.stateNode);
      } else {
        if (4 !== node.tag && null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
      }
      if (node === parent) {
        break;
      }
      for (; null === node.sibling;) {
        if (null === node.return || node.return === parent) {
          return;
        }
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
  };
  /**
   * @param {!Object} source
   * @param {!Object} node
   * @param {!Array} options
   * @param {!Object} data
   * @param {!Object} value
   * @return {undefined}
   */
  notify = function(source, node, options, data, value) {
    var obj = source.memoizedProps;
    if (obj !== data) {
      var name;
      var i;
      var v = node.stateNode;
      switch(translate(request.current), source = null, options) {
        case "input":
          obj = convert(v, obj);
          data = convert(v, data);
          /** @type {!Array} */
          source = [];
          break;
        case "option":
          obj = wrap(v, obj);
          data = wrap(v, data);
          /** @type {!Array} */
          source = [];
          break;
        case "select":
          obj = assign({}, obj, {
            value : void 0
          });
          data = assign({}, data, {
            value : void 0
          });
          /** @type {!Array} */
          source = [];
          break;
        case "textarea":
          obj = select(v, obj);
          data = select(v, data);
          /** @type {!Array} */
          source = [];
          break;
        default:
          if ("function" !== typeof obj.onClick && "function" === typeof data.onClick) {
            /** @type {function(): undefined} */
            v.onclick = size;
          }
      }
      for (name in has(options, data), options = null, obj) {
        if (!data.hasOwnProperty(name) && obj.hasOwnProperty(name) && null != obj[name]) {
          if ("style" === name) {
            for (i in v = obj[name]) {
              if (v.hasOwnProperty(i)) {
                if (!options) {
                  options = {};
                }
                /** @type {string} */
                options[i] = "";
              }
            }
          } else {
            if ("dangerouslySetInnerHTML" !== name && "children" !== name && "suppressContentEditableWarning" !== name && "suppressHydrationWarning" !== name && "autoFocus" !== name) {
              if (dependencies.hasOwnProperty(name)) {
                if (!source) {
                  /** @type {!Array} */
                  source = [];
                }
              } else {
                (source = source || []).push(name, null);
              }
            }
          }
        }
      }
      for (name in data) {
        var value = data[name];
        if (v = null != obj ? obj[name] : void 0, data.hasOwnProperty(name) && value !== v && (null != value || null != v)) {
          if ("style" === name) {
            if (v) {
              for (i in v) {
                if (!(!v.hasOwnProperty(i) || value && value.hasOwnProperty(i))) {
                  if (!options) {
                    options = {};
                  }
                  /** @type {string} */
                  options[i] = "";
                }
              }
              for (i in value) {
                if (value.hasOwnProperty(i) && v[i] !== value[i]) {
                  if (!options) {
                    options = {};
                  }
                  options[i] = value[i];
                }
              }
            } else {
              if (!options) {
                if (!source) {
                  /** @type {!Array} */
                  source = [];
                }
                source.push(name, options);
              }
              options = value;
            }
          } else {
            if ("dangerouslySetInnerHTML" === name) {
              value = value ? value.__html : void 0;
              v = v ? v.__html : void 0;
              if (null != value && v !== value) {
                (source = source || []).push(name, value);
              }
            } else {
              if ("children" === name) {
                if (!(v === value || "string" !== typeof value && "number" !== typeof value)) {
                  (source = source || []).push(name, "" + value);
                }
              } else {
                if ("suppressContentEditableWarning" !== name && "suppressHydrationWarning" !== name) {
                  if (dependencies.hasOwnProperty(name)) {
                    if (null != value) {
                      invoke(value, name);
                    }
                    if (!(source || v === value)) {
                      /** @type {!Array} */
                      source = [];
                    }
                  } else {
                    (source = source || []).push(name, value);
                  }
                }
              }
            }
          }
        }
      }
      if (options) {
        (source = source || []).push("style", options);
      }
      /** @type {!Object} */
      value = source;
      if (node.updateQueue = value) {
        node.effectTag |= 4;
      }
    }
  };
  /**
   * @param {number} solState
   * @param {!Object} node
   * @param {?} min
   * @param {?} max
   * @return {undefined}
   */
  isValidBSTRecursive = function(solState, node, min, max) {
    if (min !== max) {
      node.effectTag |= 4;
    }
  };
  /** @type {!Function} */
  var action = "function" === typeof WeakSet ? WeakSet : Set;
  /** @type {!Function} */
  var Date = "function" === typeof WeakMap ? WeakMap : Map;
  var update;
  /** @type {function(?): number} */
  var ceil = Math.ceil;
  var event = me.ReactCurrentDispatcher;
  var dashboard = me.ReactCurrentOwner;
  /** @type {number} */
  var undefined = 0;
  /** @type {number} */
  var startIndex = 3;
  /** @type {number} */
  var arg1 = 4;
  /** @type {number} */
  var value = 0;
  /** @type {null} */
  var m = null;
  /** @type {null} */
  var node = null;
  /** @type {number} */
  var n = 0;
  /** @type {number} */
  var index = undefined;
  /** @type {null} */
  var pdf = null;
  /** @type {number} */
  var r = 1073741823;
  /** @type {number} */
  var l = 1073741823;
  /** @type {null} */
  var currentRelations = null;
  /** @type {number} */
  var offset = 0;
  /** @type {boolean} */
  var Os = false;
  /** @type {number} */
  var startTime = 0;
  /** @type {null} */
  var obj = null;
  /** @type {boolean} */
  var ref1$ = false;
  /** @type {null} */
  var realEvent = null;
  /** @type {null} */
  var observers = null;
  /** @type {boolean} */
  var zs = false;
  /** @type {null} */
  var point = null;
  /** @type {number} */
  var p2 = 90;
  /** @type {null} */
  var cur = null;
  /** @type {number} */
  var _t$FLIPPED_ALIAS_KEYS = 0;
  /** @type {null} */
  var caller = null;
  /** @type {number} */
  var Vs = 0;
  /**
   * @param {!Object} data
   * @param {!Object} node
   * @param {number} i
   * @return {?}
   */
  update = function(data, node, i) {
    var value = node.expirationTime;
    if (null !== data) {
      var options = node.pendingProps;
      if (data.memoizedProps !== options || nodeList.current) {
        /** @type {boolean} */
        property = true;
      } else {
        if (value < i) {
          switch(property = false, node.tag) {
            case 3:
              split(node);
              updateGameInfoEdit();
              break;
            case 5:
              if (calculateLargestZIndex(node), 4 & node.mode && 1 !== i && options.hidden) {
                return node.expirationTime = node.childExpirationTime = 1, null;
              }
              break;
            case 1:
              if (isFunction(node.type)) {
                replaceChild(node);
              }
              break;
            case 4:
              height(node, node.stateNode.containerInfo);
              break;
            case 10:
              value = node.memoizedProps.value;
              options = node.type._context;
              indexOf(status, options._currentValue);
              options._currentValue = value;
              break;
            case 13:
              if (null !== node.memoizedState) {
                return 0 !== (value = node.child.childExpirationTime) && value >= i ? dispatch(data, node, i) : (indexOf(opts, 1 & opts.current), null !== (node = replace(data, node, i)) ? node.sibling : null);
              }
              indexOf(opts, 1 & opts.current);
              break;
            case 19:
              if (value = node.childExpirationTime >= i, 0 !== (64 & data.effectTag)) {
                if (value) {
                  return put(data, node, i);
                }
                node.effectTag |= 64;
              }
              if (null !== (options = node.memoizedState) && (options.rendering = null, options.tail = null), indexOf(opts, opts.current), !value) {
                return null;
              }
          }
          return replace(data, node, i);
        }
        /** @type {boolean} */
        property = false;
      }
    } else {
      /** @type {boolean} */
      property = false;
    }
    switch(node.expirationTime = 0, node.tag) {
      case 2:
        if (value = node.type, null !== data && (data.alternate = null, node.alternate = null, node.effectTag |= 2), data = node.pendingProps, options = $(node, item.current), report(node, i), options = execute(null, node, value, data, options, i), node.effectTag |= 1, "object" === typeof options && null !== options && "function" === typeof options.render && void 0 === options.$$typeof) {
          if (node.tag = 1, node.memoizedState = null, node.updateQueue = null, isFunction(value)) {
            /** @type {boolean} */
            var key = true;
            replaceChild(node);
          } else {
            /** @type {boolean} */
            key = false;
          }
          node.memoizedState = null !== options.state && void 0 !== options.state ? options.state : null;
          ok(node);
          var next = value.getDerivedStateFromProps;
          if ("function" === typeof next) {
            find(node, value, next, data);
          }
          options.updater = _;
          node.stateNode = options;
          /** @type {!Object} */
          options._reactInternalFiber = node;
          create(node, value, data, i);
          node = clone(null, node, value, true, key, i);
        } else {
          /** @type {number} */
          node.tag = 0;
          debug(null, node, options, i);
          node = node.child;
        }
        return node;
      case 16:
        e: {
          if (options = node.elementType, null !== data && (data.alternate = null, node.alternate = null, node.effectTag |= 2), data = node.pendingProps, function(res) {
            if (-1 === res._status) {
              /** @type {number} */
              res._status = 0;
              var value = res._ctor;
              value = value();
              res._result = value;
              value.then(function(value) {
                if (0 === res._status) {
                  value = value.default;
                  /** @type {number} */
                  res._status = 1;
                  /** @type {!Object} */
                  res._result = value;
                }
              }, function(value) {
                if (0 === res._status) {
                  /** @type {number} */
                  res._status = 2;
                  /** @type {!Object} */
                  res._result = value;
                }
              });
            }
          }(options), 1 !== options._status) {
            throw options._result;
          }
          switch(options = options._result, node.type = options, key = node.tag = function(val) {
            if ("function" === typeof val) {
              return createElement(val) ? 1 : 0;
            }
            if (void 0 !== val && null !== val) {
              if ((val = val.$$typeof) === column) {
                return 11;
              }
              if (val === years) {
                return 14;
              }
            }
            return 2;
          }(options), data = transform(options, data), key) {
            case 0:
              node = remove(null, node, options, data, i);
              break e;
            case 1:
              node = renderComponent(null, node, options, data, i);
              break e;
            case 11:
              node = configure(null, node, options, data, i);
              break e;
            case 14:
              node = patch(null, node, options, transform(options.type, data), value, i);
              break e;
          }
          throw Error(call(306, options, ""));
        }
        return node;
      case 0:
        return value = node.type, options = node.pendingProps, remove(data, node, value, options = node.elementType === value ? options : transform(value, options), i);
      case 1:
        return value = node.type, options = node.pendingProps, renderComponent(data, node, value, options = node.elementType === value ? options : transform(value, options), i);
      case 3:
        if (split(node), value = node.updateQueue, null === data || null === value) {
          throw Error(call(282));
        }
        if (value = node.pendingProps, options = null !== (options = node.memoizedState) ? options.element : null, forEach(data, node), add(node, value, null, i), (value = node.memoizedState.element) === options) {
          updateGameInfoEdit();
          node = replace(data, node, i);
        } else {
          if ((options = node.stateNode.hydrate) && (nextNode = insertBefore(node.stateNode.containerInfo.firstChild), before = node, options = abort = true), options) {
            i = x(node, null, value, i);
            /** @type {number} */
            node.child = i;
            for (; i;) {
              /** @type {number} */
              i.effectTag = -3 & i.effectTag | 1024;
              i = i.sibling;
            }
          } else {
            debug(data, node, value, i);
            updateGameInfoEdit();
          }
          node = node.child;
        }
        return node;
      case 5:
        return calculateLargestZIndex(node), null === data && reducer(node), value = node.type, options = node.pendingProps, key = null !== data ? data.memoizedProps : null, next = options.children, walker(value, options) ? next = null : null !== key && walker(value, key) && (node.effectTag |= 16), inject(data, node), 4 & node.mode && 1 !== i && options.hidden ? (node.expirationTime = node.childExpirationTime = 1, node = null) : (debug(data, node, next, i), node = node.child), node;
      case 6:
        return null === data && reducer(node), null;
      case 13:
        return dispatch(data, node, i);
      case 4:
        return height(node, node.stateNode.containerInfo), value = node.pendingProps, null === data ? node.child = fn(node, null, value, i) : debug(data, node, value, i), node.child;
      case 11:
        return value = node.type, options = node.pendingProps, configure(data, node, value, options = node.elementType === value ? options : transform(value, options), i);
      case 7:
        return debug(data, node, node.pendingProps, i), node.child;
      case 8:
      case 12:
        return debug(data, node, node.pendingProps.children, i), node.child;
      case 10:
        e: {
          value = node.type._context;
          options = node.pendingProps;
          next = node.memoizedProps;
          key = options.value;
          var item = node.type._context;
          if (indexOf(status, item._currentValue), item._currentValue = key, null !== next) {
            if (item = next.value, 0 === (key = deepEqual(item, key) ? 0 : 0 | ("function" === typeof value._calculateChangedBits ? value._calculateChangedBits(item, key) : 1073741823))) {
              if (next.children === options.children && !nodeList.current) {
                node = replace(data, node, i);
                break e;
              }
            } else {
              if (null !== (item = node.child)) {
                /** @type {!Object} */
                item.return = node;
              }
              for (; null !== item;) {
                var token = item.dependencies;
                if (null !== token) {
                  next = item.child;
                  var v = token.firstContext;
                  for (; null !== v;) {
                    if (v.context === value && 0 !== (v.observedBits & key)) {
                      if (1 === item.tag) {
                        /** @type {number} */
                        (v = parseInt(i, null)).tag = 2;
                        copy(item, v);
                      }
                      if (item.expirationTime < i) {
                        /** @type {number} */
                        item.expirationTime = i;
                      }
                      if (null !== (v = item.alternate) && v.expirationTime < i) {
                        /** @type {number} */
                        v.expirationTime = i;
                      }
                      visit(item.return, i);
                      if (token.expirationTime < i) {
                        /** @type {number} */
                        token.expirationTime = i;
                      }
                      break;
                    }
                    v = v.next;
                  }
                } else {
                  next = 10 === item.tag && item.type === node.type ? null : item.child;
                }
                if (null !== next) {
                  next.return = item;
                } else {
                  next = item;
                  for (; null !== next;) {
                    if (next === node) {
                      /** @type {null} */
                      next = null;
                      break;
                    }
                    if (null !== (item = next.sibling)) {
                      item.return = next.return;
                      next = item;
                      break;
                    }
                    next = next.return;
                  }
                }
                item = next;
              }
            }
          }
          debug(data, node, options.children, i);
          node = node.child;
        }
        return node;
      case 9:
        return options = node.type, value = (key = node.pendingProps).children, report(node, i), value = value(options = require(options, key.unstable_observedBits)), node.effectTag |= 1, debug(data, node, value, i), node.child;
      case 14:
        return key = transform(options = node.type, node.pendingProps), patch(data, node, options, key = transform(options.type, key), value, i);
      case 15:
        return validate(data, node, node.type, node.pendingProps, value, i);
      case 17:
        return value = node.type, options = node.pendingProps, options = node.elementType === value ? options : transform(value, options), null !== data && (data.alternate = null, node.alternate = null, node.effectTag |= 2), node.tag = 1, isFunction(value) ? (data = true, replaceChild(node)) : data = false, report(node, i), connect(node, value, options), create(node, value, options, i), clone(null, node, value, true, data, i);
      case 19:
        return put(data, node, i);
    }
    throw Error(call(156, node.tag));
  };
  /** @type {null} */
  var onComplete = null;
  /** @type {null} */
  var doc = null;
  /**
   * @param {string} key
   * @return {undefined}
   */
  a.prototype.render = function(key) {
    filter(key, this._internalRoot, null, null);
  };
  /**
   * @return {undefined}
   */
  a.prototype.unmount = function() {
    var self = this._internalRoot;
    var _elClass = self.containerInfo;
    filter(null, self, null, function() {
      /** @type {null} */
      _elClass[key] = null;
    });
  };
  /**
   * @param {(Object|string)} value
   * @return {undefined}
   */
  draw = function(value) {
    if (13 === value.tag) {
      var bar = calc(parseFloat(), 150, 100);
      test(value, bar);
      unshift(value, bar);
    }
  };
  /**
   * @param {(Object|string)} value
   * @return {undefined}
   */
  flatten = function(value) {
    if (13 === value.tag) {
      test(value, 3);
      unshift(value, 3);
    }
  };
  /**
   * @param {number} value
   * @return {undefined}
   */
  match = function(value) {
    if (13 === value.tag) {
      var x = parseFloat();
      test(value, x = map(x, value, null));
      unshift(value, x);
    }
  };
  /**
   * @param {!Object} element
   * @param {string} key
   * @param {!Object} el
   * @return {undefined}
   */
  callback = function(element, key, el) {
    switch(key) {
      case "input":
        if (check(element, el), key = el.name, "radio" === el.type && null != key) {
          /** @type {!Object} */
          el = element;
          for (; el.parentNode;) {
            el = el.parentNode;
          }
          el = el.querySelectorAll("input[name=" + JSON.stringify("" + key) + '][type="radio"]');
          /** @type {number} */
          key = 0;
          for (; key < el.length; key++) {
            var e = el[key];
            if (e !== element && e.form === element.form) {
              var i = b(e);
              if (!i) {
                throw Error(call(90));
              }
              getValue(e);
              check(e, i);
            }
          }
        }
        break;
      case "textarea":
        fixElement(element, el);
        break;
      case "select":
        if (null != (key = el.value)) {
          updateOptions(element, !!el.multiple, key, false);
        }
    }
  };
  /** @type {function(!Function, !Object): ?} */
  command = track;
  /**
   * @param {!Function} obj
   * @param {?} val
   * @param {?} item
   * @param {?} callback
   * @param {?} i
   * @return {?}
   */
  writer = function(obj, val, item, callback, i) {
    var origValue = value;
    /** @type {number} */
    value = value | 4;
    try {
      return drop(98, obj.bind(null, val, item, callback, i));
    } finally {
      if (0 === (value = origValue)) {
        log();
      }
    }
  };
  /**
   * @return {undefined}
   */
  getData = function() {
    if (0 === (49 & value)) {
      (function() {
        if (null !== cur) {
          /** @type {!Map} */
          var pop = cur;
          /** @type {null} */
          cur = null;
          pop.forEach(function(right, a) {
            eq(a, right);
            exec(a);
          });
          log();
        }
      })();
      readFileSync();
    }
  };
  /**
   * @param {!Function} callback
   * @param {!Object} path
   * @return {?}
   */
  cmd = function(callback, path) {
    var origValue = value;
    /** @type {number} */
    value = value | 2;
    try {
      return callback(path);
    } finally {
      if (0 === (value = origValue)) {
        log();
      }
    }
  };
  var LITE = {
    Events : [matches, getProperty, b, every, lstnrs, trigger, function(results) {
      after(results, accumulateDirectDispatchesSingle);
    }, closeTag, load_random, setup, fail, readFileSync, {
      current : false
    }]
  };
  !function(axes) {
    /** @type {function(!Object): ?} */
    var f = axes.findFiberByHostInstance;
    (function(e) {
      if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        return false;
      }
      var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (t.isDisabled || !t.supportsFiber) {
        return true;
      }
      try {
        var panelElm = t.inject(e);
        /**
         * @param {!Object} b
         * @return {undefined}
         */
        onComplete = function(b) {
          try {
            t.onCommitFiberRoot(panelElm, b, void 0, 64 === (64 & b.current.effectTag));
          } catch (n) {
          }
        };
        /**
         * @param {!Object} value
         * @return {undefined}
         */
        doc = function(value) {
          try {
            t.onCommitFiberUnmount(panelElm, value);
          } catch (n) {
          }
        };
      } catch (n) {
      }
    })(assign({}, axes, {
      overrideHookState : null,
      overrideProps : null,
      setSuspenseHandler : null,
      scheduleUpdate : null,
      currentDispatcherRef : me.ReactCurrentDispatcher,
      findHostInstanceByFiber : function(nodes) {
        return null === (nodes = query(nodes)) ? null : nodes.stateNode;
      },
      findFiberByHostInstance : function(val) {
        return f ? f(val) : null;
      },
      findHostInstancesForRefresh : null,
      scheduleRefresh : null,
      scheduleRoot : null,
      setRefreshHandler : null,
      getCurrentFiber : null
    }));
  }({
    findFiberByHostInstance : recurse,
    bundleType : 0,
    version : "16.13.0",
    rendererPackageName : "react-dom"
  });
  exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = LITE;
  /** @type {function(!Array, !Object): ?} */
  exports.createPortal = loader;
  /**
   * @param {!Object} node
   * @return {?}
   */
  exports.findDOMNode = function(node) {
    if (null == node) {
      return null;
    }
    if (1 === node.nodeType) {
      return node;
    }
    var outer = node._reactInternalFiber;
    if (void 0 === outer) {
      if ("function" === typeof node.render) {
        throw Error(call(188));
      }
      throw Error(call(268, Object.keys(node)));
    }
    return node = null === (node = query(outer)) ? null : node.stateNode;
  };
  /**
   * @param {!Function} e
   * @param {?} type
   * @return {?}
   */
  exports.flushSync = function(e, type) {
    if (0 !== (48 & value)) {
      throw Error(call(187));
    }
    var origValue = value;
    /** @type {number} */
    value = value | 1;
    try {
      return drop(99, e.bind(null, type));
    } finally {
      value = origValue;
      log();
    }
  };
  /**
   * @param {string} key
   * @param {string} options
   * @param {!Object} params
   * @return {?}
   */
  exports.hydrate = function(key, options, params) {
    if (!extract(options)) {
      throw Error(call(200));
    }
    return show(null, key, options, true, params);
  };
  /**
   * @param {string} key
   * @param {string} options
   * @param {!Object} h
   * @return {?}
   */
  exports.render = function(key, options, h) {
    if (!extract(options)) {
      throw Error(call(200));
    }
    return show(null, key, options, false, h);
  };
  /**
   * @param {undefined} options
   * @return {?}
   */
  exports.unmountComponentAtNode = function(options) {
    if (!extract(options)) {
      throw Error(call(40));
    }
    return !!options._reactRootContainer && (applyStyle(function() {
      show(null, null, options, false, function() {
        /** @type {null} */
        options._reactRootContainer = null;
        /** @type {null} */
        options[key] = null;
      });
    }), true);
  };
  /** @type {function(!Function, !Object): ?} */
  exports.unstable_batchedUpdates = track;
  /**
   * @param {!Array} data
   * @param {!Object} key
   * @return {?}
   */
  exports.unstable_createPortal = function(data, key) {
    return loader(data, key, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
  };
  /**
   * @param {!Object} container
   * @param {string} callback
   * @param {undefined} key
   * @param {!Function} opt_callback
   * @return {?}
   */
  exports.unstable_renderSubtreeIntoContainer = function(container, callback, key, opt_callback) {
    if (!extract(key)) {
      throw Error(call(200));
    }
    if (null == container || void 0 === container._reactInternalFiber) {
      throw Error(call(38));
    }
    return show(container, callback, key, false, opt_callback);
  };
  /** @type {string} */
  exports.version = "16.13.0";
}, function(module, canCreateDiscussions, factory) {
  module.exports = factory(114);
}, function(isSlidingUp, encoded, dontForceConstraints) {
  /**
   * @param {!Array} obj
   * @param {!Object} data
   * @return {undefined}
   */
  function search(obj, data) {
    var count = obj.length;
    obj.push(data);
    e: for (;;) {
      /** @type {number} */
      var val = count - 1 >>> 1;
      var node = obj[val];
      if (!(void 0 !== node && 0 < on(node, data))) {
        break e;
      }
      /** @type {!Object} */
      obj[val] = data;
      obj[count] = node;
      /** @type {number} */
      count = val;
    }
  }
  /**
   * @param {?} value
   * @return {?}
   */
  function parseInt(value) {
    return void 0 === (value = value[0]) ? null : value;
  }
  /**
   * @param {!Array} data
   * @return {?}
   */
  function decode(data) {
    var l = data[0];
    if (void 0 !== l) {
      var i = data.pop();
      if (i !== l) {
        data[0] = i;
        /** @type {number} */
        var n = 0;
        var num_arrays = data.length;
        e: for (; n < num_arrays;) {
          /** @type {number} */
          var size = 2 * (n + 1) - 1;
          var value = data[size];
          /** @type {number} */
          var x = size + 1;
          var val = data[x];
          if (void 0 !== value && 0 > on(value, i)) {
            if (void 0 !== val && 0 > on(val, value)) {
              data[n] = val;
              data[x] = i;
              /** @type {number} */
              n = x;
            } else {
              data[n] = value;
              data[size] = i;
              /** @type {number} */
              n = size;
            }
          } else {
            if (!(void 0 !== val && 0 > on(val, i))) {
              break e;
            }
            data[n] = val;
            data[x] = i;
            /** @type {number} */
            n = x;
          }
        }
      }
      return l;
    }
    return null;
  }
  /**
   * @param {string} a
   * @param {!Object} b
   * @return {?}
   */
  function on(a, b) {
    /** @type {number} */
    var r = a.sortIndex - b.sortIndex;
    return 0 !== r ? r : a.id - b.id;
  }
  /**
   * @param {?} time
   * @return {undefined}
   */
  function animate(time) {
    var value = parseInt(text);
    for (; null !== value;) {
      if (null === value.callback) {
        decode(text);
      } else {
        if (!(value.startTime <= time)) {
          break;
        }
        decode(text);
        value.sortIndex = value.expirationTime;
        search(name, value);
      }
      value = parseInt(text);
    }
  }
  /**
   * @param {?} now
   * @return {undefined}
   */
  function func(now) {
    if (err = false, animate(now), !inputWin) {
      if (null !== parseInt(name)) {
        /** @type {boolean} */
        inputWin = true;
        close(complete);
      } else {
        var out = parseInt(text);
        if (null !== out) {
          next(func, out.startTime - now);
        }
      }
    }
  }
  /**
   * @param {string} force
   * @param {?} now
   * @return {?}
   */
  function complete(force, now) {
    /** @type {boolean} */
    inputWin = false;
    if (err) {
      /** @type {boolean} */
      err = false;
      done();
    }
    /** @type {boolean} */
    winRef = true;
    var _a = result;
    try {
      animate(now);
      item = parseInt(name);
      for (; null !== item && (!(item.expirationTime > now) || force && !getCompoundIndex());) {
        var callback = item.callback;
        if (null !== callback) {
          /** @type {null} */
          item.callback = null;
          result = item.priorityLevel;
          var cb = callback(item.expirationTime <= now);
          now = encoded.unstable_now();
          if ("function" === typeof cb) {
            /** @type {!Function} */
            item.callback = cb;
          } else {
            if (item === parseInt(name)) {
              decode(name);
            }
          }
          animate(now);
        } else {
          decode(name);
        }
        item = parseInt(name);
      }
      if (null !== item) {
        /** @type {boolean} */
        var token = true;
      } else {
        var out = parseInt(text);
        if (null !== out) {
          next(func, out.startTime - now);
        }
        /** @type {boolean} */
        token = false;
      }
      return token;
    } finally {
      /** @type {null} */
      item = null;
      result = _a;
      /** @type {boolean} */
      winRef = false;
    }
  }
  /**
   * @param {number} event
   * @return {?}
   */
  function extractTouch(event) {
    switch(event) {
      case 1:
        return -1;
      case 2:
        return 250;
      case 5:
        return 1073741823;
      case 4:
        return 1E4;
      default:
        return 5E3;
    }
  }
  var close;
  var next;
  var done;
  var getCompoundIndex;
  var yoffset;
  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    /** @type {null} */
    var subscribe = null;
    /** @type {null} */
    var t = null;
    /**
     * @return {undefined}
     */
    var setTrailViewOffset = function present() {
      if (null !== subscribe) {
        try {
          var id = encoded.unstable_now();
          subscribe(true, id);
          /** @type {null} */
          subscribe = null;
        } catch (past) {
          throw setTimeout(present, 0), past;
        }
      }
    };
    /** @type {number} */
    var l = Date.now();
    /**
     * @return {?}
     */
    encoded.unstable_now = function() {
      return Date.now() - l;
    };
    /**
     * @param {string} controller
     * @return {undefined}
     */
    close = function(controller) {
      if (null !== subscribe) {
        setTimeout(close, 0, controller);
      } else {
        /** @type {string} */
        subscribe = controller;
        setTimeout(setTrailViewOffset, 0);
      }
    };
    /**
     * @param {!Function} a
     * @param {number} i
     * @return {undefined}
     */
    next = function(a, i) {
      /** @type {number} */
      t = setTimeout(a, i);
    };
    /**
     * @return {undefined}
     */
    done = function() {
      clearTimeout(t);
    };
    /**
     * @return {?}
     */
    getCompoundIndex = function() {
      return false;
    };
    /** @type {function(): undefined} */
    yoffset = encoded.unstable_forceFrameRate = function() {
    };
  } else {
    /** @type {(Performance|null)} */
    var data = window.performance;
    var Date = window.Date;
    var setTimeout = window.setTimeout;
    var clearTimeout = window.clearTimeout;
    if ("undefined" !== typeof console) {
      var cancelAnimationFrame = window.cancelAnimationFrame;
      if ("function" !== typeof window.requestAnimationFrame) {
        console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
      }
      if ("function" !== typeof cancelAnimationFrame) {
        console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills");
      }
    }
    if ("object" === typeof data && "function" === typeof data.now) {
      /**
       * @return {?}
       */
      encoded.unstable_now = function() {
        return data.now();
      };
    } else {
      var y = Date.now();
      /**
       * @return {?}
       */
      encoded.unstable_now = function() {
        return Date.now() - y;
      };
    }
    /** @type {boolean} */
    var v = false;
    /** @type {null} */
    var cb = null;
    /** @type {number} */
    var pendingReconnect = -1;
    /** @type {number} */
    var key = 5;
    /** @type {number} */
    var val = 0;
    /**
     * @return {?}
     */
    getCompoundIndex = function() {
      return encoded.unstable_now() >= val;
    };
    /**
     * @return {undefined}
     */
    yoffset = function() {
    };
    /**
     * @param {number} font_height
     * @return {undefined}
     */
    encoded.unstable_forceFrameRate = function(font_height) {
      if (0 > font_height || 125 < font_height) {
        console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported");
      } else {
        /** @type {number} */
        key = 0 < font_height ? Math.floor(1E3 / font_height) : 5;
      }
    };
    /** @type {!MessageChannel} */
    var channel = new MessageChannel;
    /** @type {!MessagePort} */
    var port2 = channel.port2;
    /**
     * @return {undefined}
     */
    channel.port1.onmessage = function() {
      if (null !== cb) {
        var domain = encoded.unstable_now();
        val = domain + key;
        try {
          if (cb(true, domain)) {
            port2.postMessage(null);
          } else {
            /** @type {boolean} */
            v = false;
            /** @type {null} */
            cb = null;
          }
        } catch (r) {
          throw port2.postMessage(null), r;
        }
      } else {
        /** @type {boolean} */
        v = false;
      }
    };
    /**
     * @param {string} force
     * @return {undefined}
     */
    close = function(force) {
      /** @type {string} */
      cb = force;
      if (!v) {
        /** @type {boolean} */
        v = true;
        port2.postMessage(null);
      }
    };
    /**
     * @param {!Function} filter
     * @param {number} delay
     * @return {undefined}
     */
    next = function(filter, delay) {
      pendingReconnect = setTimeout(function() {
        filter(encoded.unstable_now());
      }, delay);
    };
    /**
     * @return {undefined}
     */
    done = function() {
      clearTimeout(pendingReconnect);
      /** @type {number} */
      pendingReconnect = -1;
    };
  }
  /** @type {!Array} */
  var name = [];
  /** @type {!Array} */
  var text = [];
  /** @type {number} */
  var nChanges = 1;
  /** @type {null} */
  var item = null;
  /** @type {number} */
  var result = 3;
  /** @type {boolean} */
  var winRef = false;
  /** @type {boolean} */
  var inputWin = false;
  /** @type {boolean} */
  var err = false;
  /** @type {function(): undefined} */
  var q = yoffset;
  /** @type {number} */
  encoded.unstable_IdlePriority = 5;
  /** @type {number} */
  encoded.unstable_ImmediatePriority = 1;
  /** @type {number} */
  encoded.unstable_LowPriority = 4;
  /** @type {number} */
  encoded.unstable_NormalPriority = 3;
  /** @type {null} */
  encoded.unstable_Profiling = null;
  /** @type {number} */
  encoded.unstable_UserBlockingPriority = 2;
  /**
   * @param {!Object} handler
   * @return {undefined}
   */
  encoded.unstable_cancelCallback = function(handler) {
    /** @type {null} */
    handler.callback = null;
  };
  /**
   * @return {undefined}
   */
  encoded.unstable_continueExecution = function() {
    if (!(inputWin || winRef)) {
      /** @type {boolean} */
      inputWin = true;
      close(complete);
    }
  };
  /**
   * @return {?}
   */
  encoded.unstable_getCurrentPriorityLevel = function() {
    return result;
  };
  /**
   * @return {?}
   */
  encoded.unstable_getFirstCallbackNode = function() {
    return parseInt(name);
  };
  /**
   * @param {?} saveNotifs
   * @return {?}
   */
  encoded.unstable_next = function(saveNotifs) {
    switch(result) {
      case 1:
      case 2:
      case 3:
        /** @type {number} */
        var err = 3;
        break;
      default:
        err = result;
    }
    var _a = result;
    result = err;
    try {
      return saveNotifs();
    } finally {
      result = _a;
    }
  };
  /**
   * @return {undefined}
   */
  encoded.unstable_pauseExecution = function() {
  };
  /** @type {function(): undefined} */
  encoded.unstable_requestPaint = q;
  /**
   * @param {number} e
   * @param {!Function} t
   * @return {?}
   */
  encoded.unstable_runWithPriority = function(e, t) {
    switch(e) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        /** @type {number} */
        e = 3;
    }
    var _a = result;
    /** @type {number} */
    result = e;
    try {
      return t();
    } finally {
      result = _a;
    }
  };
  /**
   * @param {number} n
   * @param {!Function} fn
   * @param {!Object} e
   * @return {?}
   */
  encoded.unstable_scheduleCallback = function(n, fn, e) {
    var length = encoded.unstable_now();
    if ("object" === typeof e && null !== e) {
      var index = e.delay;
      index = "number" === typeof index && 0 < index ? length + index : length;
      e = "number" === typeof e.timeout ? e.timeout : extractTouch(n);
    } else {
      e = extractTouch(n);
      index = length;
    }
    return n = {
      id : nChanges++,
      callback : fn,
      priorityLevel : n,
      startTime : index,
      expirationTime : e = index + e,
      sortIndex : -1
    }, index > length ? (n.sortIndex = index, search(text, n), null === parseInt(name) && n === parseInt(text) && (err ? done() : err = true, next(func, index - length))) : (n.sortIndex = e, search(name, n), inputWin || winRef || (inputWin = true, close(complete))), n;
  };
  /**
   * @return {?}
   */
  encoded.unstable_shouldYield = function() {
    var time = encoded.unstable_now();
    animate(time);
    var value = parseInt(name);
    return value !== item && null !== item && null !== value && null !== value.callback && value.startTime <= time && value.expirationTime < item.expirationTime || getCompoundIndex();
  };
  /**
   * @param {!Function} CropAreaRectangle
   * @return {?}
   */
  encoded.unstable_wrapCallback = function(CropAreaRectangle) {
    var _a = result;
    return function() {
      var data = result;
      result = _a;
      try {
        return CropAreaRectangle.apply(this, arguments);
      } finally {
        result = data;
      }
    };
  };
}, , , , function(canCreateDiscussions, exports, isSlidingUp) {
  /**
   * @param {string} prop
   * @return {?}
   */
  function split(prop) {
    var start = prop.length;
    if (start % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var options = prop.indexOf("=");
    return -1 === options && (options = start), [options, options === start ? 0 : 4 - options % 4];
  }
  /**
   * @param {string} uint8
   * @param {number} start
   * @param {number} end
   * @return {?}
   */
  function encodeChunk(uint8, start, end) {
    var tObj;
    var o;
    /** @type {!Array} */
    var outChance = [];
    /** @type {number} */
    var i = start;
    for (; i < end; i = i + 3) {
      /** @type {number} */
      tObj = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (255 & uint8[i + 2]);
      outChance.push(m[(o = tObj) >> 18 & 63] + m[o >> 12 & 63] + m[o >> 6 & 63] + m[63 & o]);
    }
    return outChance.join("");
  }
  /**
   * @param {string} value
   * @return {?}
   */
  exports.byteLength = function(value) {
    var words = split(value);
    var password = words[0];
    var name = words[1];
    return 3 * (password + name) / 4 - name;
  };
  /**
   * @param {string} data
   * @return {?}
   */
  exports.toByteArray = function(data) {
    var LIMB_BITMASK;
    var i;
    var arr = split(data);
    var key = arr[0];
    var max = arr[1];
    var array = new Arr(function(addedRenderer, gen_id, maxDigits) {
      return 3 * (gen_id + maxDigits) / 4 - maxDigits;
    }(0, key, max));
    /** @type {number} */
    var item = 0;
    var ext = max > 0 ? key - 4 : key;
    /** @type {number} */
    i = 0;
    for (; i < ext; i = i + 4) {
      /** @type {number} */
      LIMB_BITMASK = o[data.charCodeAt(i)] << 18 | o[data.charCodeAt(i + 1)] << 12 | o[data.charCodeAt(i + 2)] << 6 | o[data.charCodeAt(i + 3)];
      /** @type {number} */
      array[item++] = LIMB_BITMASK >> 16 & 255;
      /** @type {number} */
      array[item++] = LIMB_BITMASK >> 8 & 255;
      /** @type {number} */
      array[item++] = 255 & LIMB_BITMASK;
    }
    if (2 === max) {
      /** @type {number} */
      LIMB_BITMASK = o[data.charCodeAt(i)] << 2 | o[data.charCodeAt(i + 1)] >> 4;
      /** @type {number} */
      array[item++] = 255 & LIMB_BITMASK;
    }
    if (1 === max) {
      /** @type {number} */
      LIMB_BITMASK = o[data.charCodeAt(i)] << 10 | o[data.charCodeAt(i + 1)] << 4 | o[data.charCodeAt(i + 2)] >> 2;
      /** @type {number} */
      array[item++] = LIMB_BITMASK >> 8 & 255;
      /** @type {number} */
      array[item++] = 255 & LIMB_BITMASK;
    }
    return array;
  };
  /**
   * @param {string} uint8
   * @return {?}
   */
  exports.fromByteArray = function(uint8) {
    var l;
    var len = uint8.length;
    /** @type {number} */
    var extraBytes = len % 3;
    /** @type {!Array} */
    var parts = [];
    /** @type {number} */
    var i = 0;
    /** @type {number} */
    var len2 = len - extraBytes;
    for (; i < len2; i = i + 16383) {
      parts.push(encodeChunk(uint8, i, i + 16383 > len2 ? len2 : i + 16383));
    }
    if (1 === extraBytes) {
      l = uint8[len - 1];
      parts.push(m[l >> 2] + m[l << 4 & 63] + "==");
    } else {
      if (2 === extraBytes) {
        l = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(m[l >> 10] + m[l >> 4 & 63] + m[l << 2 & 63] + "=");
      }
    }
    return parts.join("");
  };
  /** @type {!Array} */
  var m = [];
  /** @type {!Array} */
  var o = [];
  /** @type {!Function} */
  var Arr = "undefined" !== typeof Uint8Array ? Uint8Array : Array;
  /** @type {string} */
  var m1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  /** @type {number} */
  var k = 0;
  /** @type {number} */
  var level = m1.length;
  for (; k < level; ++k) {
    m[k] = m1[k];
    /** @type {number} */
    o[m1.charCodeAt(k)] = k;
  }
  /** @type {number} */
  o["-".charCodeAt(0)] = 62;
  /** @type {number} */
  o["_".charCodeAt(0)] = 63;
}, function(canCreateDiscussions, asyncFile) {
  /**
   * @param {number} x
   * @param {number} a
   * @param {boolean} t
   * @param {number} n
   * @param {number} b
   * @return {?}
   */
  asyncFile.read = function(x, a, t, n, b) {
    var i;
    var m;
    /** @type {number} */
    var theTokenLength = 8 * b - n - 1;
    /** @type {number} */
    var ms_controller = (1 << theTokenLength) - 1;
    /** @type {number} */
    var TIMEOUT_POLL_DECREMENT = ms_controller >> 1;
    /** @type {number} */
    var index = -7;
    /** @type {number} */
    var j = t ? b - 1 : 0;
    /** @type {number} */
    var c = t ? -1 : 1;
    var s = x[a + j];
    /** @type {number} */
    j = j + c;
    /** @type {number} */
    i = s & (1 << -index) - 1;
    /** @type {number} */
    s = s >> -index;
    /** @type {number} */
    index = index + theTokenLength;
    for (; index > 0; i = 256 * i + x[a + j], j = j + c, index = index - 8) {
    }
    /** @type {number} */
    m = i & (1 << -index) - 1;
    /** @type {number} */
    i = i >> -index;
    index = index + n;
    for (; index > 0; m = 256 * m + x[a + j], j = j + c, index = index - 8) {
    }
    if (0 === i) {
      /** @type {number} */
      i = 1 - TIMEOUT_POLL_DECREMENT;
    } else {
      if (i === ms_controller) {
        return m ? NaN : 1 / 0 * (s ? -1 : 1);
      }
      m = m + Math.pow(2, n);
      /** @type {number} */
      i = i - TIMEOUT_POLL_DECREMENT;
    }
    return (s ? -1 : 1) * m * Math.pow(2, i - n);
  };
  /**
   * @param {!Object} a
   * @param {number} v
   * @param {number} offset
   * @param {boolean} isLE
   * @param {number} mLen
   * @param {number} nBytes
   * @return {undefined}
   */
  asyncFile.write = function(a, v, offset, isLE, mLen, nBytes) {
    var e;
    var m;
    var c;
    /** @type {number} */
    var eLen = 8 * nBytes - mLen - 1;
    /** @type {number} */
    var eMax = (1 << eLen) - 1;
    /** @type {number} */
    var eBias = eMax >> 1;
    /** @type {number} */
    var rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    /** @type {number} */
    var i = isLE ? 0 : nBytes - 1;
    /** @type {number} */
    var d = isLE ? 1 : -1;
    /** @type {number} */
    var b = v < 0 || 0 === v && 1 / v < 0 ? 1 : 0;
    /** @type {number} */
    v = Math.abs(v);
    if (isNaN(v) || v === 1 / 0) {
      /** @type {number} */
      m = isNaN(v) ? 1 : 0;
      /** @type {number} */
      e = eMax;
    } else {
      /** @type {number} */
      e = Math.floor(Math.log(v) / Math.LN2);
      if (v * (c = Math.pow(2, -e)) < 1) {
        e--;
        /** @type {number} */
        c = c * 2;
      }
      if ((v = v + (e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias))) * c >= 2) {
        e++;
        /** @type {number} */
        c = c / 2;
      }
      if (e + eBias >= eMax) {
        /** @type {number} */
        m = 0;
        /** @type {number} */
        e = eMax;
      } else {
        if (e + eBias >= 1) {
          /** @type {number} */
          m = (v * c - 1) * Math.pow(2, mLen);
          /** @type {number} */
          e = e + eBias;
        } else {
          /** @type {number} */
          m = v * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          /** @type {number} */
          e = 0;
        }
      }
    }
    for (; mLen >= 8; a[offset + i] = 255 & m, i = i + d, m = m / 256, mLen = mLen - 8) {
    }
    /** @type {number} */
    e = e << mLen | m;
    eLen = eLen + mLen;
    for (; eLen > 0; a[offset + i] = 255 & e, i = i + d, e = e / 256, eLen = eLen - 8) {
    }
    a[offset + i - d] |= 128 * b;
  };
}, , function(module, canCreateDiscussions, require) {
  var Buffer = require(40).Buffer;
  var obj = require(122);
  module.exports = function() {
    /**
     * @return {undefined}
     */
    function f() {
      !function(value, t) {
        if (!(value instanceof t)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }(this, f);
      /** @type {null} */
      this.head = null;
      /** @type {null} */
      this.tail = null;
      /** @type {number} */
      this.length = 0;
    }
    return f.prototype.push = function(value) {
      var node = {
        data : value,
        next : null
      };
      if (this.length > 0) {
        this.tail.next = node;
      } else {
        this.head = node;
      }
      this.tail = node;
      ++this.length;
    }, f.prototype.unshift = function(str) {
      var node = {
        data : str,
        next : this.head
      };
      if (0 === this.length) {
        this.tail = node;
      }
      this.head = node;
      ++this.length;
    }, f.prototype.shift = function() {
      if (0 !== this.length) {
        var node = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, node;
      }
    }, f.prototype.clear = function() {
      /** @type {null} */
      this.head = this.tail = null;
      /** @type {number} */
      this.length = 0;
    }, f.prototype.join = function(value) {
      if (0 === this.length) {
        return "";
      }
      var node = this.head;
      /** @type {string} */
      var body = "" + node.data;
      for (; node = node.next;) {
        /** @type {string} */
        body = body + (value + node.data);
      }
      return body;
    }, f.prototype.concat = function(var_args) {
      if (0 === this.length) {
        return Buffer.alloc(0);
      }
      if (1 === this.length) {
        return this.head.data;
      }
      var value;
      var r;
      var i;
      var first = Buffer.allocUnsafe(var_args >>> 0);
      var node = this.head;
      /** @type {number} */
      var clipcheck = 0;
      for (; node;) {
        value = node.data;
        r = first;
        i = clipcheck;
        value.copy(r, i);
        clipcheck = clipcheck + node.data.length;
        node = node.next;
      }
      return first;
    }, f;
  }();
  if (obj && obj.inspect && obj.inspect.custom) {
    /**
     * @return {?}
     */
    module.exports.prototype[obj.inspect.custom] = function() {
      var e = obj.inspect({
        length : this.length
      });
      return this.constructor.name + " " + e;
    };
  }
}, , function(canCreateDiscussions, exports, moment) {
  (function(global) {
    /**
     * @param {string} id
     * @param {!Function} clearFn
     * @return {undefined}
     */
    function Timeout(id, clearFn) {
      /** @type {string} */
      this._id = id;
      /** @type {!Function} */
      this._clearFn = clearFn;
    }
    var target = "undefined" !== typeof global && global || "undefined" !== typeof self && self || window;
    /** @type {function(this:!Function, ...*): *} */
    var apply = Function.prototype.apply;
    /**
     * @return {?}
     */
    exports.setTimeout = function() {
      return new Timeout(apply.call(setTimeout, target, arguments), clearTimeout);
    };
    /**
     * @return {?}
     */
    exports.setInterval = function() {
      return new Timeout(apply.call(setInterval, target, arguments), clearInterval);
    };
    /** @type {function(!Object): undefined} */
    exports.clearTimeout = exports.clearInterval = function(n) {
      if (n) {
        n.close();
      }
    };
    /** @type {function(): undefined} */
    Timeout.prototype.unref = Timeout.prototype.ref = function() {
    };
    /**
     * @return {undefined}
     */
    Timeout.prototype.close = function() {
      this._clearFn.call(target, this._id);
    };
    /**
     * @param {?} item
     * @param {number} msecs
     * @return {undefined}
     */
    exports.enroll = function(item, msecs) {
      clearTimeout(item._idleTimeoutId);
      /** @type {number} */
      item._idleTimeout = msecs;
    };
    /**
     * @param {?} item
     * @return {undefined}
     */
    exports.unenroll = function(item) {
      clearTimeout(item._idleTimeoutId);
      /** @type {number} */
      item._idleTimeout = -1;
    };
    /** @type {function(!Object): undefined} */
    exports._unrefActive = exports.active = function(item) {
      clearTimeout(item._idleTimeoutId);
      var msecs = item._idleTimeout;
      if (msecs >= 0) {
        /** @type {number} */
        item._idleTimeoutId = setTimeout(function() {
          if (item._onTimeout) {
            item._onTimeout();
          }
        }, msecs);
      }
    };
    moment(124);
    exports.setImmediate = "undefined" !== typeof self && self.setImmediate || "undefined" !== typeof global && global.setImmediate || this && this.setImmediate;
    exports.clearImmediate = "undefined" !== typeof self && self.clearImmediate || "undefined" !== typeof global && global.clearImmediate || this && this.clearImmediate;
  }).call(this, moment(5));
}, function(canCreateDiscussions, isSlidingUp, __webpack_require__) {
  (function(argSpeed, $process) {
    !function(global, canCreateDiscussions) {
      /**
       * @param {string} key
       * @return {undefined}
       */
      function clear(key) {
        delete result[key];
      }
      /**
       * @param {string} key
       * @return {undefined}
       */
      function render(key) {
        if (a) {
          setTimeout(render, 0, key);
        } else {
          var server = result[key];
          if (server) {
            /** @type {boolean} */
            a = true;
            try {
              !function(task) {
                var callback = task.callback;
                var args = task.args;
                switch(args.length) {
                  case 0:
                    callback();
                    break;
                  case 1:
                    callback(args[0]);
                    break;
                  case 2:
                    callback(args[0], args[1]);
                    break;
                  case 3:
                    callback(args[0], args[1], args[2]);
                    break;
                  default:
                    callback.apply(void 0, args);
                }
              }(server);
            } finally {
              clear(key);
              /** @type {boolean} */
              a = false;
            }
          }
        }
      }
      if (!global.setImmediate) {
        var done;
        /** @type {number} */
        var id = 1;
        var result = {};
        /** @type {boolean} */
        var a = false;
        var document = global.document;
        /** @type {(Object|null)} */
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
        if ("[object process]" === {}.toString.call(global.process)) {
          /**
           * @param {!Function} router
           * @return {undefined}
           */
          done = function(router) {
            $process.nextTick(function() {
              render(router);
            });
          };
        } else {
          if (function() {
            if (global.postMessage && !global.importScripts) {
              /** @type {boolean} */
              var t = true;
              var oldOnMessage = global.onmessage;
              return global.onmessage = function() {
                /** @type {boolean} */
                t = false;
              }, global.postMessage("", "*"), global.onmessage = oldOnMessage, t;
            }
          }()) {
            (function() {
              /** @type {string} */
              var prefix = "setImmediate$" + Math.random() + "$";
              /**
               * @param {!Object} event
               * @return {undefined}
               */
              var onMessage = function(event) {
                if (event.source === global && "string" === typeof event.data && 0 === event.data.indexOf(prefix)) {
                  render(+event.data.slice(prefix.length));
                }
              };
              if (global.addEventListener) {
                global.addEventListener("message", onMessage, false);
              } else {
                global.attachEvent("onmessage", onMessage);
              }
              /**
               * @param {number} index
               * @return {undefined}
               */
              done = function(index) {
                global.postMessage(prefix + index, "*");
              };
            })();
          } else {
            if (global.MessageChannel) {
              (function() {
                /** @type {!MessageChannel} */
                var channel = new MessageChannel;
                /**
                 * @param {!Object} data
                 * @return {undefined}
                 */
                channel.port1.onmessage = function(data) {
                  render(data.data);
                };
                /**
                 * @param {number} height
                 * @return {undefined}
                 */
                done = function(height) {
                  channel.port2.postMessage(height);
                };
              })();
            } else {
              if (document && "onreadystatechange" in document.createElement("script")) {
                (function() {
                  var root = document.documentElement;
                  /**
                   * @param {!Function} router
                   * @return {undefined}
                   */
                  done = function(router) {
                    var script = document.createElement("script");
                    /**
                     * @return {undefined}
                     */
                    script.onreadystatechange = function() {
                      render(router);
                      /** @type {null} */
                      script.onreadystatechange = null;
                      root.removeChild(script);
                      /** @type {null} */
                      script = null;
                    };
                    root.appendChild(script);
                  };
                })();
              } else {
                /**
                 * @param {number} height
                 * @return {undefined}
                 */
                done = function(height) {
                  setTimeout(render, 0, height);
                };
              }
            }
          }
        }
        /**
         * @param {!Object} value
         * @return {?}
         */
        attachTo.setImmediate = function(value) {
          if ("function" !== typeof value) {
            /** @type {!Function} */
            value = new Function("" + value);
          }
          /** @type {!Array} */
          var G__20381__a = new Array(arguments.length - 1);
          /** @type {number} */
          var G__20381__i = 0;
          for (; G__20381__i < G__20381__a.length; G__20381__i++) {
            G__20381__a[G__20381__i] = arguments[G__20381__i + 1];
          }
          var obj = {
            callback : value,
            args : G__20381__a
          };
          return result[id] = obj, done(id), id++;
        };
        /** @type {function(string): undefined} */
        attachTo.clearImmediate = clear;
      }
    }("undefined" === typeof self ? "undefined" === typeof argSpeed ? this : argSpeed : self);
  }).call(this, __webpack_require__(5), __webpack_require__(8));
}, function(mixin, canCreateDiscussions, moment) {
  (function(backgroundPage) {
    /**
     * @param {string} name
     * @return {?}
     */
    function config(name) {
      try {
        if (!backgroundPage.localStorage) {
          return false;
        }
      } catch (n) {
        return false;
      }
      var vl = backgroundPage.localStorage[name];
      return null != vl && "true" === String(vl).toLowerCase();
    }
    /**
     * @param {!Object} value
     * @param {string} str
     * @return {?}
     */
    mixin.exports = function(value, str) {
      if (config("noDeprecation")) {
        return value;
      }
      /** @type {boolean} */
      var n = false;
      return function() {
        if (!n) {
          if (config("throwDeprecation")) {
            throw new Error(str);
          }
          if (config("traceDeprecation")) {
            console.trace(str);
          } else {
            console.warn(str);
          }
          /** @type {boolean} */
          n = true;
        }
        return value.apply(this, arguments);
      };
    };
  }).call(this, moment(5));
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {?}
   */
  function FilterStream(key) {
    if (!(this instanceof FilterStream)) {
      return new FilterStream(key);
    }
    SchemaType.call(this, key);
  }
  /** @type {function(string): ?} */
  module.exports = FilterStream;
  var SchemaType = require(69);
  /** @type {!Object} */
  var util = Object.create(require(21));
  util.inherits = require(1);
  util.inherits(FilterStream, SchemaType);
  /**
   * @param {!Array} rws
   * @param {!Array} iws
   * @param {!Array} rtws
   * @return {undefined}
   */
  FilterStream.prototype._transform = function(rws, iws, rtws) {
    rtws(null, rws);
  };
}, function(module, canCreateDiscussions, factory) {
  module.exports = factory(41);
}, function(module, canCreateDiscussions, factory) {
  module.exports = factory(13);
}, function(mixin, canCreateDiscussions, saveNotifs) {
  mixin.exports = saveNotifs(20).Transform;
}, function(mixin, canCreateDiscussions, saveNotifs) {
  mixin.exports = saveNotifs(20).PassThrough;
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha512() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    Duplex.call(this, 64, 56);
  }
  /**
   * @param {number} num
   * @return {?}
   */
  function rol(num) {
    return num << 30 | num >>> 2;
  }
  /**
   * @param {number} range
   * @param {number} k
   * @param {number} g
   * @param {number} j
   * @return {?}
   */
  function callback(range, k, g, j) {
    return 0 === range ? k & g | ~k & j : 2 === range ? k & g | k & j | g & j : k ^ g ^ j;
  }
  var inherits = require(1);
  var Duplex = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var newAttempts = [1518500249, 1859775393, -1894007588, -899497514];
  /** @type {!Array} */
  var w = new Array(80);
  inherits(Sha512, Duplex);
  /**
   * @return {?}
   */
  Sha512.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  /**
   * @param {!Object} buffer
   * @return {undefined}
   */
  Sha512.prototype._update = function(buffer) {
    var optionUsed2;
    var W = this._w;
    /** @type {number} */
    var a = 0 | this._a;
    /** @type {number} */
    var b = 0 | this._b;
    /** @type {number} */
    var c = 0 | this._c;
    /** @type {number} */
    var d = 0 | this._d;
    /** @type {number} */
    var e = 0 | this._e;
    /** @type {number} */
    var j = 0;
    for (; j < 16; ++j) {
      W[j] = buffer.readInt32BE(4 * j);
    }
    for (; j < 80; ++j) {
      /** @type {number} */
      W[j] = W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16];
    }
    /** @type {number} */
    var i = 0;
    for (; i < 80; ++i) {
      /** @type {number} */
      var time = ~~(i / 20);
      /** @type {number} */
      var nativeObjectObject = 0 | ((optionUsed2 = a) << 5 | optionUsed2 >>> 27) + callback(time, b, c, d) + e + W[i] + newAttempts[time];
      e = d;
      d = c;
      c = rol(b);
      /** @type {number} */
      b = a;
      /** @type {number} */
      a = nativeObjectObject;
    }
    /** @type {number} */
    this._a = a + this._a | 0;
    /** @type {number} */
    this._b = b + this._b | 0;
    /** @type {number} */
    this._c = c + this._c | 0;
    /** @type {number} */
    this._d = d + this._d | 0;
    /** @type {number} */
    this._e = e + this._e | 0;
  };
  /**
   * @return {?}
   */
  Sha512.prototype._hash = function() {
    var arr = Buffer.allocUnsafe(20);
    return arr.writeInt32BE(0 | this._a, 0), arr.writeInt32BE(0 | this._b, 4), arr.writeInt32BE(0 | this._c, 8), arr.writeInt32BE(0 | this._d, 12), arr.writeInt32BE(0 | this._e, 16), arr;
  };
  /** @type {function(): undefined} */
  mixin.exports = Sha512;
}, function(mixin, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha512() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    Duplex.call(this, 64, 56);
  }
  /**
   * @param {number} x
   * @return {?}
   */
  function ROTL(x) {
    return x << 5 | x >>> 27;
  }
  /**
   * @param {number} num
   * @return {?}
   */
  function rol(num) {
    return num << 30 | num >>> 2;
  }
  /**
   * @param {number} g
   * @param {number} b
   * @param {number} a
   * @param {number} d
   * @return {?}
   */
  function f(g, b, a, d) {
    return 0 === g ? b & a | ~b & d : 2 === g ? b & a | b & d | a & d : b ^ a ^ d;
  }
  var inherits = require(1);
  var Duplex = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var data_series = [1518500249, 1859775393, -1894007588, -899497514];
  /** @type {!Array} */
  var w = new Array(80);
  inherits(Sha512, Duplex);
  /**
   * @return {?}
   */
  Sha512.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  /**
   * @param {!Object} buffer
   * @return {undefined}
   */
  Sha512.prototype._update = function(buffer) {
    var t;
    var W = this._w;
    /** @type {number} */
    var a = 0 | this._a;
    /** @type {number} */
    var b = 0 | this._b;
    /** @type {number} */
    var c = 0 | this._c;
    /** @type {number} */
    var d = 0 | this._d;
    /** @type {number} */
    var e = 0 | this._e;
    /** @type {number} */
    var j = 0;
    for (; j < 16; ++j) {
      W[j] = buffer.readInt32BE(4 * j);
    }
    for (; j < 80; ++j) {
      /** @type {number} */
      W[j] = (t = W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16]) << 1 | t >>> 31;
    }
    /** @type {number} */
    var i = 0;
    for (; i < 80; ++i) {
      /** @type {number} */
      var s = ~~(i / 20);
      /** @type {number} */
      var l8r = ROTL(a) + f(s, b, c, d) + e + W[i] + data_series[s] | 0;
      e = d;
      d = c;
      c = rol(b);
      /** @type {number} */
      b = a;
      /** @type {number} */
      a = l8r;
    }
    /** @type {number} */
    this._a = a + this._a | 0;
    /** @type {number} */
    this._b = b + this._b | 0;
    /** @type {number} */
    this._c = c + this._c | 0;
    /** @type {number} */
    this._d = d + this._d | 0;
    /** @type {number} */
    this._e = e + this._e | 0;
  };
  /**
   * @return {?}
   */
  Sha512.prototype._hash = function() {
    var arr = Buffer.allocUnsafe(20);
    return arr.writeInt32BE(0 | this._a, 0), arr.writeInt32BE(0 | this._b, 4), arr.writeInt32BE(0 | this._c, 8), arr.writeInt32BE(0 | this._d, 12), arr.writeInt32BE(0 | this._e, 16), arr;
  };
  /** @type {function(): undefined} */
  mixin.exports = Sha512;
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha224() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    o.call(this, 64, 56);
  }
  var inherits = require(1);
  var _Dispatcher = require(70);
  var o = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var w = new Array(64);
  inherits(Sha224, _Dispatcher);
  /**
   * @return {?}
   */
  Sha224.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  };
  /**
   * @return {?}
   */
  Sha224.prototype._hash = function() {
    var H = Buffer.allocUnsafe(28);
    return H.writeInt32BE(this._a, 0), H.writeInt32BE(this._b, 4), H.writeInt32BE(this._c, 8), H.writeInt32BE(this._d, 12), H.writeInt32BE(this._e, 16), H.writeInt32BE(this._f, 20), H.writeInt32BE(this._g, 24), H;
  };
  /** @type {function(): undefined} */
  module.exports = Sha224;
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {undefined}
   */
  function Sha224() {
    this.init();
    /** @type {!Array} */
    this._w = w;
    o.call(this, 128, 112);
  }
  var inherits = require(1);
  var _Dispatcher = require(71);
  var o = require(17);
  var Buffer = require(2).Buffer;
  /** @type {!Array} */
  var w = new Array(160);
  inherits(Sha224, _Dispatcher);
  /**
   * @return {?}
   */
  Sha224.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  };
  /**
   * @return {?}
   */
  Sha224.prototype._hash = function() {
    /**
     * @param {undefined} val
     * @param {undefined} num
     * @param {number} offset
     * @return {undefined}
     */
    function writeInt64BE(val, num, offset) {
      buff.writeInt32BE(val, offset);
      buff.writeInt32BE(num, offset + 4);
    }
    var buff = Buffer.allocUnsafe(48);
    return writeInt64BE(this._ah, this._al, 0), writeInt64BE(this._bh, this._bl, 8), writeInt64BE(this._ch, this._cl, 16), writeInt64BE(this._dh, this._dl, 24), writeInt64BE(this._eh, this._el, 32), writeInt64BE(this._fh, this._fl, 40), buff;
  };
  /** @type {function(): undefined} */
  module.exports = Sha224;
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @param {string} data
   * @return {undefined}
   */
  function Hmac(key, data) {
    Base.call(this, "digest");
    if ("string" === typeof data) {
      data = Buffer.from(data);
    }
    /** @type {string} */
    this._alg = key;
    /** @type {string} */
    this._key = data;
    if (data.length > 64) {
      data = key(data);
    } else {
      if (data.length < 64) {
        data = Buffer.concat([data, decFinal], 64);
      }
    }
    var ipad = this._ipad = Buffer.allocUnsafe(64);
    var opad = this._opad = Buffer.allocUnsafe(64);
    /** @type {number} */
    var i = 0;
    for (; i < 64; i++) {
      /** @type {number} */
      ipad[i] = 54 ^ data[i];
      /** @type {number} */
      opad[i] = 92 ^ data[i];
    }
    /** @type {!Array} */
    this._hash = [ipad];
  }
  var inherits = require(1);
  var Buffer = require(2).Buffer;
  var Base = require(10);
  var decFinal = Buffer.alloc(128);
  inherits(Hmac, Base);
  /**
   * @param {!Object} data
   * @return {undefined}
   */
  Hmac.prototype._update = function(data) {
    this._hash.push(data);
  };
  /**
   * @return {?}
   */
  Hmac.prototype._final = function() {
    var decFinal = this._alg(Buffer.concat(this._hash));
    return this._alg(Buffer.concat([this._opad, decFinal]));
  };
  /** @type {function(string, string): undefined} */
  module.exports = Hmac;
}, function(module, canCreateDiscussions, factory) {
  module.exports = factory(74);
}, function(mixin, canCreateDiscussions, require) {
  (function(window, $process) {
    /**
     * @param {string} key
     * @param {?} val
     * @param {number} i
     * @param {number} fields
     * @param {string} k
     * @return {?}
     */
    function fn(key, val, i, fields, k) {
      return subtleCrypto.importKey("raw", key, {
        name : "PBKDF2"
      }, false, ["deriveBits"]).then(function(key) {
        return subtleCrypto.deriveBits({
          name : "PBKDF2",
          salt : val,
          iterations : i,
          hash : {
            name : k
          }
        }, key, fields << 3);
      }).then(function(e) {
        return Buffer.from(e);
      });
    }
    var error;
    var walk = require(76);
    var type = require(77);
    var callback = require(78);
    var Buffer = require(2).Buffer;
    var subtleCrypto = window.crypto && window.crypto.subtle;
    var doc = {
      sha : "SHA-1",
      "sha-1" : "SHA-1",
      sha1 : "SHA-1",
      sha256 : "SHA-256",
      "sha-256" : "SHA-256",
      sha384 : "SHA-384",
      "sha-384" : "SHA-384",
      "sha-512" : "SHA-512",
      sha512 : "SHA-512"
    };
    /** @type {!Array} */
    var types = [];
    /**
     * @param {string} value
     * @param {?} options
     * @param {?} i
     * @param {undefined} data
     * @param {string} digest
     * @param {string} callback
     * @return {?}
     */
    mixin.exports = function(value, options, i, data, digest, callback) {
      if ("function" === typeof digest) {
        /** @type {string} */
        callback = digest;
        digest = void 0;
      }
      var element = doc[(digest = digest || "sha1").toLowerCase()];
      if (!element || "function" !== typeof window.Promise) {
        return $process.nextTick(function() {
          var result;
          try {
            result = callback(value, options, i, data, digest);
          } catch (identifierPositions) {
            return callback(identifierPositions);
          }
          callback(null, result);
        });
      }
      if (walk(value, options, i, data), "function" !== typeof callback) {
        throw new Error("No callback provided to pbkdf2");
      }
      if (!Buffer.isBuffer(value)) {
        value = Buffer.from(value, type);
      }
      if (!Buffer.isBuffer(options)) {
        options = Buffer.from(options, type);
      }
      (function(actionAsPromise, t) {
        actionAsPromise.then(function(val_error) {
          $process.nextTick(function() {
            t(null, val_error);
          });
        }, function(e) {
          $process.nextTick(function() {
            t(e);
          });
        });
      })(function(t) {
        if (window.process && !window.process.browser) {
          return Promise.resolve(false);
        }
        if (!subtleCrypto || !subtleCrypto.importKey || !subtleCrypto.deriveBits) {
          return Promise.resolve(false);
        }
        if (void 0 !== types[t]) {
          return types[t];
        }
        var String = fn(error = error || Buffer.alloc(8), error, 10, 128, t).then(function() {
          return true;
        }).catch(function() {
          return false;
        });
        return types[t] = String, String;
      }(element).then(function(format) {
        return format ? fn(value, options, i, data, element) : callback(value, options, i, data, digest);
      }), callback);
    };
  }).call(this, require(5), require(8));
}, function(canCreateDiscussions, crypto, require) {
  /**
   * @param {string} suite
   * @param {?} key
   * @param {!Array} iv
   * @return {?}
   */
  function createDecipheriv(suite, key, iv) {
    if (suite = suite.toLowerCase(), tests[suite]) {
      return ciphers.createCipheriv(suite, key, iv);
    }
    if (object[suite]) {
      return new Cipher({
        key : key,
        iv : iv,
        mode : suite
      });
    }
    throw new TypeError("invalid suite type");
  }
  /**
   * @param {!Object} suite
   * @param {number} key
   * @param {string} iv
   * @return {?}
   */
  function createCipheriv(suite, key, iv) {
    if (suite = suite.toLowerCase(), tests[suite]) {
      return ciphers.createDecipheriv(suite, key, iv);
    }
    if (object[suite]) {
      return new Cipher({
        key : key,
        iv : iv,
        mode : suite,
        decrypt : true
      });
    }
    throw new TypeError("invalid suite type");
  }
  var Cipher = require(139);
  var ciphers = require(46);
  var tests = require(47);
  var object = require(152);
  var ebtk = require(32);
  /** @type {function(string, ?): ?} */
  crypto.createCipher = crypto.Cipher = function(suite, password) {
    var keyLen;
    var ivLen;
    if (suite = suite.toLowerCase(), tests[suite]) {
      keyLen = tests[suite].key;
      ivLen = tests[suite].iv;
    } else {
      if (!object[suite]) {
        throw new TypeError("invalid suite type");
      }
      /** @type {number} */
      keyLen = 8 * object[suite].key;
      ivLen = object[suite].iv;
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
  };
  /** @type {function(string, ?, !Array): ?} */
  crypto.createCipheriv = crypto.Cipheriv = createDecipheriv;
  /** @type {function(!Object, ?): ?} */
  crypto.createDecipher = crypto.Decipher = function(suite, password) {
    var keyLen;
    var ivLen;
    if (suite = suite.toLowerCase(), tests[suite]) {
      keyLen = tests[suite].key;
      ivLen = tests[suite].iv;
    } else {
      if (!object[suite]) {
        throw new TypeError("invalid suite type");
      }
      /** @type {number} */
      keyLen = 8 * object[suite].key;
      ivLen = object[suite].iv;
    }
    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
  };
  /** @type {function(!Object, number, string): ?} */
  crypto.createDecipheriv = crypto.Decipheriv = createCipheriv;
  /** @type {function(): ?} */
  crypto.listCiphers = crypto.getCiphers = function() {
    return Object.keys(object).concat(ciphers.getCiphers());
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  function DES(key) {
    Duplex.call(this);
    var GET_USER_PROFILE_SUCCESS;
    var name = key.mode.toLowerCase();
    var mode = modes[name];
    /** @type {string} */
    GET_USER_PROFILE_SUCCESS = key.decrypt ? "decrypt" : "encrypt";
    var i = key.key;
    if (!Buffer.isBuffer(i)) {
      i = Buffer.from(i);
    }
    if (!("des-ede" !== name && "des-ede-cbc" !== name)) {
      i = Buffer.concat([i, i.slice(0, 8)]);
    }
    var val = key.iv;
    if (!Buffer.isBuffer(val)) {
      val = Buffer.from(val);
    }
    this._des = mode.create({
      key : i,
      iv : val,
      type : GET_USER_PROFILE_SUCCESS
    });
  }
  var Duplex = require(10);
  var des = require(140);
  var inherits = require(1);
  var Buffer = require(2).Buffer;
  var modes = {
    "des-ede3-cbc" : des.CBC.instantiate(des.EDE),
    "des-ede3" : des.EDE,
    "des-ede-cbc" : des.CBC.instantiate(des.EDE),
    "des-ede" : des.EDE,
    "des-cbc" : des.CBC.instantiate(des.DES),
    "des-ecb" : des.DES
  };
  modes.des = modes["des-cbc"];
  modes.des3 = modes["des-ede3-cbc"];
  /** @type {function(!Object): undefined} */
  module.exports = DES;
  inherits(DES, Duplex);
  /**
   * @param {!Array} data
   * @return {?}
   */
  DES.prototype._update = function(data) {
    return Buffer.from(this._des.update(data));
  };
  /**
   * @return {?}
   */
  DES.prototype._final = function() {
    return Buffer.from(this._des.final());
  };
}, function(canCreateDiscussions, des, require) {
  des.utils = require(79);
  des.Cipher = require(45);
  des.DES = require(80);
  des.CBC = require(141);
  des.EDE = require(142);
}, function(canCreateDiscussions, $menuItems, require) {
  /**
   * @param {!NodeList} rules
   * @return {undefined}
   */
  function _update(rules) {
    assert.equal(rules.length, 8, "Invalid IV length");
    /** @type {!Array} */
    this.iv = new Array(8);
    /** @type {number} */
    var i = 0;
    for (; i < this.iv.length; i++) {
      this.iv[i] = rules[i];
    }
  }
  var assert = require(6);
  var parseArgs = require(1);
  var query = {};
  /**
   * @param {!Function} callback
   * @return {?}
   */
  $menuItems.instantiate = function(callback) {
    /**
     * @param {?} options
     * @return {undefined}
     */
    function CBC(options) {
      callback.call(this, options);
      this._cbcInit();
    }
    parseArgs(CBC, callback);
    /** @type {!Array<string>} */
    var queryFields = Object.keys(query);
    /** @type {number} */
    var i = 0;
    for (; i < queryFields.length; i++) {
      /** @type {string} */
      var key = queryFields[i];
      CBC.prototype[key] = query[key];
    }
    return CBC.create = function(key) {
      return new CBC(key);
    }, CBC;
  };
  /**
   * @return {undefined}
   */
  query._cbcInit = function() {
    var state = new _update(this.options.iv);
    this._cbcState = state;
  };
  /**
   * @param {!Object} inp
   * @param {number} inOff
   * @param {!Array} out
   * @param {number} outOff
   * @return {undefined}
   */
  query._update = function(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state.iv;
    if ("encrypt" === this.type) {
      /** @type {number} */
      var i = 0;
      for (; i < this.blockSize; i++) {
        iv[i] ^= inp[inOff + i];
      }
      superProto._update.call(this, iv, 0, out, outOff);
      /** @type {number} */
      i = 0;
      for (; i < this.blockSize; i++) {
        iv[i] = out[outOff + i];
      }
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);
      /** @type {number} */
      i = 0;
      for (; i < this.blockSize; i++) {
        out[outOff + i] ^= iv[i];
      }
      /** @type {number} */
      i = 0;
      for (; i < this.blockSize; i++) {
        iv[i] = inp[inOff + i];
      }
    }
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} seyfileContent
   * @param {string} options
   * @return {undefined}
   */
  function run(seyfileContent, options) {
    assert.equal(options.length, 24, "Invalid key length");
    var previewKey = options.slice(0, 8);
    var encodedGeohash = options.slice(8, 16);
    var NO_LABEL_TITLE = options.slice(16, 24);
    /** @type {!Array} */
    this.ciphers = "encrypt" === seyfileContent ? [ws.create({
      type : "encrypt",
      key : previewKey
    }), ws.create({
      type : "decrypt",
      key : encodedGeohash
    }), ws.create({
      type : "encrypt",
      key : NO_LABEL_TITLE
    })] : [ws.create({
      type : "decrypt",
      key : NO_LABEL_TITLE
    }), ws.create({
      type : "encrypt",
      key : encodedGeohash
    }), ws.create({
      type : "decrypt",
      key : previewKey
    })];
  }
  /**
   * @param {string} key
   * @return {undefined}
   */
  function Cipher(key) {
    Observer.call(this, key);
    var state = new run(this.type, this.options.key);
    this._edeState = state;
  }
  var assert = require(6);
  var inherits = require(1);
  var Observer = require(45);
  var ws = require(80);
  inherits(Cipher, Observer);
  /** @type {function(string): undefined} */
  module.exports = Cipher;
  /**
   * @param {string} key
   * @return {?}
   */
  Cipher.create = function(key) {
    return new Cipher(key);
  };
  /**
   * @param {!Array} data
   * @param {number} inOff
   * @param {!Array} out
   * @param {number} outOff
   * @return {undefined}
   */
  Cipher.prototype._update = function(data, inOff, out, outOff) {
    var state = this._edeState;
    state.ciphers[0]._update(data, inOff, out, outOff);
    state.ciphers[1]._update(out, outOff, out, outOff);
    state.ciphers[2]._update(out, outOff, out, outOff);
  };
  Cipher.prototype._pad = ws.prototype._pad;
  Cipher.prototype._unpad = ws.prototype._unpad;
}, function(canCreateDiscussions, crypto, require) {
  /**
   * @param {string} mode
   * @param {?} key
   * @param {?} iv
   * @return {undefined}
   */
  function Decipher(mode, key, iv) {
    Chart.call(this);
    this._cache = new Splitter;
    this._cipher = new aes.AES(key);
    this._prev = Buffer.from(iv);
    /** @type {string} */
    this._mode = mode;
    /** @type {boolean} */
    this._autopadding = true;
  }
  /**
   * @return {undefined}
   */
  function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
  }
  /**
   * @param {string} suite
   * @param {?} key
   * @param {?} iv
   * @return {?}
   */
  function createCipheriv(suite, key, iv) {
    var config = engines[suite.toLowerCase()];
    if (!config) {
      throw new TypeError("invalid suite type");
    }
    if ("string" === typeof key && (key = Buffer.from(key)), key.length !== config.key / 8) {
      throw new TypeError("invalid key length " + key.length);
    }
    if ("string" === typeof iv && (iv = Buffer.from(iv)), "GCM" !== config.mode && iv.length !== config.iv) {
      throw new TypeError("invalid iv length " + iv.length);
    }
    return "stream" === config.type ? new Cipher(config.module, key, iv) : "auth" === config.type ? new StreamCipher(config.module, key, iv) : new Decipher(config.module, key, iv);
  }
  var engines = require(47);
  var StreamCipher = require(84);
  var Buffer = require(2).Buffer;
  var Cipher = require(85);
  var Chart = require(10);
  var aes = require(31);
  var ebtk = require(32);
  require(1)(Decipher, Chart);
  /**
   * @param {!Object} name
   * @return {?}
   */
  Decipher.prototype._update = function(name) {
    var chunk;
    var value;
    this._cache.add(name);
    /** @type {!Array} */
    var n = [];
    for (; chunk = this._cache.get();) {
      value = this._mode.encrypt(this, chunk);
      n.push(value);
    }
    return Buffer.concat(n);
  };
  var last = Buffer.alloc(16, 16);
  /**
   * @return {?}
   */
  Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      return chunk = this._mode.encrypt(this, chunk), this._cipher.scrub(), chunk;
    }
    if (!chunk.equals(last)) {
      throw this._cipher.scrub(), new Error("data not multiple of block length");
    }
  };
  /**
   * @param {?} ap
   * @return {?}
   */
  Decipher.prototype.setAutoPadding = function(ap) {
    return this._autopadding = !!ap, this;
  };
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  Splitter.prototype.add = function(key) {
    this.cache = Buffer.concat([this.cache, key]);
  };
  /**
   * @return {?}
   */
  Splitter.prototype.get = function() {
    if (this.cache.length > 15) {
      var e = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), e;
    }
    return null;
  };
  /**
   * @return {?}
   */
  Splitter.prototype.flush = function() {
    /** @type {number} */
    var n = 16 - this.cache.length;
    var b = Buffer.allocUnsafe(n);
    /** @type {number} */
    var i = -1;
    for (; ++i < n;) {
      b.writeUInt8(n, i);
    }
    return Buffer.concat([this.cache, b]);
  };
  /** @type {function(string, ?, ?): ?} */
  crypto.createCipheriv = createCipheriv;
  /**
   * @param {string} suite
   * @param {?} password
   * @return {?}
   */
  crypto.createCipher = function(suite, password) {
    var config = engines[suite.toLowerCase()];
    if (!config) {
      throw new TypeError("invalid suite type");
    }
    var keys = ebtk(password, false, config.key, config.iv);
    return createCipheriv(suite, keys.key, keys.iv);
  };
}, function(canCreateDiscussions, state) {
  /**
   * @param {?} self
   * @param {!Object} block
   * @return {?}
   */
  state.encrypt = function(self, block) {
    return self._cipher.encryptBlock(block);
  };
  /**
   * @param {?} self
   * @param {!Array} block
   * @return {?}
   */
  state.decrypt = function(self, block) {
    return self._cipher.decryptBlock(block);
  };
}, function(canCreateDiscussions, state, require) {
  var xor = require(22);
  /**
   * @param {?} self
   * @param {!Object} block
   * @return {?}
   */
  state.encrypt = function(self, block) {
    var data = xor(block, self._prev);
    return self._prev = self._cipher.encryptBlock(data), self._prev;
  };
  /**
   * @param {?} self
   * @param {!Array} block
   * @return {?}
   */
  state.decrypt = function(self, block) {
    var pad = self._prev;
    /** @type {!Array} */
    self._prev = block;
    var data = self._cipher.decryptBlock(block);
    return xor(data, pad);
  };
}, function(canCreateDiscussions, state, require) {
  /**
   * @param {?} self
   * @param {!Object} data
   * @param {(boolean|number)} success
   * @return {?}
   */
  function reset(self, data, success) {
    var len = data.length;
    var privateKey = xor(data, self._cache);
    return self._cache = self._cache.slice(len), self._prev = Buffer.concat([self._prev, success ? data : privateKey]), privateKey;
  }
  var Buffer = require(2).Buffer;
  var xor = require(22);
  /**
   * @param {?} self
   * @param {!Object} data
   * @param {(boolean|number)} c
   * @return {?}
   */
  state.encrypt = function(self, data, c) {
    var i;
    var out = Buffer.allocUnsafe(0);
    for (; data.length;) {
      if (0 === self._cache.length && (self._cache = self._cipher.encryptBlock(self._prev), self._prev = Buffer.allocUnsafe(0)), !(self._cache.length <= data.length)) {
        out = Buffer.concat([out, reset(self, data, c)]);
        break;
      }
      i = self._cache.length;
      out = Buffer.concat([out, reset(self, data.slice(0, i), c)]);
      data = data.slice(i);
    }
    return out;
  };
}, function(canCreateDiscussions, state, require) {
  /**
   * @param {?} self
   * @param {number} byte
   * @param {number} decrypt
   * @return {?}
   */
  function encryptByte(self, byte, decrypt) {
    /** @type {number} */
    var out = self._cipher.encryptBlock(self._prev)[0] ^ byte;
    return self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byte : out])]), out;
  }
  var Buffer = require(2).Buffer;
  /**
   * @param {?} self
   * @param {!Object} chunk
   * @param {undefined} decrypt
   * @return {?}
   */
  state.encrypt = function(self, chunk, decrypt) {
    var n = chunk.length;
    var out = Buffer.allocUnsafe(n);
    /** @type {number} */
    var i = -1;
    for (; ++i < n;) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }
    return out;
  };
}, function(canCreateDiscussions, state, require) {
  /**
   * @param {?} self
   * @param {number} byte
   * @param {boolean} decrypt
   * @return {?}
   */
  function encryptByte(self, byte, decrypt) {
    var bit;
    var value;
    /** @type {number} */
    var a = -1;
    /** @type {number} */
    var out = 0;
    for (; ++a < 8;) {
      /** @type {number} */
      bit = byte & 1 << 7 - a ? 128 : 0;
      /** @type {number} */
      out = out + ((128 & (value = self._cipher.encryptBlock(self._prev)[0] ^ bit)) >> a % 8);
      self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }
    return out;
  }
  /**
   * @param {!Array} data
   * @param {number} qos
   * @return {?}
   */
  function shiftIn(data, qos) {
    var index = data.length;
    /** @type {number} */
    var i = -1;
    var out = Buffer.allocUnsafe(data.length);
    data = Buffer.concat([data, Buffer.from([qos])]);
    for (; ++i < index;) {
      /** @type {number} */
      out[i] = data[i] << 1 | data[i + 1] >> 7;
    }
    return out;
  }
  var Buffer = require(2).Buffer;
  /**
   * @param {?} self
   * @param {!Object} chunk
   * @param {boolean} decrypt
   * @return {?}
   */
  state.encrypt = function(self, chunk, decrypt) {
    var n = chunk.length;
    var out = Buffer.allocUnsafe(n);
    /** @type {number} */
    var i = -1;
    for (; ++i < n;) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }
    return out;
  };
}, function(canCreateDiscussions, state, require) {
  (function(requestValuesAggs) {
    /**
     * @param {?} self
     * @return {?}
     */
    function encryptByte(self) {
      return self._prev = self._cipher.encryptBlock(self._prev), self._prev;
    }
    var xor = require(22);
    /**
     * @param {?} self
     * @param {!Object} block
     * @return {?}
     */
    state.encrypt = function(self, block) {
      for (; self._cache.length < block.length;) {
        self._cache = requestValuesAggs.concat([self._cache, encryptByte(self)]);
      }
      var Vi = self._cache.slice(0, block.length);
      return self._cache = self._cache.slice(block.length), xor(block, Vi);
    };
  }).call(this, require(3).Buffer);
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Array} array
   * @return {?}
   */
  function fromArray(array) {
    var bufferdata = Buffer.allocUnsafe(16);
    return bufferdata.writeUInt32BE(array[0] >>> 0, 0), bufferdata.writeUInt32BE(array[1] >>> 0, 4), bufferdata.writeUInt32BE(array[2] >>> 0, 8), bufferdata.writeUInt32BE(array[3] >>> 0, 12), bufferdata;
  }
  /**
   * @param {!Function} key
   * @return {undefined}
   */
  function GHASH(key) {
    /** @type {!Function} */
    this.h = key;
    this.state = Buffer.alloc(16, 0);
    this.cache = Buffer.allocUnsafe(0);
  }
  var Buffer = require(2).Buffer;
  var decFinal = Buffer.alloc(16, 0);
  /**
   * @param {number} block
   * @return {undefined}
   */
  GHASH.prototype.ghash = function(block) {
    /** @type {number} */
    var i = -1;
    for (; ++i < block.length;) {
      this.state[i] ^= block[i];
    }
    this._multiply();
  };
  /**
   * @return {undefined}
   */
  GHASH.prototype._multiply = function() {
    var h;
    var i;
    var r;
    /** @type {!Array} */
    var dbMask = [(h = this.h).readUInt32BE(0), h.readUInt32BE(4), h.readUInt32BE(8), h.readUInt32BE(12)];
    /** @type {!Array} */
    var value = [0, 0, 0, 0];
    /** @type {number} */
    var a = -1;
    for (; ++a < 128;) {
      if (0 !== (this.state[~~(a / 8)] & 1 << 7 - a % 8)) {
        value[0] ^= dbMask[0];
        value[1] ^= dbMask[1];
        value[2] ^= dbMask[2];
        value[3] ^= dbMask[3];
      }
      /** @type {boolean} */
      r = 0 !== (1 & dbMask[3]);
      /** @type {number} */
      i = 3;
      for (; i > 0; i--) {
        /** @type {number} */
        dbMask[i] = dbMask[i] >>> 1 | (1 & dbMask[i - 1]) << 31;
      }
      /** @type {number} */
      dbMask[0] = dbMask[0] >>> 1;
      if (r) {
        /** @type {number} */
        dbMask[0] = dbMask[0] ^ 225 << 24;
      }
    }
    this.state = fromArray(value);
  };
  /**
   * @param {!Object} data
   * @return {undefined}
   */
  GHASH.prototype.update = function(data) {
    var chunk;
    this.cache = Buffer.concat([this.cache, data]);
    for (; this.cache.length >= 16;) {
      chunk = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      this.ghash(chunk);
    }
  };
  /**
   * @param {!Function} abl
   * @param {number} bl
   * @return {?}
   */
  GHASH.prototype.final = function(abl, bl) {
    return this.cache.length && this.ghash(Buffer.concat([this.cache, decFinal], 16)), this.ghash(fromArray([0, abl, 0, bl])), this.state;
  };
  /** @type {function(!Function): undefined} */
  module.exports = GHASH;
}, function(canCreateDiscussions, crypto, require) {
  /**
   * @param {string} mode
   * @param {?} key
   * @param {?} iv
   * @return {undefined}
   */
  function Decipher(mode, key, iv) {
    Chart.call(this);
    this._cache = new Splitter;
    this._last = void 0;
    this._cipher = new aes.AES(key);
    this._prev = Buffer.from(iv);
    /** @type {string} */
    this._mode = mode;
    /** @type {boolean} */
    this._autopadding = true;
  }
  /**
   * @return {undefined}
   */
  function Splitter() {
    this.cache = Buffer.allocUnsafe(0);
  }
  /**
   * @param {!Object} suite
   * @param {number} key
   * @param {!Object} iv
   * @return {?}
   */
  function createDecipheriv(suite, key, iv) {
    var config = engines[suite.toLowerCase()];
    if (!config) {
      throw new TypeError("invalid suite type");
    }
    if ("string" === typeof iv && (iv = Buffer.from(iv)), "GCM" !== config.mode && iv.length !== config.iv) {
      throw new TypeError("invalid iv length " + iv.length);
    }
    if ("string" === typeof key && (key = Buffer.from(key)), key.length !== config.key / 8) {
      throw new TypeError("invalid key length " + key.length);
    }
    return "stream" === config.type ? new Cipher(config.module, key, iv, true) : "auth" === config.type ? new StreamCipher(config.module, key, iv, true) : new Decipher(config.module, key, iv);
  }
  var StreamCipher = require(84);
  var Buffer = require(2).Buffer;
  var engines = require(47);
  var Cipher = require(85);
  var Chart = require(10);
  var aes = require(31);
  var ebtk = require(32);
  require(1)(Decipher, Chart);
  /**
   * @param {!Object} name
   * @return {?}
   */
  Decipher.prototype._update = function(name) {
    var chunk;
    var value;
    this._cache.add(name);
    /** @type {!Array} */
    var n = [];
    for (; chunk = this._cache.get(this._autopadding);) {
      value = this._mode.decrypt(this, chunk);
      n.push(value);
    }
    return Buffer.concat(n);
  };
  /**
   * @return {?}
   */
  Decipher.prototype._final = function() {
    var chunk = this._cache.flush();
    if (this._autopadding) {
      return function(kv) {
        var k = kv[15];
        if (k < 1 || k > 16) {
          throw new Error("unable to decrypt data");
        }
        /** @type {number} */
        var i = -1;
        for (; ++i < k;) {
          if (kv[i + (16 - k)] !== k) {
            throw new Error("unable to decrypt data");
          }
        }
        if (16 === k) {
          return;
        }
        return kv.slice(0, 16 - k);
      }(this._mode.decrypt(this, chunk));
    }
    if (chunk) {
      throw new Error("data not multiple of block length");
    }
  };
  /**
   * @param {?} ap
   * @return {?}
   */
  Decipher.prototype.setAutoPadding = function(ap) {
    return this._autopadding = !!ap, this;
  };
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  Splitter.prototype.add = function(key) {
    this.cache = Buffer.concat([this.cache, key]);
  };
  /**
   * @param {string} type
   * @return {?}
   */
  Splitter.prototype.get = function(type) {
    var t;
    if (type) {
      if (this.cache.length > 16) {
        return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
      }
    } else {
      if (this.cache.length >= 16) {
        return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
      }
    }
    return null;
  };
  /**
   * @return {?}
   */
  Splitter.prototype.flush = function() {
    if (this.cache.length) {
      return this.cache;
    }
  };
  /**
   * @param {!Object} suite
   * @param {?} password
   * @return {?}
   */
  crypto.createDecipher = function(suite, password) {
    var config = engines[suite.toLowerCase()];
    if (!config) {
      throw new TypeError("invalid suite type");
    }
    var keys = ebtk(password, false, config.key, config.iv);
    return createDecipheriv(suite, keys.key, keys.iv);
  };
  /** @type {function(!Object, number, !Object): ?} */
  crypto.createDecipheriv = createDecipheriv;
}, function(canCreateDiscussions, modes) {
  modes["des-ecb"] = {
    key : 8,
    iv : 0
  };
  modes["des-cbc"] = modes.des = {
    key : 8,
    iv : 8
  };
  modes["des-ede3-cbc"] = modes.des3 = {
    key : 24,
    iv : 8
  };
  modes["des-ede3"] = {
    key : 24,
    iv : 0
  };
  modes["des-ede-cbc"] = {
    key : 16,
    iv : 8
  };
  modes["des-ede"] = {
    key : 16,
    iv : 0
  };
}, function(canCreateDiscussions, crypto, require) {
  (function(Buffer) {
    var formatter = require(86);
    var primes = require(156);
    var Error = require(157);
    var ENCODINGS = {
      binary : true,
      hex : true,
      base64 : true
    };
    /** @type {function(?): ?} */
    crypto.DiffieHellmanGroup = crypto.createDiffieHellmanGroup = crypto.getDiffieHellman = function(mod) {
      var bitsBuff = new Buffer(primes[mod].prime, "hex");
      var key = new Buffer(primes[mod].gen, "hex");
      return new Error(bitsBuff, key);
    };
    /** @type {function(string, !Object, !Object, !Object): ?} */
    crypto.createDiffieHellman = crypto.DiffieHellman = function write(val, enc, data, encoding) {
      return Buffer.isBuffer(enc) || void 0 === ENCODINGS[enc] ? write(val, "binary", enc, data) : (enc = enc || "binary", encoding = encoding || "binary", data = data || new Buffer([2]), Buffer.isBuffer(data) || (data = new Buffer(data, encoding)), "number" === typeof val ? new Error(formatter(val, data), data, true) : (Buffer.isBuffer(val) || (val = new Buffer(val, enc)), new Error(val, data, true)));
    };
  }).call(this, require(3).Buffer);
}, , , function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"modp1":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},"modp2":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},"modp5":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},"modp14":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},"modp15":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},"modp16":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},"modp17":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},"modp18":{"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}}');
}, function(module, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {!Object} pub
     * @param {string} enc
     * @return {?}
     */
    function setPublicKey(pub, enc) {
      return enc = enc || "utf8", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this._pub = new BN(pub), this;
    }
    /**
     * @param {!Object} data
     * @param {string} encoding
     * @return {?}
     */
    function setPrivateKey(data, encoding) {
      return encoding = encoding || "utf8", Buffer.isBuffer(data) || (data = new Buffer(data, encoding)), this._priv = new BN(data), this;
    }
    /**
     * @param {string} key
     * @param {string} value
     * @param {string} generator
     * @return {undefined}
     */
    function DH(key, value, generator) {
      this.setGenerator(value);
      this.__prime = new BN(key);
      this._prime = BN.mont(this.__prime);
      this._primeLen = key.length;
      this._pub = void 0;
      this._priv = void 0;
      this._primeCode = void 0;
      if (generator) {
        /** @type {function(!Object, string): ?} */
        this.setPublicKey = setPublicKey;
        /** @type {function(!Object, string): ?} */
        this.setPrivateKey = setPrivateKey;
      } else {
        /** @type {number} */
        this._primeCode = 8;
      }
    }
    /**
     * @param {?} bn
     * @param {number} enc
     * @return {?}
     */
    function formatReturnValue(bn, enc) {
      var sig = new Buffer(bn.toArray());
      return enc ? sig.toString(enc) : sig;
    }
    var BN = require(4);
    var FLOATABLE = new (require(88));
    var e = new BN(24);
    var r = new BN(11);
    var base = new BN(10);
    var c = new BN(3);
    var d = new BN(7);
    var primes = require(86);
    var randomBytes = require(16);
    /** @type {function(string, string, string): undefined} */
    module.exports = DH;
    var costs = {};
    Object.defineProperty(DH.prototype, "verifyError", {
      enumerable : true,
      get : function() {
        return "number" !== typeof this._primeCode && (this._primeCode = function(num, infoHashBuffer) {
          var bits = infoHashBuffer.toString("hex");
          /** @type {string} */
          var n = [bits, num.toString(16)].join("_");
          if (n in costs) {
            return costs[n];
          }
          var res;
          /** @type {number} */
          var newCost = 0;
          if (num.isEven() || !primes.simpleSieve || !primes.fermatTest(num) || !FLOATABLE.test(num)) {
            return newCost = newCost + 1, newCost = newCost + ("02" === bits || "05" === bits ? 8 : 4), costs[n] = newCost, newCost;
          }
          switch(FLOATABLE.test(num.shrn(1)) || (newCost = newCost + 2), bits) {
            case "02":
              if (num.mod(e).cmp(r)) {
                /** @type {number} */
                newCost = newCost + 8;
              }
              break;
            case "05":
              if ((res = num.mod(base)).cmp(c) && res.cmp(d)) {
                /** @type {number} */
                newCost = newCost + 8;
              }
              break;
            default:
              /** @type {number} */
              newCost = newCost + 4;
          }
          return costs[n] = newCost, newCost;
        }(this.__prime, this.__gen)), this._primeCode;
      }
    });
    /**
     * @return {?}
     */
    DH.prototype.generateKeys = function() {
      return this._priv || (this._priv = new BN(randomBytes(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
    };
    /**
     * @param {?} other
     * @return {?}
     */
    DH.prototype.computeSecret = function(other) {
      var resultsSubject = (other = (other = new BN(other)).toRed(this._prime)).redPow(this._priv).fromRed();
      var out = new Buffer(resultsSubject.toArray());
      var prime = this.getPrime();
      if (out.length < prime.length) {
        var zBuffer = new Buffer(prime.length - out.length);
        zBuffer.fill(0);
        out = Buffer.concat([zBuffer, out]);
      }
      return out;
    };
    /**
     * @param {number} enc
     * @return {?}
     */
    DH.prototype.getPublicKey = function(enc) {
      return formatReturnValue(this._pub, enc);
    };
    /**
     * @param {undefined} enc
     * @return {?}
     */
    DH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this._priv, enc);
    };
    /**
     * @param {undefined} enc
     * @return {?}
     */
    DH.prototype.getPrime = function(enc) {
      return formatReturnValue(this.__prime, enc);
    };
    /**
     * @param {undefined} enc
     * @return {?}
     */
    DH.prototype.getGenerator = function(enc) {
      return formatReturnValue(this._gen, enc);
    };
    /**
     * @param {string} gen
     * @param {string} enc
     * @return {?}
     */
    DH.prototype.setGenerator = function(gen, enc) {
      return enc = enc || "utf8", Buffer.isBuffer(gen) || (gen = new Buffer(gen, enc)), this.__gen = gen, this._gen = new BN(gen), this;
    };
  }).call(this, require(3).Buffer);
}, function(mixin, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {?} algorithm
     * @return {undefined}
     */
    function Sign(algorithm) {
      stream.Writable.call(this);
      var data = args[algorithm];
      if (!data) {
        throw new Error("Unknown message digest");
      }
      this._hashType = data.hash;
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    /**
     * @param {?} algorithm
     * @return {undefined}
     */
    function Verify(algorithm) {
      stream.Writable.call(this);
      var data = args[algorithm];
      if (!data) {
        throw new Error("Unknown message digest");
      }
      this._hash = createHash(data.hash);
      this._tag = data.id;
      this._signType = data.sign;
    }
    /**
     * @param {string} algorithm
     * @return {?}
     */
    function createSign(algorithm) {
      return new Sign(algorithm);
    }
    /**
     * @param {?} algorithm
     * @return {?}
     */
    function createVerify(algorithm) {
      return new Verify(algorithm);
    }
    var createHash = require(19);
    var stream = require(38);
    var inherits = require(1);
    var sign = require(159);
    var verify = require(191);
    var args = require(74);
    Object.keys(args).forEach(function(i) {
      args[i].id = new Buffer(args[i].id, "hex");
      args[i.toLowerCase()] = args[i];
    });
    inherits(Sign, stream.Writable);
    /**
     * @param {!Object} data
     * @param {!Object} value
     * @param {number} callback
     * @return {undefined}
     */
    Sign.prototype._write = function(data, value, callback) {
      this._hash.update(data);
      callback();
    };
    /**
     * @param {?} data
     * @param {!Object} opts
     * @return {?}
     */
    Sign.prototype.update = function(data, opts) {
      return "string" === typeof data && (data = new Buffer(data, opts)), this._hash.update(data), this;
    };
    /**
     * @param {!Object} key
     * @param {?} enc
     * @return {?}
     */
    Sign.prototype.sign = function(key, enc) {
      this.end();
      var method = this._hash.digest();
      var sig = sign(method, key, this._hashType, this._signType, this._tag);
      return enc ? sig.toString(enc) : sig;
    };
    inherits(Verify, stream.Writable);
    /**
     * @param {!Object} data
     * @param {!Object} value
     * @param {number} callback
     * @return {undefined}
     */
    Verify.prototype._write = function(data, value, callback) {
      this._hash.update(data);
      callback();
    };
    /**
     * @param {?} data
     * @param {!Object} opts
     * @return {?}
     */
    Verify.prototype.update = function(data, opts) {
      return "string" === typeof data && (data = new Buffer(data, opts)), this._hash.update(data), this;
    };
    /**
     * @param {number} message
     * @param {string} data
     * @param {(!Function|RegExp|string)} enc
     * @return {?}
     */
    Verify.prototype.verify = function(message, data, enc) {
      if ("string" === typeof data) {
        data = new Buffer(data, enc);
      }
      this.end();
      var verificationStatusId = this._hash.digest();
      return verify(data, verificationStatusId, message, this._signType, this._tag);
    };
    mixin.exports = {
      Sign : createSign,
      Verify : createVerify,
      createSign : createSign,
      createVerify : createVerify
    };
  }).call(this, require(3).Buffer);
}, function(component, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {!Array} x
     * @param {!Object} r
     * @param {!Array} hash
     * @param {string} data
     * @return {?}
     */
    function render(x, r, hash, data) {
      if ((x = new Buffer(x.toArray())).length < r.byteLength()) {
        var zBuffer = new Buffer(r.byteLength() - x.length);
        zBuffer.fill(0);
        x = Buffer.concat([zBuffer, x]);
      }
      var hlen = hash.length;
      var str = function(bits, q) {
        bits = (bits = bits2int(bits, q)).mod(q);
        var temp = new Buffer(bits.toArray());
        if (temp.length < q.byteLength()) {
          var zBuffer = new Buffer(q.byteLength() - temp.length);
          zBuffer.fill(0);
          temp = Buffer.concat([zBuffer, temp]);
        }
        return temp;
      }(hash, r);
      var v = new Buffer(hlen);
      v.fill(1);
      var k = new Buffer(hlen);
      return k.fill(0), k = createHmac(data, k).update(v).update(new Buffer([0])).update(x).update(str).digest(), v = createHmac(data, k).update(v).digest(), {
        k : k = createHmac(data, k).update(v).update(new Buffer([1])).update(x).update(str).digest(),
        v : v = createHmac(data, k).update(v).digest()
      };
    }
    /**
     * @param {!Array} obits
     * @param {!Object} q
     * @return {?}
     */
    function bits2int(obits, q) {
      var out = new BN(obits);
      /** @type {number} */
      var bits = (obits.length << 3) - q.bitLength();
      return bits > 0 && out.ishrn(bits), out;
    }
    /**
     * @param {!Object} q
     * @param {!Object} kv
     * @param {string} algo
     * @return {?}
     */
    function makeKey(q, kv, algo) {
      var t;
      var k;
      do {
        t = new Buffer(0);
        for (; 8 * t.length < q.bitLength();) {
          kv.v = createHmac(algo, kv.k).update(kv.v).digest();
          t = Buffer.concat([t, kv.v]);
        }
        k = bits2int(t, q);
        kv.k = createHmac(algo, kv.k).update(kv.v).update(new Buffer([0])).digest();
        kv.v = createHmac(algo, kv.k).update(kv.v).digest();
      } while (-1 !== k.cmp(q));
      return k;
    }
    /**
     * @param {?} g
     * @param {string} k
     * @param {string} p
     * @param {undefined} q
     * @return {?}
     */
    function makeR(g, k, p, q) {
      return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
    }
    var createHmac = require(72);
    var callback = require(49);
    var EC = require(50).ec;
    var BN = require(4);
    var parseKeys = require(34);
    var curves = require(98);
    /**
     * @param {string} key
     * @param {string} tree
     * @param {string} data
     * @param {undefined} value
     * @param {?} feedingNodesBlock
     * @return {?}
     */
    component.exports = function(key, tree, data, value, feedingNodesBlock) {
      var priv = parseKeys(tree);
      if (priv.curve) {
        if ("ecdsa" !== value && "ecdsa/rsa" !== value) {
          throw new Error("wrong private key type");
        }
        return function(level, key) {
          var curveName = curves[key.curve.join(".")];
          if (!curveName) {
            throw new Error("unknown curve " + key.curve.join("."));
          }
          var adjustedLevel = (new EC(curveName)).keyFromPrivate(key.privateKey).sign(level);
          return new Buffer(adjustedLevel.toDER());
        }(key, priv);
      }
      if ("dsa" === priv.type) {
        if ("dsa" !== value) {
          throw new Error("wrong private key type");
        }
        return function(hash, priv, algo) {
          var k;
          var x = priv.params.priv_key;
          var p = priv.params.p;
          var q = priv.params.q;
          var g = priv.params.g;
          var r = new BN(0);
          var H = bits2int(hash, q).mod(q);
          /** @type {boolean} */
          var phi = false;
          var kv = render(x, q, hash, algo);
          for (; false === phi;) {
            k = makeKey(q, kv, algo);
            r = makeR(g, k, p, q);
            if (0 === (phi = k.invm(q).imul(H.add(x.mul(r))).mod(q)).cmpn(0)) {
              /** @type {boolean} */
              phi = false;
              r = new BN(0);
            }
          }
          return function(data, options) {
            data = data.toArray();
            options = options.toArray();
            if (128 & data[0]) {
              /** @type {!Array<?>} */
              data = [0].concat(data);
            }
            if (128 & options[0]) {
              /** @type {!Array<?>} */
              options = [0].concat(options);
            }
            /** @type {!Array} */
            var n = [48, data.length + options.length + 4, 2, data.length];
            return n = n.concat(data, [2, options.length], options), new Buffer(n);
          }(r, phi);
        }(key, priv, data);
      }
      if ("rsa" !== value && "ecdsa/rsa" !== value) {
        throw new Error("wrong private key type");
      }
      key = Buffer.concat([feedingNodesBlock, key]);
      var m = priv.modulus.byteLength();
      /** @type {!Array} */
      var storage = [0, 1];
      for (; key.length + storage.length + 1 < m;) {
        storage.push(255);
      }
      storage.push(0);
      /** @type {number} */
      var j = -1;
      for (; ++j < key.length;) {
        storage.push(key[j]);
      }
      return callback(storage, priv);
    };
    /** @type {function(!Array, !Object, !Array, string): ?} */
    component.exports.getKey = render;
    /** @type {function(!Object, !Object, string): ?} */
    component.exports.makeKey = makeKey;
  }).call(this, require(3).Buffer);
}, function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"name":"elliptic","version":"6.5.2","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"jscs":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","jshint":"jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js","lint":"npm run jscs && npm run jshint","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^1.4.3","coveralls":"^3.0.8","grunt":"^1.0.4","grunt-browserify":"^5.0.0","grunt-cli":"^1.2.0","grunt-contrib-connect":"^1.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^1.0.1","grunt-mocha-istanbul":"^3.0.1","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.2","jscs":"^3.0.7","jshint":"^2.10.3","mocha":"^6.2.2"},"dependencies":{"bn.js":"^4.4.0","brorand":"^1.0.1","hash.js":"^1.0.0","hmac-drbg":"^1.0.0","inherits":"^2.0.1","minimalistic-assert":"^1.0.0","minimalistic-crypto-utils":"^1.0.0"}}');
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} value
   * @return {undefined}
   */
  function update(value) {
    code.call(this, "short", value);
    this.a = (new Date(value.a, 16)).toRed(this.red);
    this.b = (new Date(value.b, 16)).toRed(this.red);
    this.tinv = this.two.redInvm();
    /** @type {boolean} */
    this.zeroA = 0 === this.a.fromRed().cmpn(0);
    /** @type {boolean} */
    this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3);
    this.endo = this._getEndomorphism(value);
    /** @type {!Array} */
    this._endoWnafT1 = new Array(4);
    /** @type {!Array} */
    this._endoWnafT2 = new Array(4);
  }
  /**
   * @param {?} name
   * @param {number} val
   * @param {number} desc
   * @param {?} index
   * @return {undefined}
   */
  function self(name, val, desc, index) {
    code.BasePoint.call(this, name, "affine");
    if (null === val && null === desc) {
      /** @type {null} */
      this.x = null;
      /** @type {null} */
      this.y = null;
      /** @type {boolean} */
      this.inf = true;
    } else {
      this.x = new Date(val, 16);
      this.y = new Date(desc, 16);
      if (index) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red) {
        this.x = this.x.toRed(this.curve.red);
      }
      if (!this.y.red) {
        this.y = this.y.toRed(this.curve.red);
      }
      /** @type {boolean} */
      this.inf = false;
    }
  }
  /**
   * @param {?} message
   * @param {number} input
   * @param {number} x
   * @param {number} y
   * @return {undefined}
   */
  function Point(message, input, x, y) {
    code.BasePoint.call(this, message, "jacobian");
    if (null === input && null === x && null === y) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new Date(0);
    } else {
      this.x = new Date(input, 16);
      this.y = new Date(x, 16);
      this.z = new Date(y, 16);
    }
    if (!this.x.red) {
      this.x = this.x.toRed(this.curve.red);
    }
    if (!this.y.red) {
      this.y = this.y.toRed(this.curve.red);
    }
    if (!this.z.red) {
      this.z = this.z.toRed(this.curve.red);
    }
    /** @type {boolean} */
    this.zOne = this.z === this.curve.one;
  }
  var chai = require(7);
  var Date = require(4);
  var callback = require(1);
  var code = require(33);
  var assert = chai.assert;
  callback(update, code);
  /** @type {function(string): undefined} */
  module.exports = update;
  /**
   * @param {!Object} options
   * @return {?}
   */
  update.prototype._getEndomorphism = function(options) {
    if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
      var b;
      var e;
      if (options.beta) {
        b = (new Date(options.beta, 16)).toRed(this.red);
      } else {
        var d = this._getEndoRoots(this.p);
        b = (b = d[0].cmp(d[1]) < 0 ? d[0] : d[1]).toRed(this.red);
      }
      if (options.lambda) {
        e = new Date(options.lambda, 16);
      } else {
        var p1 = this._getEndoRoots(this.n);
        if (0 === this.g.mul(p1[0]).x.cmp(this.g.x.redMul(b))) {
          e = p1[0];
        } else {
          e = p1[1];
          assert(0 === this.g.mul(e).x.cmp(this.g.x.redMul(b)));
        }
      }
      return {
        beta : b,
        lambda : e,
        basis : options.basis ? options.basis.map(function(e) {
          return {
            a : new Date(e.a, 16),
            b : new Date(e.b, 16)
          };
        }) : this._getEndoBasis(e)
      };
    }
  };
  /**
   * @param {undefined} value
   * @return {?}
   */
  update.prototype._getEndoRoots = function(value) {
    var newOperators = value === this.p ? this.red : Date.mont(value);
    var one = (new Date(2)).toRed(newOperators).redInvm();
    var oneDayInTheFirstWeek = one.redNeg();
    var D = (new Date(3)).toRed(newOperators).redNeg().redSqrt().redMul(one);
    return [oneDayInTheFirstWeek.redAdd(D).fromRed(), oneDayInTheFirstWeek.redSub(D).fromRed()];
  };
  /**
   * @param {!Object} images
   * @return {?}
   */
  update.prototype._getEndoBasis = function(images) {
    var jsons;
    var content;
    var d;
    var e;
    var _jsons;
    var _content;
    var result;
    var ret;
    var value;
    var r = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    /** @type {!Object} */
    var p = images;
    var h = this.n.clone();
    var c = new Date(1);
    var b = new Date(0);
    var s = new Date(0);
    var t = new Date(1);
    /** @type {number} */
    var v = 0;
    for (; 0 !== p.cmpn(0);) {
      var seq = h.div(p);
      ret = h.sub(seq.mul(p));
      value = s.sub(seq.mul(c));
      var vfrac = t.sub(seq.mul(b));
      if (!d && ret.cmp(r) < 0) {
        jsons = result.neg();
        content = c;
        d = ret.neg();
        e = value;
      } else {
        if (d && 2 === ++v) {
          break;
        }
      }
      result = ret;
      h = p;
      p = ret;
      s = c;
      c = value;
      t = b;
      b = vfrac;
    }
    _jsons = ret.neg();
    _content = value;
    var nOne = d.sqr().add(e.sqr());
    return _jsons.sqr().add(_content.sqr()).cmp(nOne) >= 0 && (_jsons = jsons, _content = content), d.negative && (d = d.neg(), e = e.neg()), _jsons.negative && (_jsons = _jsons.neg(), _content = _content.neg()), [{
      a : d,
      b : e
    }, {
      a : _jsons,
      b : _content
    }];
  };
  /**
   * @param {!Array} d
   * @return {?}
   */
  update.prototype._endoSplit = function(d) {
    var state = this.endo.basis;
    var res = state[0];
    var self = state[1];
    var _ = self.b.mul(d).divRound(this.n);
    var math = res.b.neg().mul(d).divRound(this.n);
    var t = _.mul(res.a);
    var trg = math.mul(self.a);
    var vLinks = _.mul(res.b);
    var j = math.mul(self.b);
    return {
      k1 : d.sub(t).sub(trg),
      k2 : vLinks.add(j).neg()
    };
  };
  /**
   * @param {!Object} x
   * @param {number} throwNotFound
   * @return {?}
   */
  update.prototype.pointFromX = function(x, throwNotFound) {
    if (!(x = new Date(x, 16)).red) {
      x = x.toRed(this.red);
    }
    var n = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = n.redSqrt();
    if (0 !== y.redSqr().redSub(n).cmp(this.zero)) {
      throw new Error("invalid point");
    }
    var hasProperty = y.fromRed().isOdd();
    return (throwNotFound && !hasProperty || !throwNotFound && hasProperty) && (y = y.redNeg()), this.point(x, y);
  };
  /**
   * @param {!Object} point
   * @return {?}
   */
  update.prototype.validate = function(point) {
    if (point.inf) {
      return true;
    }
    var x = point.x;
    var y = point.y;
    var nOne = this.a.redMul(x);
    var b = x.redSqr().redMul(x).redIAdd(nOne).redIAdd(this.b);
    return 0 === y.redSqr().redISub(b).cmpn(0);
  };
  /**
   * @param {!Array} value
   * @param {!Array} name
   * @param {boolean} timeout
   * @return {?}
   */
  update.prototype._endoWnafMulAdd = function(value, name, timeout) {
    var vertices = this._endoWnafT1;
    var data = this._endoWnafT2;
    /** @type {number} */
    var k = 0;
    for (; k < value.length; k++) {
      var params = this._endoSplit(name[k]);
      var l = value[k];
      var uStart = l._getBeta();
      if (params.k1.negative) {
        params.k1.ineg();
        l = l.neg(true);
      }
      if (params.k2.negative) {
        params.k2.ineg();
        uStart = uStart.neg(true);
      }
      vertices[2 * k] = l;
      vertices[2 * k + 1] = uStart;
      data[2 * k] = params.k1;
      data[2 * k + 1] = params.k2;
    }
    var result2 = this._wnafMulAdd(1, vertices, data, 2 * k, timeout);
    /** @type {number} */
    var c = 0;
    for (; c < 2 * k; c++) {
      /** @type {null} */
      vertices[c] = null;
      /** @type {null} */
      data[c] = null;
    }
    return result2;
  };
  callback(self, code.BasePoint);
  /**
   * @param {!Object} options
   * @param {!Object} array
   * @param {!Object} val
   * @return {?}
   */
  update.prototype.point = function(options, array, val) {
    return new self(this, options, array, val);
  };
  /**
   * @param {undefined} json
   * @param {!Object} target
   * @return {?}
   */
  update.prototype.pointFromJSON = function(json, target) {
    return self.fromJSON(this, json, target);
  };
  /**
   * @return {?}
   */
  self.prototype._getBeta = function() {
    if (this.curve.endo) {
      var options = this.precomputed;
      if (options && options.beta) {
        return options.beta;
      }
      var p = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (options) {
        var event = this.curve;
        /**
         * @param {!Object} options
         * @return {?}
         */
        var data = function(options) {
          return event.point(options.x.redMul(event.endo.beta), options.y);
        };
        options.beta = p;
        p.precomputed = {
          beta : null,
          naf : options.naf && {
            wnd : options.naf.wnd,
            points : options.naf.points.map(data)
          },
          doubles : options.doubles && {
            step : options.doubles.step,
            points : options.doubles.points.map(data)
          }
        };
      }
      return p;
    }
  };
  /**
   * @return {?}
   */
  self.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles : this.precomputed.doubles && {
        step : this.precomputed.doubles.step,
        points : this.precomputed.doubles.points.slice(1)
      },
      naf : this.precomputed.naf && {
        wnd : this.precomputed.naf.wnd,
        points : this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  };
  /**
   * @param {!Object} path
   * @param {string} options
   * @param {!Object} val
   * @return {?}
   */
  self.fromJSON = function(path, options, val) {
    /**
     * @param {!Object} to
     * @return {?}
     */
    function parameters(to) {
      return path.point(to[0], to[1], val);
    }
    if ("string" === typeof options) {
      /** @type {*} */
      options = JSON.parse(options);
    }
    var op = path.point(options[0], options[1], val);
    if (!options[2]) {
      return op;
    }
    var $scope = options[2];
    return op.precomputed = {
      beta : null,
      doubles : $scope.doubles && {
        step : $scope.doubles.step,
        points : [op].concat($scope.doubles.points.map(parameters))
      },
      naf : $scope.naf && {
        wnd : $scope.naf.wnd,
        points : [op].concat($scope.naf.points.map(parameters))
      }
    }, op;
  };
  /**
   * @return {?}
   */
  self.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  /**
   * @return {?}
   */
  self.prototype.isInfinity = function() {
    return this.inf;
  };
  /**
   * @param {!Object} a
   * @return {?}
   */
  self.prototype.add = function(a) {
    if (this.inf) {
      return a;
    }
    if (a.inf) {
      return this;
    }
    if (this.eq(a)) {
      return this.dbl();
    }
    if (this.neg().eq(a)) {
      return this.curve.point(null, null);
    }
    if (0 === this.x.cmp(a.x)) {
      return this.curve.point(null, null);
    }
    var b = this.y.redSub(a.y);
    if (0 !== b.cmpn(0)) {
      b = b.redMul(this.x.redSub(a.x).redInvm());
    }
    var x = b.redSqr().redISub(this.x).redISub(a.x);
    var y = b.redMul(this.x.redSub(x)).redISub(this.y);
    return this.curve.point(x, y);
  };
  /**
   * @return {?}
   */
  self.prototype.dbl = function() {
    if (this.inf) {
      return this;
    }
    var target = this.y.redAdd(this.y);
    if (0 === target.cmpn(0)) {
      return this.curve.point(null, null);
    }
    var aB = this.curve.a;
    var x = this.x.redSqr();
    var b = target.redInvm();
    var t = x.redAdd(x).redIAdd(x).redIAdd(aB).redMul(b);
    var n = t.redSqr().redISub(this.x.redAdd(this.x));
    var y = t.redMul(this.x.redSub(n)).redISub(this.y);
    return this.curve.point(n, y);
  };
  /**
   * @return {?}
   */
  self.prototype.getX = function() {
    return this.x.fromRed();
  };
  /**
   * @return {?}
   */
  self.prototype.getY = function() {
    return this.y.fromRed();
  };
  /**
   * @param {number} value
   * @return {?}
   */
  self.prototype.mul = function(value) {
    return value = new Date(value, 16), this.isInfinity() ? this : this._hasDoubles(value) ? this.curve._fixedNafMul(this, value) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [value]) : this.curve._wnafMul(this, value);
  };
  /**
   * @param {?} point
   * @param {?} res
   * @param {?} str
   * @return {?}
   */
  self.prototype.mulAdd = function(point, res, str) {
    /** @type {!Array} */
    var r = [this, res];
    /** @type {!Array} */
    var allTypes = [point, str];
    return this.curve.endo ? this.curve._endoWnafMulAdd(r, allTypes) : this.curve._wnafMulAdd(1, r, allTypes, 2);
  };
  /**
   * @param {?} to
   * @param {?} state
   * @param {?} result
   * @return {?}
   */
  self.prototype.jmulAdd = function(to, state, result) {
    /** @type {!Array} */
    var r = [this, state];
    /** @type {!Array} */
    var value = [to, result];
    return this.curve.endo ? this.curve._endoWnafMulAdd(r, value, true) : this.curve._wnafMulAdd(1, r, value, 2, true);
  };
  /**
   * @param {!Object} obj
   * @return {?}
   */
  self.prototype.eq = function(obj) {
    return this === obj || this.inf === obj.inf && (this.inf || 0 === this.x.cmp(obj.x) && 0 === this.y.cmp(obj.y));
  };
  /**
   * @param {string} a
   * @return {?}
   */
  self.prototype.neg = function(a) {
    if (this.inf) {
      return this;
    }
    var p = this.curve.point(this.x, this.y.redNeg());
    if (a && this.precomputed) {
      var $scope = this.precomputed;
      /**
       * @param {?} n
       * @return {?}
       */
      var data = function(n) {
        return n.neg();
      };
      p.precomputed = {
        naf : $scope.naf && {
          wnd : $scope.naf.wnd,
          points : $scope.naf.points.map(data)
        },
        doubles : $scope.doubles && {
          step : $scope.doubles.step,
          points : $scope.doubles.points.map(data)
        }
      };
    }
    return p;
  };
  /**
   * @return {?}
   */
  self.prototype.toJ = function() {
    return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
  };
  callback(Point, code.BasePoint);
  /**
   * @param {!Object} d
   * @param {!Object} x
   * @param {!Object} y
   * @return {?}
   */
  update.prototype.jpoint = function(d, x, y) {
    return new Point(this, d, x, y);
  };
  /**
   * @return {?}
   */
  Point.prototype.toP = function() {
    if (this.isInfinity()) {
      return this.curve.point(null, null);
    }
    var b = this.z.redInvm();
    var precision = b.redSqr();
    var n = this.x.redMul(precision);
    var y = this.y.redMul(precision).redMul(b);
    return this.curve.point(n, y);
  };
  /**
   * @return {?}
   */
  Point.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  /**
   * @param {!Object} p
   * @return {?}
   */
  Point.prototype.add = function(p) {
    if (this.isInfinity()) {
      return p;
    }
    if (p.isInfinity()) {
      return this;
    }
    var n = p.z.redSqr();
    var z2 = this.z.redSqr();
    var t = this.x.redMul(n);
    var z = p.x.redMul(z2);
    var app = this.y.redMul(n.redMul(p.z));
    var users = p.y.redMul(z2.redMul(this.z));
    var b = t.redSub(z);
    var r = app.redSub(users);
    if (0 === b.cmpn(0)) {
      return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
    }
    var j = b.redSqr();
    var c = j.redMul(b);
    var data = t.redMul(j);
    var label = r.redSqr().redIAdd(c).redISub(data).redISub(data);
    var HIGHWAY_EASEMENT = r.redMul(data.redISub(label)).redISub(app.redMul(c));
    var $B = this.z.redMul(p.z).redMul(b);
    return this.curve.jpoint(label, HIGHWAY_EASEMENT, $B);
  };
  /**
   * @param {!Object} p
   * @return {?}
   */
  Point.prototype.mixedAdd = function(p) {
    if (this.isInfinity()) {
      return p.toJ();
    }
    if (p.isInfinity()) {
      return this;
    }
    var formArgs = this.z.redSqr();
    var u = this.x;
    var n = p.x.redMul(formArgs);
    var v = this.y;
    var res = p.y.redMul(formArgs).redMul(this.z);
    var b = u.redSub(n);
    var r = v.redSub(res);
    if (0 === b.cmpn(0)) {
      return 0 !== r.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
    }
    var c = b.redSqr();
    var name = c.redMul(b);
    var data = u.redMul(c);
    var t = r.redSqr().redIAdd(name).redISub(data).redISub(data);
    var HIGHWAY_EASEMENT = r.redMul(data.redISub(t)).redISub(v.redMul(name));
    var h = this.z.redMul(b);
    return this.curve.jpoint(t, HIGHWAY_EASEMENT, h);
  };
  /**
   * @param {number} k
   * @return {?}
   */
  Point.prototype.dblp = function(k) {
    if (0 === k) {
      return this;
    }
    if (this.isInfinity()) {
      return this;
    }
    if (!k) {
      return this.dbl();
    }
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      /** @type {number} */
      var leftSums = 0;
      for (; leftSums < k; leftSums++) {
        r = r.dbl();
      }
      return r;
    }
    var sigr = this.curve.a;
    var b = this.curve.tinv;
    var r = this.x;
    var v2 = this.y;
    var z = this.z;
    var z2 = z.redSqr().redSqr();
    var a = v2.redAdd(v2);
    /** @type {number} */
    leftSums = 0;
    for (; leftSums < k; leftSums++) {
      var x = r.redSqr();
      var b = a.redSqr();
      var mid = b.redSqr();
      var t = x.redAdd(x).redIAdd(x).redIAdd(sigr.redMul(z2));
      var p = r.redMul(b);
      var q = t.redSqr().redISub(p.redAdd(p));
      var c = p.redISub(q);
      var right = t.redMul(c);
      right = right.redIAdd(right).redISub(mid);
      var d = a.redMul(z);
      if (leftSums + 1 < k) {
        z2 = z2.redMul(mid);
      }
      r = q;
      z = d;
      a = right;
    }
    return this.curve.jpoint(r, a.redMul(b), z);
  };
  /**
   * @return {?}
   */
  Point.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  };
  /**
   * @return {?}
   */
  Point.prototype._zeroDbl = function() {
    var r;
    var i;
    var y;
    if (this.zOne) {
      var x = this.x.redSqr();
      var newScale = this.y.redSqr();
      var g = newScale.redSqr();
      var z = this.x.redAdd(newScale).redSqr().redISub(x).redISub(g);
      z = z.redIAdd(z);
      var b = x.redAdd(x).redIAdd(x);
      var f = b.redSqr().redISub(z).redISub(z);
      var h = g.redIAdd(g);
      h = (h = h.redIAdd(h)).redIAdd(h);
      r = f;
      i = b.redMul(z.redISub(f)).redISub(h);
      y = this.y.redAdd(this.y);
    } else {
      var x = this.x.redSqr();
      var newScale = this.y.redSqr();
      var z = newScale.redSqr();
      var d = this.x.redAdd(newScale).redSqr().redISub(x).redISub(z);
      d = d.redIAdd(d);
      var b = x.redAdd(x).redIAdd(x);
      var other_list = b.redSqr();
      var m = z.redIAdd(z);
      m = (m = m.redIAdd(m)).redIAdd(m);
      r = other_list.redISub(d).redISub(d);
      i = b.redMul(d.redISub(r)).redISub(m);
      y = (y = this.y.redMul(this.z)).redIAdd(y);
    }
    return this.curve.jpoint(r, i, y);
  };
  /**
   * @return {?}
   */
  Point.prototype._threeDbl = function() {
    var a;
    var r;
    var y;
    if (this.zOne) {
      var x = this.x.redSqr();
      var newScale = this.y.redSqr();
      var t = newScale.redSqr();
      var z = this.x.redAdd(newScale).redSqr().redISub(x).redISub(t);
      z = z.redIAdd(z);
      var b = x.redAdd(x).redIAdd(x).redIAdd(this.curve.a);
      var f = b.redSqr().redISub(z).redISub(z);
      a = f;
      var g = t.redIAdd(t);
      g = (g = g.redIAdd(g)).redIAdd(g);
      r = b.redMul(z.redISub(f)).redISub(g);
      y = this.y.redAdd(this.y);
    } else {
      var n = this.z.redSqr();
      var b = this.y.redSqr();
      var m = this.x.redMul(b);
      var x = this.x.redSub(n).redMul(this.x.redAdd(n));
      x = x.redAdd(x).redIAdd(x);
      var d = m.redIAdd(m);
      var value = (d = d.redIAdd(d)).redAdd(d);
      a = x.redSqr().redISub(value);
      y = this.y.redAdd(this.z).redSqr().redISub(b).redISub(n);
      var z = b.redSqr();
      z = (z = (z = z.redIAdd(z)).redIAdd(z)).redIAdd(z);
      r = x.redMul(d.redISub(a)).redISub(z);
    }
    return this.curve.jpoint(a, r, y);
  };
  /**
   * @return {?}
   */
  Point.prototype._dbl = function() {
    var t = this.curve.a;
    var x = this.x;
    var y = this.y;
    var b = this.z;
    var c = b.redSqr().redSqr();
    var nOne = x.redSqr();
    var prevResult = y.redSqr();
    var removedRelations = nOne.redAdd(nOne).redIAdd(nOne).redIAdd(t.redMul(c));
    var z = x.redAdd(x);
    var u = (z = z.redIAdd(z)).redMul(prevResult);
    var val = removedRelations.redSqr().redISub(u.redAdd(u));
    var length = u.redISub(val);
    var right = prevResult.redSqr();
    right = (right = (right = right.redIAdd(right)).redIAdd(right)).redIAdd(right);
    var r = removedRelations.redMul(length).redISub(right);
    var p = y.redAdd(y).redMul(b);
    return this.curve.jpoint(val, r, p);
  };
  /**
   * @return {?}
   */
  Point.prototype.trpl = function() {
    if (!this.curve.zeroA) {
      return this.dbl().add(this);
    }
    var n = this.x.redSqr();
    var x = this.y.redSqr();
    var incDays = this.z.redSqr();
    var zoom = x.redSqr();
    var b = n.redAdd(n).redIAdd(n);
    var start = b.redSqr();
    var z = this.x.redAdd(x).redSqr().redISub(n).redISub(zoom);
    var z2 = (z = (z = (z = z.redIAdd(z)).redAdd(z).redIAdd(z)).redISub(start)).redSqr();
    var s = zoom.redIAdd(zoom);
    s = (s = (s = s.redIAdd(s)).redIAdd(s)).redIAdd(s);
    var c = b.redIAdd(z).redSqr().redISub(start).redISub(z2).redISub(s);
    var w = x.redMul(c);
    w = (w = w.redIAdd(w)).redIAdd(w);
    var val = this.x.redMul(z2).redISub(w);
    val = (val = val.redIAdd(val)).redIAdd(val);
    var r = this.y.redMul(c.redMul(s.redISub(c)).redISub(z.redMul(z2)));
    r = (r = (r = r.redIAdd(r)).redIAdd(r)).redIAdd(r);
    var y2 = this.z.redAdd(z).redSqr().redISub(incDays).redISub(z2);
    return this.curve.jpoint(val, r, y2);
  };
  /**
   * @param {?} b
   * @param {!Object} a
   * @return {?}
   */
  Point.prototype.mul = function(b, a) {
    return b = new Date(b, a), this.curve._wnafMul(this, b);
  };
  /**
   * @param {!Object} options
   * @return {?}
   */
  Point.prototype.eq = function(options) {
    if ("affine" === options.type) {
      return this.eq(options.toJ());
    }
    if (this === options) {
      return true;
    }
    var b = this.z.redSqr();
    var t = options.z.redSqr();
    if (0 !== this.x.redMul(t).redISub(options.x.redMul(b)).cmpn(0)) {
      return false;
    }
    var xy = b.redMul(this.z);
    var newScale = t.redMul(options.z);
    return 0 === this.y.redMul(newScale).redISub(options.y.redMul(xy)).cmpn(0);
  };
  /**
   * @param {?} y
   * @return {?}
   */
  Point.prototype.eqXToP = function(y) {
    var b = this.z.redSqr();
    var x = y.toRed(this.curve.red).redMul(b);
    if (0 === this.x.cmp(x)) {
      return true;
    }
    var r = y.clone();
    var i = this.curve.redN.redMul(b);
    for (;;) {
      if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) {
        return false;
      }
      if (x.redIAdd(i), 0 === this.x.cmp(x)) {
        return true;
      }
    }
  };
  /**
   * @return {?}
   */
  Point.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  /**
   * @return {?}
   */
  Point.prototype.isInfinity = function() {
    return 0 === this.z.cmpn(0);
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function g(key) {
    data.call(this, "mont", key);
    this.a = (new Error(key.a, 16)).toRed(this.red);
    this.b = (new Error(key.b, 16)).toRed(this.red);
    this.i4 = (new Error(4)).toRed(this.red).redInvm();
    this.two = (new Error(2)).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  /**
   * @param {?} name
   * @param {number} val
   * @param {number} desc
   * @return {undefined}
   */
  function self(name, val, desc) {
    data.BasePoint.call(this, name, "projective");
    if (null === val && null === desc) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new Error(val, 16);
      this.z = new Error(desc, 16);
      if (!this.x.red) {
        this.x = this.x.toRed(this.curve.red);
      }
      if (!this.z.red) {
        this.z = this.z.toRed(this.curve.red);
      }
    }
  }
  var Error = require(4);
  var setSendConsoleError = require(1);
  var data = require(33);
  var utils = require(7);
  setSendConsoleError(g, data);
  /** @type {function(string): undefined} */
  module.exports = g;
  /**
   * @param {!Object} e
   * @return {?}
   */
  g.prototype.validate = function(e) {
    var b = e.normalize().x;
    var mathUtil = b.redSqr();
    var r = mathUtil.redMul(b).redAdd(mathUtil.redMul(this.a)).redAdd(b);
    return 0 === r.redSqrt().redSqr().cmp(r);
  };
  setSendConsoleError(self, data.BasePoint);
  /**
   * @param {boolean} bytes
   * @param {string} enc
   * @return {?}
   */
  g.prototype.decodePoint = function(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  /**
   * @param {!Object} options
   * @param {!Object} val
   * @return {?}
   */
  g.prototype.point = function(options, val) {
    return new self(this, options, val);
  };
  /**
   * @param {undefined} json
   * @return {?}
   */
  g.prototype.pointFromJSON = function(json) {
    return self.fromJSON(this, json);
  };
  /**
   * @return {undefined}
   */
  self.prototype.precompute = function() {
  };
  /**
   * @return {?}
   */
  self.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  /**
   * @param {!Object} obj
   * @param {!Object} data
   * @return {?}
   */
  self.fromJSON = function(obj, data) {
    return new self(obj, data[0], data[1] || obj.one);
  };
  /**
   * @return {?}
   */
  self.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  /**
   * @return {?}
   */
  self.prototype.isInfinity = function() {
    return 0 === this.z.cmpn(0);
  };
  /**
   * @return {?}
   */
  self.prototype.dbl = function() {
    var t = this.x.redAdd(this.z).redSqr();
    var b = this.x.redSub(this.z).redSqr();
    var r = t.redSub(b);
    var n = t.redMul(b);
    var height = r.redMul(b.redAdd(this.curve.a24.redMul(r)));
    return this.curve.point(n, height);
  };
  /**
   * @return {?}
   */
  self.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  /**
   * @param {!Object} t
   * @param {!Object} node
   * @return {?}
   */
  self.prototype.diffAdd = function(t, node) {
    var c = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var r = t.x.redAdd(t.z);
    var date = t.x.redSub(t.z).redMul(c);
    var incDays = r.redMul(b);
    var percent = node.z.redMul(date.redAdd(incDays).redSqr());
    var height = node.x.redMul(date.redISub(incDays).redSqr());
    return this.curve.point(percent, height);
  };
  /**
   * @param {?} str
   * @return {?}
   */
  self.prototype.mul = function(str) {
    var num = str.clone();
    var sureMsg = this;
    var r = this.curve.point(null, null);
    /** @type {!Array} */
    var d3MapTileLayer = [];
    for (; 0 !== num.cmpn(0); num.iushrn(1)) {
      d3MapTileLayer.push(num.andln(1));
    }
    /** @type {number} */
    var x = d3MapTileLayer.length - 1;
    for (; x >= 0; x--) {
      if (0 === d3MapTileLayer[x]) {
        sureMsg = sureMsg.diffAdd(r, this);
        r = r.dbl();
      } else {
        r = sureMsg.diffAdd(r, this);
        sureMsg = sureMsg.dbl();
      }
    }
    return r;
  };
  /**
   * @return {?}
   */
  self.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  /**
   * @return {?}
   */
  self.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  };
  /**
   * @param {!Object} options
   * @return {?}
   */
  self.prototype.eq = function(options) {
    return 0 === this.getX().cmp(options.getX());
  };
  /**
   * @return {?}
   */
  self.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  };
  /**
   * @return {?}
   */
  self.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @return {undefined}
   */
  function verify(key) {
    /** @type {boolean} */
    this.twisted = 1 !== (0 | key.a);
    /** @type {boolean} */
    this.mOneA = this.twisted && -1 === (0 | key.a);
    /** @type {boolean} */
    this.extended = this.mOneA;
    item.call(this, "edwards", key);
    this.a = (new Date(key.a, 16)).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = (new Date(key.c, 16)).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = (new Date(key.d, 16)).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || 0 === this.c.fromRed().cmpn(1));
    /** @type {boolean} */
    this.oneC = 1 === (0 | key.c);
  }
  /**
   * @param {?} name
   * @param {number} element
   * @param {number} str
   * @param {number} value
   * @param {string} current
   * @return {undefined}
   */
  function self(name, element, str, value, current) {
    item.BasePoint.call(this, name, "projective");
    if (null === element && null === str && null === value) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      /** @type {boolean} */
      this.zOne = true;
    } else {
      this.x = new Date(element, 16);
      this.y = new Date(str, 16);
      this.z = value ? new Date(value, 16) : this.curve.one;
      this.t = current && new Date(current, 16);
      if (!this.x.red) {
        this.x = this.x.toRed(this.curve.red);
      }
      if (!this.y.red) {
        this.y = this.y.toRed(this.curve.red);
      }
      if (!this.z.red) {
        this.z = this.z.toRed(this.curve.red);
      }
      if (this.t && !this.t.red) {
        this.t = this.t.toRed(this.curve.red);
      }
      /** @type {boolean} */
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne) {
          this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
  }
  var chai = require(7);
  var Date = require(4);
  var $ = require(1);
  var item = require(33);
  var assert = chai.assert;
  $(verify, item);
  /** @type {function(!Object): undefined} */
  module.exports = verify;
  /**
   * @param {!Object} obj
   * @return {?}
   */
  verify.prototype._mulA = function(obj) {
    return this.mOneA ? obj.redNeg() : this.a.redMul(obj);
  };
  /**
   * @param {!Navigator} c
   * @return {?}
   */
  verify.prototype._mulC = function(c) {
    return this.oneC ? c : this.c.redMul(c);
  };
  /**
   * @param {!Object} i
   * @param {!Object} y
   * @param {!Object} number
   * @param {!Object} howManyToRound
   * @return {?}
   */
  verify.prototype.jpoint = function(i, y, number, howManyToRound) {
    return this.point(i, y, number, howManyToRound);
  };
  /**
   * @param {!Object} x
   * @param {number} throwNotFound
   * @return {?}
   */
  verify.prototype.pointFromX = function(x, throwNotFound) {
    if (!(x = new Date(x, 16)).red) {
      x = x.toRed(this.red);
    }
    var dx = x.redSqr();
    var t = this.c2.redSub(this.a.redMul(dx));
    var o = this.one.redSub(this.c2.redMul(this.d).redMul(dx));
    var n = t.redMul(o.redInvm());
    var y = n.redSqrt();
    if (0 !== y.redSqr().redSub(n).cmp(this.zero)) {
      throw new Error("invalid point");
    }
    var hasProperty = y.fromRed().isOdd();
    return (throwNotFound && !hasProperty || !throwNotFound && hasProperty) && (y = y.redNeg()), this.point(x, y);
  };
  /**
   * @param {!Object} x
   * @param {boolean} miniBatchSize
   * @return {?}
   */
  verify.prototype.pointFromY = function(x, miniBatchSize) {
    if (!(x = new Date(x, 16)).red) {
      x = x.toRed(this.red);
    }
    var r = x.redSqr();
    var t = r.redSub(this.c2);
    var index = r.redMul(this.d).redMul(this.c2).redSub(this.a);
    var expected = t.redMul(index.redInvm());
    if (0 === expected.cmp(this.zero)) {
      if (miniBatchSize) {
        throw new Error("invalid point");
      }
      return this.point(this.zero, x);
    }
    var y = expected.redSqrt();
    if (0 !== y.redSqr().redSub(expected).cmp(this.zero)) {
      throw new Error("invalid point");
    }
    return y.fromRed().isOdd() !== miniBatchSize && (y = y.redNeg()), this.point(y, x);
  };
  /**
   * @param {!Object} point
   * @return {?}
   */
  verify.prototype.validate = function(point) {
    if (point.isInfinity()) {
      return true;
    }
    point.normalize();
    var c = point.x.redSqr();
    var b = point.y.redSqr();
    var x = c.redMul(this.a).redAdd(b);
    var r = this.c2.redMul(this.one.redAdd(this.d.redMul(c).redMul(b)));
    return 0 === x.cmp(r);
  };
  $(self, item.BasePoint);
  /**
   * @param {undefined} json
   * @return {?}
   */
  verify.prototype.pointFromJSON = function(json) {
    return self.fromJSON(this, json);
  };
  /**
   * @param {!Object} options
   * @param {!Object} val
   * @param {!Object} x
   * @param {!Object} y
   * @return {?}
   */
  verify.prototype.point = function(options, val, x, y) {
    return new self(this, options, val, x, y);
  };
  /**
   * @param {?} obj
   * @param {!Object} data
   * @return {?}
   */
  self.fromJSON = function(obj, data) {
    return new self(obj, data[0], data[1], data[2]);
  };
  /**
   * @return {?}
   */
  self.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  /**
   * @return {?}
   */
  self.prototype.isInfinity = function() {
    return 0 === this.x.cmpn(0) && (0 === this.y.cmp(this.z) || this.zOne && 0 === this.y.cmp(this.curve.c));
  };
  /**
   * @return {?}
   */
  self.prototype._extDbl = function() {
    var val = this.x.redSqr();
    var j = this.y.redSqr();
    var z = this.z.redSqr();
    z = z.redIAdd(z);
    var canvasLayersManager = this.curve._mulA(val);
    var t = this.x.redAdd(this.y).redSqr().redISub(val).redISub(j);
    var b = canvasLayersManager.redAdd(j);
    var c = b.redSub(z);
    var d = canvasLayersManager.redSub(j);
    var n = t.redMul(c);
    var y = b.redMul(d);
    var y2 = t.redMul(d);
    var l = c.redMul(b);
    return this.curve.point(n, y, l, y2);
  };
  /**
   * @return {?}
   */
  self.prototype._projDbl = function() {
    var n;
    var height;
    var s;
    var TemplateUtil = this.x.redAdd(this.y).redSqr();
    var str = this.x.redSqr();
    var m = this.y.redSqr();
    if (this.curve.twisted) {
      var r = (t = this.curve._mulA(str)).redAdd(m);
      if (this.zOne) {
        n = TemplateUtil.redSub(str).redSub(m).redMul(r.redSub(this.curve.two));
        height = r.redMul(t.redSub(m));
        s = r.redSqr().redSub(r).redSub(r);
      } else {
        var b = this.z.redSqr();
        var c = r.redSub(b).redISub(b);
        n = TemplateUtil.redSub(str).redISub(m).redMul(c);
        height = r.redMul(t.redSub(m));
        s = r.redMul(c);
      }
    } else {
      var t = str.redAdd(m);
      b = this.curve._mulC(this.z).redSqr();
      c = t.redSub(b).redSub(b);
      n = this.curve._mulC(TemplateUtil.redISub(t)).redMul(c);
      height = this.curve._mulC(t).redMul(str.redISub(m));
      s = t.redMul(c);
    }
    return this.curve.point(n, height, s);
  };
  /**
   * @return {?}
   */
  self.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  };
  /**
   * @param {!Object} trace
   * @return {?}
   */
  self.prototype._extAdd = function(trace) {
    var users = this.y.redSub(this.x).redMul(trace.y.redSub(trace.x));
    var siteManagementRef = this.y.redAdd(this.x).redMul(trace.y.redAdd(trace.x));
    var j = this.t.redMul(this.curve.dd).redMul(trace.t);
    var canvasLayersManager = this.z.redMul(trace.z.redAdd(trace.z));
    var r = siteManagementRef.redSub(users);
    var c = canvasLayersManager.redSub(j);
    var b = canvasLayersManager.redAdd(j);
    var value = siteManagementRef.redAdd(users);
    var n = r.redMul(c);
    var y = b.redMul(value);
    var z = r.redMul(value);
    var d = c.redMul(b);
    return this.curve.point(n, y, d, z);
  };
  /**
   * @param {!Object} to
   * @return {?}
   */
  self.prototype._projAdd = function(to) {
    var y;
    var i;
    var t = this.z.redMul(to.z);
    var NumberFce = t.redSqr();
    var b = this.x.redMul(to.x);
    var a = this.y.redMul(to.y);
    var s = this.curve.d.redMul(b).redMul(a);
    var r = NumberFce.redSub(s);
    var c = NumberFce.redAdd(s);
    var tc = this.x.redAdd(this.y).redMul(to.x.redAdd(to.y)).redISub(b).redISub(a);
    var n = t.redMul(r).redMul(tc);
    return this.curve.twisted ? (y = t.redMul(c).redMul(a.redSub(this.curve._mulA(b))), i = r.redMul(c)) : (y = t.redMul(c).redMul(a.redSub(b)), i = this.curve._mulC(r).redMul(c)), this.curve.point(n, y, i);
  };
  /**
   * @param {!Object} p
   * @return {?}
   */
  self.prototype.add = function(p) {
    return this.isInfinity() ? p : p.isInfinity() ? this : this.curve.extended ? this._extAdd(p) : this._projAdd(p);
  };
  /**
   * @param {?} value
   * @return {?}
   */
  self.prototype.mul = function(value) {
    return this._hasDoubles(value) ? this.curve._fixedNafMul(this, value) : this.curve._wnafMul(this, value);
  };
  /**
   * @param {?} point
   * @param {?} op
   * @param {?} result
   * @return {?}
   */
  self.prototype.mulAdd = function(point, op, result) {
    return this.curve._wnafMulAdd(1, [this, op], [point, result], 2, false);
  };
  /**
   * @param {?} to
   * @param {?} topspeed
   * @param {?} startspeed
   * @return {?}
   */
  self.prototype.jmulAdd = function(to, topspeed, startspeed) {
    return this.curve._wnafMulAdd(1, [this, topspeed], [to, startspeed], 2, true);
  };
  /**
   * @return {?}
   */
  self.prototype.normalize = function() {
    if (this.zOne) {
      return this;
    }
    var precision = this.z.redInvm();
    return this.x = this.x.redMul(precision), this.y = this.y.redMul(precision), this.t && (this.t = this.t.redMul(precision)), this.z = this.curve.one, this.zOne = true, this;
  };
  /**
   * @return {?}
   */
  self.prototype.neg = function() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  /**
   * @return {?}
   */
  self.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  };
  /**
   * @return {?}
   */
  self.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  };
  /**
   * @param {!Object} text
   * @return {?}
   */
  self.prototype.eq = function(text) {
    return this === text || 0 === this.getX().cmp(text.getX()) && 0 === this.getY().cmp(text.getY());
  };
  /**
   * @param {?} y
   * @return {?}
   */
  self.prototype.eqXToP = function(y) {
    var x = y.toRed(this.curve.red).redMul(this.z);
    if (0 === this.x.cmp(x)) {
      return true;
    }
    var r = y.clone();
    var res = this.curve.redN.redMul(this.z);
    for (;;) {
      if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) {
        return false;
      }
      if (x.redIAdd(res), 0 === this.x.cmp(x)) {
        return true;
      }
    }
  };
  /** @type {function(): ?} */
  self.prototype.toP = self.prototype.normalize;
  /** @type {function(!Object): ?} */
  self.prototype.mixedAdd = self.prototype.add;
}, function(canCreateDiscussions, hash_fns, saveNotifs) {
  hash_fns.sha1 = saveNotifs(165);
  hash_fns.sha224 = saveNotifs(166);
  hash_fns.sha256 = saveNotifs(92);
  hash_fns.sha384 = saveNotifs(167);
  hash_fns.sha512 = saveNotifs(93);
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {?}
   */
  function Slider() {
    if (!(this instanceof Slider)) {
      return new Slider;
    }
    Event.call(this);
    /** @type {!Array} */
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    /** @type {!Array} */
    this.W = new Array(80);
  }
  var _ = require(9);
  var dom = require(23);
  var utils = require(91);
  var parse = _.rotl32;
  var setItemLater = _.sum32;
  var callback = _.sum32_5;
  var filter = utils.ft_1;
  var Event = dom.BlockHash;
  /** @type {!Array} */
  var obj = [1518500249, 1859775393, 2400959708, 3395469782];
  _.inherits(Slider, Event);
  /** @type {function(): ?} */
  module.exports = Slider;
  /** @type {number} */
  Slider.blockSize = 512;
  /** @type {number} */
  Slider.outSize = 160;
  /** @type {number} */
  Slider.hmacStrength = 80;
  /** @type {number} */
  Slider.padLength = 64;
  /**
   * @param {!Object} data
   * @param {number} off
   * @return {undefined}
   */
  Slider.prototype._update = function(data, off) {
    var buffer = this.W;
    /** @type {number} */
    var i = 0;
    for (; i < 16; i++) {
      buffer[i] = data[off + i];
    }
    for (; i < buffer.length; i++) {
      buffer[i] = parse(buffer[i - 3] ^ buffer[i - 8] ^ buffer[i - 14] ^ buffer[i - 16], 1);
    }
    var d = this.h[0];
    var a = this.h[1];
    var g = this.h[2];
    var b = this.h[3];
    var c = this.h[4];
    /** @type {number} */
    i = 0;
    for (; i < buffer.length; i++) {
      /** @type {number} */
      var hash = ~~(i / 20);
      var v = callback(parse(d, 5), filter(hash, a, g, b), c, buffer[i], obj[hash]);
      c = b;
      b = g;
      g = parse(a, 30);
      a = d;
      d = v;
    }
    this.h[0] = setItemLater(this.h[0], d);
    this.h[1] = setItemLater(this.h[1], a);
    this.h[2] = setItemLater(this.h[2], g);
    this.h[3] = setItemLater(this.h[3], b);
    this.h[4] = setItemLater(this.h[4], c);
  };
  /**
   * @param {string} hex2
   * @return {?}
   */
  Slider.prototype._digest = function(hex2) {
    return "hex" === hex2 ? _.toHex32(this.h, "big") : _.split32(this.h, "big");
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {?}
   */
  function f() {
    if (!(this instanceof f)) {
      return new f;
    }
    Polling.call(this);
    /** @type {!Array} */
    this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
  }
  var util = require(9);
  var Polling = require(92);
  util.inherits(f, Polling);
  /** @type {function(): ?} */
  module.exports = f;
  /** @type {number} */
  f.blockSize = 512;
  /** @type {number} */
  f.outSize = 224;
  /** @type {number} */
  f.hmacStrength = 192;
  /** @type {number} */
  f.padLength = 64;
  /**
   * @param {string} hex2
   * @return {?}
   */
  f.prototype._digest = function(hex2) {
    return "hex" === hex2 ? util.toHex32(this.h.slice(0, 7), "big") : util.split32(this.h.slice(0, 7), "big");
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @return {?}
   */
  function f() {
    if (!(this instanceof f)) {
      return new f;
    }
    Polling.call(this);
    /** @type {!Array} */
    this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
  }
  var util = require(9);
  var Polling = require(93);
  util.inherits(f, Polling);
  /** @type {function(): ?} */
  module.exports = f;
  /** @type {number} */
  f.blockSize = 1024;
  /** @type {number} */
  f.outSize = 384;
  /** @type {number} */
  f.hmacStrength = 192;
  /** @type {number} */
  f.padLength = 128;
  /**
   * @param {string} hex2
   * @return {?}
   */
  f.prototype._digest = function(hex2) {
    return "hex" === hex2 ? util.toHex32(this.h.slice(0, 12), "big") : util.split32(this.h.slice(0, 12), "big");
  };
}, function(canCreateDiscussions, options, $) {
  /**
   * @return {?}
   */
  function Slider() {
    if (!(this instanceof Slider)) {
      return new Slider;
    }
    parent.call(this);
    /** @type {!Array} */
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    /** @type {string} */
    this.endian = "little";
  }
  /**
   * @param {number} str
   * @param {number} e
   * @param {number} a
   * @param {number} b
   * @return {?}
   */
  function debug(str, e, a, b) {
    return str <= 15 ? e ^ a ^ b : str <= 31 ? e & a | ~e & b : str <= 47 ? (e | ~a) ^ b : str <= 63 ? e & b | a & ~b : e ^ (a | ~b);
  }
  /**
   * @param {number} documents
   * @return {?}
   */
  function remove(documents) {
    return documents <= 15 ? 0 : documents <= 31 ? 1518500249 : documents <= 47 ? 1859775393 : documents <= 63 ? 2400959708 : 2840853838;
  }
  /**
   * @param {number} name
   * @return {?}
   */
  function getById(name) {
    return name <= 15 ? 1352829926 : name <= 31 ? 1548603684 : name <= 47 ? 1836072691 : name <= 63 ? 2053994217 : 0;
  }
  var self = $(9);
  var btn = $(23);
  var cb = self.rotl32;
  var resolve = self.sum32;
  var filter = self.sum32_3;
  var f = self.sum32_4;
  var parent = btn.BlockHash;
  self.inherits(Slider, parent);
  /** @type {function(): ?} */
  options.ripemd160 = Slider;
  /** @type {number} */
  Slider.blockSize = 512;
  /** @type {number} */
  Slider.outSize = 160;
  /** @type {number} */
  Slider.hmacStrength = 192;
  /** @type {number} */
  Slider.padLength = 64;
  /**
   * @param {!Object} s
   * @param {number} off
   * @return {undefined}
   */
  Slider.prototype._update = function(s, off) {
    var e = this.h[0];
    var a = this.h[1];
    var index = this.h[2];
    var b = this.h[3];
    var x = this.h[4];
    var g = e;
    var options = a;
    var id = index;
    var end = b;
    var i = x;
    /** @type {number} */
    var key = 0;
    for (; key < 80; key++) {
      var value = resolve(cb(f(e, debug(key, a, index, b), s[closedFrames[key] + off], remove(key)), version_info[key]), x);
      e = x;
      x = b;
      b = cb(index, 10);
      index = a;
      a = value;
      value = resolve(cb(f(g, debug(79 - key, options, id, end), s[range[key] + off], getById(key)), someStoreStorage[key]), i);
      g = i;
      i = end;
      end = cb(id, 10);
      id = options;
      options = value;
    }
    value = filter(this.h[1], index, end);
    this.h[1] = filter(this.h[2], b, i);
    this.h[2] = filter(this.h[3], x, g);
    this.h[3] = filter(this.h[4], e, options);
    this.h[4] = filter(this.h[0], a, id);
    this.h[0] = value;
  };
  /**
   * @param {string} hex2
   * @return {?}
   */
  Slider.prototype._digest = function(hex2) {
    return "hex" === hex2 ? self.toHex32(this.h, "little") : self.split32(this.h, "little");
  };
  /** @type {!Array} */
  var closedFrames = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  /** @type {!Array} */
  var range = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  /** @type {!Array} */
  var version_info = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  /** @type {!Array} */
  var someStoreStorage = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
}, function(context, canCreateDiscussions, moment) {
  /**
   * @param {string} key
   * @param {string} children
   * @param {string} k
   * @return {?}
   */
  function init(key, children, k) {
    if (!(this instanceof init)) {
      return new init(key, children, k);
    }
    /** @type {string} */
    this.Hash = key;
    /** @type {number} */
    this.blockSize = key.blockSize / 8;
    /** @type {number} */
    this.outSize = key.outSize / 8;
    /** @type {null} */
    this.inner = null;
    /** @type {null} */
    this.outer = null;
    this._init(result.toArray(children, k));
  }
  var result = moment(9);
  var start = moment(6);
  /** @type {function(string, string, string): ?} */
  context.exports = init;
  /**
   * @param {!Array} key
   * @return {undefined}
   */
  init.prototype._init = function(key) {
    if (key.length > this.blockSize) {
      key = (new this.Hash).update(key).digest();
    }
    start(key.length <= this.blockSize);
    var i = key.length;
    for (; i < this.blockSize; i++) {
      key.push(0);
    }
    /** @type {number} */
    i = 0;
    for (; i < key.length; i++) {
      key[i] ^= 54;
    }
    this.inner = (new this.Hash).update(key);
    /** @type {number} */
    i = 0;
    for (; i < key.length; i++) {
      key[i] ^= 106;
    }
    this.outer = (new this.Hash).update(key);
  };
  /**
   * @param {?} data
   * @param {!Array} callback
   * @return {?}
   */
  init.prototype.update = function(data, callback) {
    return this.inner.update(data, callback), this;
  };
  /**
   * @param {string} enc
   * @return {?}
   */
  init.prototype.digest = function(enc) {
    return this.outer.update(this.inner.digest()), this.outer.digest(enc);
  };
}, function(mixin, canCreateDiscussions) {
  mixin.exports = {
    doubles : {
      step : 4,
      points : [["e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a", "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"], ["8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508", "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"], ["175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739", "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"], ["363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640", "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"], 
      ["8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c", "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"], ["723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda", "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"], ["eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa", "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"], ["100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0", "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"], 
      ["e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d", "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"], ["feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d", "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"], ["da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1", "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"], ["53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0", "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"], 
      ["8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047", "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"], ["385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862", "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"], ["6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7", "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"], ["3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd", "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"], 
      ["85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83", "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"], ["948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a", "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"], ["6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8", "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"], ["e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d", "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"], 
      ["e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725", "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"], ["213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754", "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"], ["4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c", "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"], ["fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6", "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"], 
      ["76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39", "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"], ["c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891", "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"], ["d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b", "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"], ["b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03", "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"], 
      ["e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d", "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"], ["a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070", "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"], ["90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4", "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"], ["8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da", "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"], 
      ["e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11", "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"], ["8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e", "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"], ["e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41", "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"], ["b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef", "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"], 
      ["d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8", "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"], ["324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d", "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"], ["4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96", "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"], ["9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd", "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"], 
      ["6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5", "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"], ["a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266", "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"], ["7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71", "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"], ["928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac", "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"], 
      ["85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751", "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"], ["ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e", "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"], ["827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241", "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"], ["eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3", "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"], 
      ["e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f", "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"], ["1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19", "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"], ["146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be", "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"], ["fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9", "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"], 
      ["da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2", "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"], ["a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13", "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"], ["174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c", "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"], ["959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba", "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"], 
      ["d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151", "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"], ["64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073", "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"], ["8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458", "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"], ["13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b", "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"], 
      ["bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366", "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"], ["8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa", "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"], ["8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0", "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"], ["dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787", "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"], 
      ["f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e", "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"]]
    },
    naf : {
      wnd : 7,
      points : [["f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9", "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"], ["2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4", "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"], ["5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc", "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"], ["acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe", "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"], 
      ["774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb", "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"], ["f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8", "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"], ["d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e", "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"], ["defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34", "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"], 
      ["2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c", "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"], ["352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5", "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"], ["2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f", "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"], ["9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714", "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"], 
      ["daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729", "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"], ["c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db", "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"], ["6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4", "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"], ["1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5", "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"], 
      ["605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479", "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"], ["62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d", "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"], ["80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f", "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"], ["7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb", "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"], 
      ["d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9", "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"], ["49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963", "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"], ["77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74", "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"], ["f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530", "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"], 
      ["463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b", "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"], ["f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247", "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"], ["caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1", "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"], ["2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120", "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"], 
      ["7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435", "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"], ["754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18", "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"], ["e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8", "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"], ["186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb", "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"], 
      ["df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f", "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"], ["5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143", "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"], ["290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba", "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"], ["af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45", "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"], 
      ["766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a", "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"], ["59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e", "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"], ["f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8", "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"], ["7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c", "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"], 
      ["948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519", "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"], ["7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab", "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"], ["3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca", "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"], ["d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf", "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"], 
      ["1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610", "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"], ["733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4", "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"], ["15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c", "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"], ["a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940", "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"], 
      ["e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980", "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"], ["311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3", "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"], ["34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf", "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"], ["f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63", "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"], 
      ["d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448", "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"], ["32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf", "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"], ["7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5", "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"], ["ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6", "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"], 
      ["16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5", "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"], ["eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99", "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"], ["78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51", "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"], ["494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5", "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"], 
      ["a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5", "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"], ["c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997", "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"], ["841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881", "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"], ["5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5", "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"], 
      ["36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66", "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"], ["336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726", "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"], ["8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede", "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"], ["1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94", "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"], 
      ["85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31", "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"], ["29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51", "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"], ["a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252", "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"], ["4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5", "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"], 
      ["d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b", "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"], ["ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4", "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"], ["af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f", "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"], ["e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889", "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"], 
      ["591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246", "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"], ["11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984", "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"], ["3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a", "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"], ["cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030", "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"], 
      ["c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197", "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"], ["c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593", "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"], ["a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef", "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"], ["347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38", "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"], 
      ["da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a", "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"], ["c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111", "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"], ["4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502", "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"], ["3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea", "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"], 
      ["cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26", "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"], ["b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986", "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"], ["d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e", "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"], ["48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4", "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"], 
      ["dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda", "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"], ["6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859", "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"], ["e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f", "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"], ["eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c", "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"], 
      ["13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942", "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"], ["ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a", "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"], ["b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80", "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"], ["ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d", "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"], 
      ["8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1", "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"], ["52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63", "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"], ["e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352", "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"], ["7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193", "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"], 
      ["5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00", "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"], ["32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58", "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"], ["e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7", "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"], ["8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8", "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"], 
      ["4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e", "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"], ["3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d", "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"], ["674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b", "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"], ["d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f", "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"], 
      ["30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6", "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"], ["be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297", "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"], ["93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a", "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"], ["b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c", "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"], 
      ["d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52", "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"], ["d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb", "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"], ["463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065", "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"], ["7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917", "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"], 
      ["74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9", "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"], ["30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3", "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"], ["9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57", "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"], ["176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66", "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"], 
      ["75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8", "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"], ["809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721", "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"], ["1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180", "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"]]
    }
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @return {?}
   */
  function sign(key) {
    if (!(this instanceof sign)) {
      return new sign(key);
    }
    if ("string" === typeof key) {
      assert(nodes.hasOwnProperty(key), "Unknown curve " + key);
      key = nodes[key];
    }
    if (key instanceof nodes.PresetCurve) {
      key = {
        curve : key
      };
    }
    this.curve = key.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = key.curve.g;
    this.g.precompute(key.curve.n.bitLength() + 1);
    this.hash = key.hash || key.curve.hash;
  }
  var BN = require(4);
  var bn = require(172);
  var chai = require(7);
  var nodes = require(51);
  var generate = require(48);
  var assert = chai.assert;
  var KeyPair = require(173);
  var Buffer = require(174);
  /** @type {function(!Object): ?} */
  module.exports = sign;
  /**
   * @param {?} options
   * @return {?}
   */
  sign.prototype.keyPair = function(options) {
    return new KeyPair(this, options);
  };
  /**
   * @param {!Object} priv
   * @param {?} enc
   * @return {?}
   */
  sign.prototype.keyFromPrivate = function(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  /**
   * @param {!Object} pub
   * @param {?} enc
   * @return {?}
   */
  sign.prototype.keyFromPublic = function(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  /**
   * @param {!Object} options
   * @return {?}
   */
  sign.prototype.genKeyPair = function(options) {
    if (!options) {
      options = {};
    }
    var r = new bn({
      hash : this.hash,
      pers : options.pers,
      persEnc : options.persEnc || "utf8",
      entropy : options.entropy || generate(this.hash.hmacStrength),
      entropyEnc : options.entropy && options.entropyEnc || "utf8",
      nonce : this.n.toArray()
    });
    var result = this.n.byteLength();
    var b = this.n.sub(new BN(2));
    for (;;) {
      var priv = new BN(r.generate(result));
      if (!(priv.cmp(b) > 0)) {
        return priv.iaddn(1), this.keyFromPrivate(priv);
      }
    }
  };
  /**
   * @param {!Object} msg
   * @param {boolean} isFromBackend
   * @return {?}
   */
  sign.prototype._truncateToN = function(msg, isFromBackend) {
    /** @type {number} */
    var delta = 8 * msg.byteLength() - this.n.bitLength();
    return delta > 0 && (msg = msg.ushrn(delta)), !isFromBackend && msg.cmp(this.n) >= 0 ? msg.sub(this.n) : msg;
  };
  /**
   * @param {!Object} msg
   * @param {string} key
   * @param {!Object} enc
   * @param {!Object} options
   * @return {?}
   */
  sign.prototype.sign = function(msg, key, enc, options) {
    if ("object" === typeof enc) {
      /** @type {!Object} */
      options = enc;
      /** @type {null} */
      enc = null;
    }
    if (!options) {
      options = {};
    }
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    var p = new bn({
      hash : this.hash,
      entropy : bkey,
      nonce : nonce,
      pers : options.pers,
      persEnc : options.persEnc || "utf8"
    });
    var q = this.n.sub(new BN(1));
    /** @type {number} */
    var iter = 0;
    for (;; iter++) {
      var k = options.k ? options.k(iter) : new BN(p.generate(this.n.byteLength()));
      if (!((k = this._truncateToN(k, true)).cmpn(1) <= 0 || k.cmp(q) >= 0)) {
        var kp = this.g.mul(k);
        if (!kp.isInfinity()) {
          var x = kp.getX();
          var r = x.umod(this.n);
          if (0 !== r.cmpn(0)) {
            var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
            if (0 !== (s = s.umod(this.n)).cmpn(0)) {
              /** @type {number} */
              var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (0 !== x.cmp(r) ? 2 : 0);
              return options.canonical && s.cmp(this.nh) > 0 && (s = this.n.sub(s), recoveryParam = recoveryParam ^ 1), new Buffer({
                r : r,
                s : s,
                recoveryParam : recoveryParam
              });
            }
          }
        }
      }
    }
  };
  /**
   * @param {number} msg
   * @param {string} value
   * @param {?} key
   * @param {?} enc
   * @return {?}
   */
  sign.prototype.verify = function(msg, value, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    var r = (value = new Buffer(value, "hex")).r;
    var k = value.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) {
      return false;
    }
    if (k.cmpn(1) < 0 || k.cmp(this.n) >= 0) {
      return false;
    }
    var p;
    var sinv = k.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    return this.curve._maxwellTrick ? !(p = this.g.jmulAdd(u1, key.getPublic(), u2)).isInfinity() && p.eqXToP(r) : !(p = this.g.mulAdd(u1, key.getPublic(), u2)).isInfinity() && 0 === p.getX().umod(this.n).cmp(r);
  };
  /**
   * @param {?} msg
   * @param {!Object} signature
   * @param {number} j
   * @param {string} enc
   * @return {?}
   */
  sign.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Buffer(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var v = signature.s;
    /** @type {number} */
    var endtick = 1 & j;
    /** @type {number} */
    var axrev = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && axrev) {
      throw new Error("Unable to find sencond key candinate");
    }
    r = axrev ? this.curve.pointFromX(r.add(this.curve.n), endtick) : this.curve.pointFromX(r, endtick);
    var w = signature.r.invm(n);
    var u1 = n.sub(e).mul(w).umod(n);
    var u2 = v.mul(w).umod(n);
    return this.g.mulAdd(u1, r, u2);
  };
  /**
   * @param {?} e
   * @param {!Object} signature
   * @param {!Object} Q
   * @param {string} enc
   * @return {?}
   */
  sign.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    if (null !== (signature = new Buffer(signature, enc)).recoveryParam) {
      return signature.recoveryParam;
    }
    /** @type {number} */
    var i = 0;
    for (; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e) {
        continue;
      }
      if (Qprime.eq(Q)) {
        return i;
      }
    }
    throw new Error("Unable to find valid recovery factor");
  };
}, function(context, canCreateDiscussions, require) {
  /**
   * @param {!Object} options
   * @return {?}
   */
  function init(options) {
    if (!(this instanceof init)) {
      return new init(options);
    }
    this.hash = options.hash;
    /** @type {boolean} */
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    /** @type {null} */
    this._reseed = null;
    /** @type {null} */
    this.reseedInterval = null;
    /** @type {null} */
    this.K = null;
    /** @type {null} */
    this.V = null;
    var item = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var type = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var url = utils.toArray(options.pers, options.persEnc || "hex");
    assert(item.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(item, type, url);
  }
  var crypto = require(52);
  var utils = require(89);
  var assert = require(6);
  /** @type {function(!Object): ?} */
  context.exports = init;
  /**
   * @param {!Array} element
   * @param {undefined} type
   * @param {undefined} url
   * @return {undefined}
   */
  init.prototype._init = function(element, type, url) {
    var data = element.concat(type).concat(url);
    /** @type {!Array} */
    this.K = new Array(this.outLen / 8);
    /** @type {!Array} */
    this.V = new Array(this.outLen / 8);
    /** @type {number} */
    var i = 0;
    for (; i < this.V.length; i++) {
      /** @type {number} */
      this.K[i] = 0;
      /** @type {number} */
      this.V[i] = 1;
    }
    this._update(data);
    /** @type {number} */
    this._reseed = 1;
    /** @type {number} */
    this.reseedInterval = 281474976710656;
  };
  /**
   * @return {?}
   */
  init.prototype._hmac = function() {
    return new crypto.hmac(this.hash, this.K);
  };
  /**
   * @param {!Array} data
   * @return {undefined}
   */
  init.prototype._update = function(data) {
    var md = this._hmac().update(this.V).update([0]);
    if (data) {
      md = md.update(data);
    }
    this.K = md.digest();
    this.V = this._hmac().update(this.V).digest();
    if (data) {
      this.K = this._hmac().update(this.V).update([1]).update(data).digest();
      this.V = this._hmac().update(this.V).digest();
    }
  };
  /**
   * @param {string} f
   * @param {string} i
   * @param {string} s
   * @param {string} l
   * @return {undefined}
   */
  init.prototype.reseed = function(f, i, s, l) {
    if ("string" !== typeof i) {
      /** @type {string} */
      l = s;
      /** @type {string} */
      s = i;
      /** @type {null} */
      i = null;
    }
    f = utils.toArray(f, i);
    s = utils.toArray(s, l);
    assert(f.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(f.concat(s || []));
    /** @type {number} */
    this._reseed = 1;
  };
  /**
   * @param {number} target
   * @param {string} value
   * @param {undefined} data
   * @param {string} options
   * @return {?}
   */
  init.prototype.generate = function(target, value, data, options) {
    if (this._reseed > this.reseedInterval) {
      throw new Error("Reseed is required");
    }
    if ("string" !== typeof value) {
      options = data;
      /** @type {string} */
      data = value;
      /** @type {null} */
      value = null;
    }
    if (data) {
      data = utils.toArray(data, options || "hex");
      this._update(data);
    }
    /** @type {!Array} */
    var temp = [];
    for (; temp.length < target;) {
      this.V = this._hmac().update(this.V).digest();
      /** @type {!Array<?>} */
      temp = temp.concat(this.V);
    }
    /** @type {!Array<?>} */
    var a = temp.slice(0, target);
    return this._update(data), this._reseed++, utils.encode(a, value);
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @param {!Object} options
   * @return {undefined}
   */
  function self(key, options) {
    /** @type {!Object} */
    this.ec = key;
    /** @type {null} */
    this.priv = null;
    /** @type {null} */
    this.pub = null;
    if (options.priv) {
      this._importPrivate(options.priv, options.privEnc);
    }
    if (options.pub) {
      this._importPublic(options.pub, options.pubEnc);
    }
  }
  var BN = require(4);
  var point = require(7).assert;
  /** @type {function(!Object, !Object): undefined} */
  module.exports = self;
  /**
   * @param {string} key
   * @param {!Object} obj
   * @param {?} enc
   * @return {?}
   */
  self.fromPublic = function(key, obj, enc) {
    return obj instanceof self ? obj : new self(key, {
      pub : obj,
      pubEnc : enc
    });
  };
  /**
   * @param {string} key
   * @param {!Function} obj
   * @param {?} enc
   * @return {?}
   */
  self.fromPrivate = function(key, obj, enc) {
    return obj instanceof self ? obj : new self(key, {
      priv : obj,
      privEnc : enc
    });
  };
  /**
   * @return {?}
   */
  self.prototype.validate = function() {
    var pub = this.getPublic();
    return pub.isInfinity() ? {
      result : false,
      reason : "Invalid public key"
    } : pub.validate() ? pub.mul(this.ec.curve.n).isInfinity() ? {
      result : true,
      reason : null
    } : {
      result : false,
      reason : "Public key * N != O"
    } : {
      result : false,
      reason : "Public key is not a point"
    };
  };
  /**
   * @param {string} data
   * @param {!Function} cb
   * @return {?}
   */
  self.prototype.getPublic = function(data, cb) {
    return "string" === typeof data && (cb = data, data = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), cb ? this.pub.encode(cb, data) : this.pub;
  };
  /**
   * @param {string} data
   * @return {?}
   */
  self.prototype.getPrivate = function(data) {
    return "hex" === data ? this.priv.toString(16, 2) : this.priv;
  };
  /**
   * @param {number} key
   * @param {number} enc
   * @return {undefined}
   */
  self.prototype._importPrivate = function(key, enc) {
    this.priv = new BN(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  /**
   * @param {!Object} key
   * @param {string} enc
   * @return {?}
   */
  self.prototype._importPublic = function(key, enc) {
    if (key.x || key.y) {
      return "mont" === this.ec.curve.type ? point(key.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || point(key.x && key.y, "Need both x and y coordinate"), void(this.pub = this.ec.curve.point(key.x, key.y));
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  /**
   * @param {?} pub
   * @return {?}
   */
  self.prototype.derive = function(pub) {
    return pub.mul(this.priv).getX();
  };
  /**
   * @param {!Object} msg
   * @param {?} enc
   * @param {!Array} options
   * @return {?}
   */
  self.prototype.sign = function(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  /**
   * @param {number} msg
   * @param {string} signature
   * @return {?}
   */
  self.prototype.verify = function(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  /**
   * @return {?}
   */
  self.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @param {string} s
   * @return {?}
   */
  function verify(key, s) {
    if (key instanceof verify) {
      return key;
    }
    if (!this._importDER(key, s)) {
      assert(key.r && key.s, "Signature without r or s");
      this.r = new bn(key.r, 16);
      this.s = new bn(key.s, 16);
      if (void 0 === key.recoveryParam) {
        /** @type {null} */
        this.recoveryParam = null;
      } else {
        this.recoveryParam = key.recoveryParam;
      }
    }
  }
  /**
   * @return {undefined}
   */
  function Position() {
    /** @type {number} */
    this.place = 0;
  }
  /**
   * @param {string} buf
   * @param {!Object} p
   * @return {?}
   */
  function getLength(buf, p) {
    var len = buf[p.place++];
    if (!(128 & len)) {
      return len;
    }
    /** @type {number} */
    var clientHeight = 15 & len;
    /** @type {number} */
    var val = 0;
    /** @type {number} */
    var targetOffsetHeight = 0;
    var off = p.place;
    for (; targetOffsetHeight < clientHeight; targetOffsetHeight++, off++) {
      /** @type {number} */
      val = val << 8;
      /** @type {number} */
      val = val | buf[off];
    }
    return p.place = off, val;
  }
  /**
   * @param {string} x
   * @return {?}
   */
  function match(x) {
    /** @type {number} */
    var j = 0;
    /** @type {number} */
    var rown = x.length - 1;
    for (; !x[j] && !(128 & x[j + 1]) && j < rown;) {
      j++;
    }
    return 0 === j ? x : x.slice(j);
  }
  /**
   * @param {!Array} text
   * @param {number} value
   * @return {undefined}
   */
  function debug(text, value) {
    if (value < 128) {
      text.push(value);
    } else {
      /** @type {number} */
      var odd = 1 + (Math.log(value) / Math.LN2 >>> 3);
      text.push(128 | odd);
      for (; --odd;) {
        text.push(value >>> (odd << 3) & 255);
      }
      text.push(value);
    }
  }
  var bn = require(4);
  var utils = require(7);
  var assert = utils.assert;
  /** @type {function(!Object, string): ?} */
  module.exports = verify;
  /**
   * @param {string} data
   * @param {string} enc
   * @return {?}
   */
  verify.prototype._importDER = function(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position;
    if (48 !== data[p.place++]) {
      return false;
    }
    if (getLength(data, p) + p.place !== data.length) {
      return false;
    }
    if (2 !== data[p.place++]) {
      return false;
    }
    var rlen = getLength(data, p);
    var r = data.slice(p.place, rlen + p.place);
    if (p.place += rlen, 2 !== data[p.place++]) {
      return false;
    }
    var slen = getLength(data, p);
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    return 0 === r[0] && 128 & r[1] && (r = r.slice(1)), 0 === s[0] && 128 & s[1] && (s = s.slice(1)), this.r = new bn(r), this.s = new bn(s), this.recoveryParam = null, true;
  };
  /**
   * @param {boolean} r
   * @return {?}
   */
  verify.prototype.toDER = function(r) {
    var m = this.r.toArray();
    var result = this.s.toArray();
    if (128 & m[0]) {
      /** @type {!Array<?>} */
      m = [0].concat(m);
    }
    if (128 & result[0]) {
      /** @type {!Array<?>} */
      result = [0].concat(result);
    }
    m = match(m);
    result = match(result);
    for (; !result[0] && !(128 & result[1]);) {
      result = result.slice(1);
    }
    /** @type {!Array} */
    var data = [2];
    debug(data, m.length);
    (data = data.concat(m)).push(2);
    debug(data, result.length);
    /** @type {!Array<?>} */
    var o = data.concat(result);
    /** @type {!Array} */
    var a = [48];
    return debug(a, o.length), a = a.concat(o), utils.encode(a, r);
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {!Object} key
   * @return {?}
   */
  function sign(key) {
    if (assert("ed25519" === key, "only tested with ed25519 so far"), !(this instanceof sign)) {
      return new sign(key);
    }
    key = transition[key].curve;
    /** @type {!Object} */
    this.curve = key;
    this.g = key.g;
    this.g.precompute(key.n.bitLength() + 1);
    this.pointClass = key.point().constructor;
    /** @type {number} */
    this.encodingLength = Math.ceil(key.n.bitLength() / 8);
    this.hash = configs.sha512;
  }
  var configs = require(52);
  var transition = require(51);
  var utils = require(7);
  var assert = utils.assert;
  var firstLine = utils.parseBytes;
  var model = require(176);
  var Point = require(177);
  /** @type {function(!Object): ?} */
  module.exports = sign;
  /**
   * @param {!Object} message
   * @param {string} secret
   * @return {?}
   */
  sign.prototype.sign = function(message, secret) {
    message = firstLine(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var msg = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var unitSeparator = r.add(msg).umod(this.curve.n);
    return this.makeSignature({
      R : R,
      S : unitSeparator,
      Rencoded : Rencoded
    });
  };
  /**
   * @param {?} message
   * @param {!Object} sig
   * @param {!Object} pub
   * @return {?}
   */
  sign.prototype.verify = function(message, sig, pub) {
    message = firstLine(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var o = this.g.mul(sig.S());
    return sig.R().add(key.pub().mul(h)).eq(o);
  };
  /**
   * @return {?}
   */
  sign.prototype.hashInt = function() {
    var hash = this.hash();
    /** @type {number} */
    var i = 0;
    for (; i < arguments.length; i++) {
      hash.update(arguments[i]);
    }
    return utils.intFromLE(hash.digest()).umod(this.curve.n);
  };
  /**
   * @param {!Object} pub
   * @return {?}
   */
  sign.prototype.keyFromPublic = function(pub) {
    return model.fromPublic(this, pub);
  };
  /**
   * @param {!Object} secret
   * @return {?}
   */
  sign.prototype.keyFromSecret = function(secret) {
    return model.fromSecret(this, secret);
  };
  /**
   * @param {!Function} s
   * @return {?}
   */
  sign.prototype.makeSignature = function(s) {
    return s instanceof Point ? s : new Point(this, s);
  };
  /**
   * @param {!Object} point
   * @return {?}
   */
  sign.prototype.encodePoint = function(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    return enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0, enc;
  };
  /**
   * @param {!Object} bytes
   * @return {?}
   */
  sign.prototype.decodePoint = function(bytes) {
    /** @type {number} */
    var index = (bytes = utils.parseBytes(bytes)).length - 1;
    var normed = bytes.slice(0, index).concat(-129 & bytes[index]);
    /** @type {boolean} */
    var xIsOdd = 0 !== (128 & bytes[index]);
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  /**
   * @param {?} num
   * @return {?}
   */
  sign.prototype.encodeInt = function(num) {
    return num.toArray("le", this.encodingLength);
  };
  /**
   * @param {string} bytes
   * @return {?}
   */
  sign.prototype.decodeInt = function(bytes) {
    return utils.intFromLE(bytes);
  };
  /**
   * @param {?} val
   * @return {?}
   */
  sign.prototype.isPoint = function(val) {
    return val instanceof this.pointClass;
  };
}, function(blob, canCreateDiscussions, $) {
  /**
   * @param {!Object} value
   * @param {!Object} params
   * @return {undefined}
   */
  function data(value, params) {
    /** @type {!Object} */
    this.eddsa = value;
    this._secret = resolve(params.secret);
    if (value.isPoint(params.pub)) {
      this._pub = params.pub;
    } else {
      this._pubBytes = resolve(params.pub);
    }
  }
  var self = $(7);
  var assert = self.assert;
  var resolve = self.parseBytes;
  var callback = self.cachedProperty;
  /**
   * @param {string} size
   * @param {!Object} key
   * @return {?}
   */
  data.fromPublic = function(size, key) {
    return key instanceof data ? key : new data(size, {
      pub : key
    });
  };
  /**
   * @param {string} eddsa
   * @param {!Function} secret
   * @return {?}
   */
  data.fromSecret = function(eddsa, secret) {
    return secret instanceof data ? secret : new data(eddsa, {
      secret : secret
    });
  };
  /**
   * @return {?}
   */
  data.prototype.secret = function() {
    return this._secret;
  };
  callback(data, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  });
  callback(data, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  });
  callback(data, "privBytes", function() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    /** @type {number} */
    var themeprop = eddsa.encodingLength - 1;
    var n = hash.slice(0, eddsa.encodingLength);
    return n[0] &= 248, n[themeprop] &= 127, n[themeprop] |= 64, n;
  });
  callback(data, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  callback(data, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  callback(data, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  /**
   * @param {!Object} message
   * @return {?}
   */
  data.prototype.sign = function(message) {
    return assert(this._secret, "KeyPair can only verify"), this.eddsa.sign(message, this);
  };
  /**
   * @param {number} message
   * @param {string} sig
   * @return {?}
   */
  data.prototype.verify = function(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  /**
   * @param {boolean} callback
   * @return {?}
   */
  data.prototype.getSecret = function(callback) {
    return assert(this._secret, "KeyPair is public only"), self.encode(this.secret(), callback);
  };
  /**
   * @param {boolean} callback
   * @return {?}
   */
  data.prototype.getPublic = function(callback) {
    return self.encode(this.pubBytes(), callback);
  };
  /** @type {function(!Object, !Object): undefined} */
  blob.exports = data;
}, function(module, canCreateDiscussions, $) {
  /**
   * @param {!Object} value
   * @param {!Object} sig
   * @return {undefined}
   */
  function Color(value, sig) {
    /** @type {!Object} */
    this.eddsa = value;
    if ("object" !== typeof sig) {
      sig = parseInt(sig);
    }
    if (Array.isArray(sig)) {
      sig = {
        R : sig.slice(0, value.encodingLength),
        S : sig.slice(value.encodingLength)
      };
    }
    test(sig.R && sig.S, "Signature without R or S");
    if (value.isPoint(sig.R)) {
      this._R = sig.R;
    }
    if (sig.S instanceof $realtime) {
      this._S = sig.S;
    }
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  var $realtime = $(4);
  var self = $(7);
  var test = self.assert;
  var hasCurve = self.cachedProperty;
  var parseInt = self.parseBytes;
  hasCurve(Color, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  hasCurve(Color, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  hasCurve(Color, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  });
  hasCurve(Color, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  });
  /**
   * @return {?}
   */
  Color.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  };
  /**
   * @return {?}
   */
  Color.prototype.toHex = function() {
    return self.encode(this.toBytes(), "hex").toUpperCase();
  };
  /** @type {function(!Object, !Object): undefined} */
  module.exports = Color;
}, function(canCreateDiscussions, result, $) {
  var library = $(24);
  result.certificate = $(188);
  var set_heat_to = library.define("RSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("modulus").int(), this.key("publicExponent").int(), this.key("privateExponent").int(), this.key("prime1").int(), this.key("prime2").int(), this.key("exponent1").int(), this.key("exponent2").int(), this.key("coefficient").int());
  });
  result.RSAPrivateKey = set_heat_to;
  var bad_format = library.define("RSAPublicKey", function() {
    this.seq().obj(this.key("modulus").int(), this.key("publicExponent").int());
  });
  result.RSAPublicKey = bad_format;
  var public_key = library.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(B), this.key("subjectPublicKey").bitstr());
  });
  result.PublicKey = public_key;
  var B = library.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("none").null_().optional(), this.key("curve").objid().optional(), this.key("params").seq().obj(this.key("p").int(), this.key("q").int(), this.key("g").int()).optional());
  });
  var PrivateKey = library.define("PrivateKeyInfo", function() {
    this.seq().obj(this.key("version").int(), this.key("algorithm").use(B), this.key("subjectPrivateKey").octstr());
  });
  result.PrivateKey = PrivateKey;
  var $user_unavailable_error = library.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(this.key("algorithm").seq().obj(this.key("id").objid(), this.key("decrypt").seq().obj(this.key("kde").seq().obj(this.key("id").objid(), this.key("kdeparams").seq().obj(this.key("salt").octstr(), this.key("iters").int())), this.key("cipher").seq().obj(this.key("algo").objid(), this.key("iv").octstr()))), this.key("subjectPrivateKey").octstr());
  });
  result.EncryptedPrivateKey = $user_unavailable_error;
  var atomInfos = library.define("DSAPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("p").int(), this.key("q").int(), this.key("g").int(), this.key("pub_key").int(), this.key("priv_key").int());
  });
  result.DSAPrivateKey = atomInfos;
  result.DSAparam = library.define("DSAparam", function() {
    this.int();
  });
  var coreItem = library.define("ECPrivateKey", function() {
    this.seq().obj(this.key("version").int(), this.key("privateKey").octstr(), this.key("parameters").optional().explicit(0).use(data), this.key("publicKey").optional().explicit(1).bitstr());
  });
  result.ECPrivateKey = coreItem;
  var data = library.define("ECParameters", function() {
    this.choice({
      namedCurve : this.objid()
    });
  });
  result.signature = library.define("signature", function() {
    this.seq().obj(this.key("r").int(), this.key("s").int());
  });
}, function(canCreateDiscussions, Jsdc, require) {
  /**
   * @param {string} name
   * @param {!Object} tag
   * @return {undefined}
   */
  function from(name, tag) {
    /** @type {string} */
    this.name = name;
    /** @type {!Object} */
    this.body = tag;
    this.decoders = {};
    this.encoders = {};
  }
  var asn1 = require(24);
  var expect = require(1);
  /**
   * @param {string} item
   * @param {!Function} deps
   * @return {?}
   */
  Jsdc.define = function(item, deps) {
    return new from(item, deps);
  };
  /**
   * @param {!Function} b
   * @return {?}
   */
  from.prototype._createNamed = function(b) {
    var named;
    try {
      named = require(180).runInThisContext("(function " + this.name + "(entity) {\n  this._initNamed(entity);\n})");
    } catch (n) {
      /**
       * @param {?} e
       * @return {undefined}
       */
      named = function(e) {
        this._initNamed(e);
      };
    }
    return expect(named, b), named.prototype._initNamed = function(e) {
      b.call(this, e);
    }, new named(this);
  };
  /**
   * @param {string} enc
   * @return {?}
   */
  from.prototype._getDecoder = function(enc) {
    return enc = enc || "der", this.decoders.hasOwnProperty(enc) || (this.decoders[enc] = this._createNamed(asn1.decoders[enc])), this.decoders[enc];
  };
  /**
   * @param {string} value
   * @param {string} enc
   * @param {string} options
   * @return {?}
   */
  from.prototype.decode = function(value, enc, options) {
    return this._getDecoder(enc).decode(value, options);
  };
  /**
   * @param {string} enc
   * @return {?}
   */
  from.prototype._getEncoder = function(enc) {
    return enc = enc || "der", this.encoders.hasOwnProperty(enc) || (this.encoders[enc] = this._createNamed(asn1.encoders[enc])), this.encoders[enc];
  };
  /**
   * @param {!Array} data
   * @param {string} options
   * @param {boolean} json
   * @return {?}
   */
  from.prototype.encode = function(data, options, json) {
    return this._getEncoder(options).encode(data, json);
  };
}, function(module$jscomp$0, exports$jscomp$0) {
  /**
   * @return {undefined}
   */
  function Context$jscomp$0() {
  }
  /**
   * @param {!Array} string
   * @param {string} key
   * @return {?}
   */
  var indexOf$jscomp$0 = function(string, key) {
    if (string.indexOf) {
      return string.indexOf(key);
    }
    /** @type {number} */
    var index = 0;
    for (; index < string.length; index++) {
      if (string[index] === key) {
        return index;
      }
    }
    return -1;
  };
  /**
   * @param {!Object} obj
   * @return {?}
   */
  var Object_keys$jscomp$0 = function(obj) {
    if (Object.keys) {
      return Object.keys(obj);
    }
    /** @type {!Array} */
    var result = [];
    var key;
    for (key in obj) {
      result.push(key);
    }
    return result;
  };
  /**
   * @param {!Array} array
   * @param {!Function} fn
   * @return {?}
   */
  var forEach$jscomp$0 = function(array, fn) {
    if (array.forEach) {
      return array.forEach(fn);
    }
    /** @type {number} */
    var i = 0;
    for (; i < array.length; i++) {
      fn(array[i], i, array);
    }
  };
  var defineProp$jscomp$0 = function() {
    try {
      return Object.defineProperty({}, "_", {}), function(BeautifulProperties, commonVar, command_module_id) {
        Object.defineProperty(BeautifulProperties, commonVar, {
          writable : true,
          enumerable : false,
          configurable : true,
          value : command_module_id
        });
      };
    } catch (e) {
      return function(args, callbackArgumentIndex, withoutSuffix) {
        args[callbackArgumentIndex] = withoutSuffix;
      };
    }
  }();
  /** @type {!Array} */
  var globals$jscomp$0 = ["Array", "Boolean", "Date", "Error", "EvalError", "Function", "Infinity", "JSON", "Math", "NaN", "Number", "Object", "RangeError", "ReferenceError", "RegExp", "String", "SyntaxError", "TypeError", "URIError", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "undefined", "unescape"];
  Context$jscomp$0.prototype = {};
  /** @type {function(string): ?} */
  var Script$jscomp$0 = exports$jscomp$0.Script = function(code) {
    if (!(this instanceof Script$jscomp$0)) {
      return new Script$jscomp$0(code);
    }
    /** @type {string} */
    this.code = code;
  };
  /**
   * @param {!Object} context
   * @return {?}
   */
  Script$jscomp$0.prototype.runInContext = function(context) {
    if (!(context instanceof Context$jscomp$0)) {
      throw new TypeError("needs a 'context' argument.");
    }
    /** @type {!Element} */
    var iframe = document.createElement("iframe");
    if (!iframe.style) {
      iframe.style = {};
    }
    /** @type {string} */
    iframe.style.display = "none";
    document.body.appendChild(iframe);
    var win = iframe.contentWindow;
    var wEval = win.eval;
    var wExecScript = win.execScript;
    if (!wEval && wExecScript) {
      wExecScript.call(win, "null");
      wEval = win.eval;
    }
    forEach$jscomp$0(Object_keys$jscomp$0(context), function(k) {
      win[k] = context[k];
    });
    forEach$jscomp$0(globals$jscomp$0, function(k) {
      if (context[k]) {
        win[k] = context[k];
      }
    });
    var fn = Object_keys$jscomp$0(win);
    var res = wEval.call(win, this.code);
    return forEach$jscomp$0(Object_keys$jscomp$0(win), function(key) {
      if (key in context || -1 === indexOf$jscomp$0(fn, key)) {
        context[key] = win[key];
      }
    }), forEach$jscomp$0(globals$jscomp$0, function(key) {
      if (!(key in context)) {
        defineProp$jscomp$0(context, key, win[key]);
      }
    }), document.body.removeChild(iframe), res;
  };
  /**
   * @return {?}
   */
  Script$jscomp$0.prototype.runInThisContext = function() {
    return eval(this.code);
  };
  /**
   * @param {!Object} sandbox
   * @return {?}
   */
  Script$jscomp$0.prototype.runInNewContext = function(sandbox) {
    var context = Script$jscomp$0.createContext(sandbox);
    var res = this.runInContext(context);
    return sandbox && forEach$jscomp$0(Object_keys$jscomp$0(context), function(k) {
      sandbox[k] = context[k];
    }), res;
  };
  forEach$jscomp$0(Object_keys$jscomp$0(Script$jscomp$0.prototype), function(name) {
    /** @type {function(string): ?} */
    exports$jscomp$0[name] = Script$jscomp$0[name] = function(code) {
      var s = Script$jscomp$0(code);
      return s[name].apply(s, [].slice.call(arguments, 1));
    };
  });
  /**
   * @param {!AudioNode} context
   * @return {?}
   */
  exports$jscomp$0.isContext = function(context) {
    return context instanceof Context$jscomp$0;
  };
  /**
   * @param {string} code
   * @return {?}
   */
  exports$jscomp$0.createScript = function(code) {
    return exports$jscomp$0.Script(code);
  };
  /** @type {function(!Object): ?} */
  exports$jscomp$0.createContext = Script$jscomp$0.createContext = function(context) {
    var maskedContext = new Context$jscomp$0;
    return "object" === typeof context && forEach$jscomp$0(Object_keys$jscomp$0(context), function(contextName) {
      maskedContext[contextName] = context[contextName];
    }), maskedContext;
  };
}, function(canCreateDiscussions, cellPB, getCb) {
  /**
   * @param {string} options
   * @return {undefined}
   */
  function o(options) {
    this._reporterState = {
      obj : null,
      path : [],
      options : options || {},
      errors : []
    };
  }
  /**
   * @param {string} filepath
   * @param {string} msg
   * @return {undefined}
   */
  function fn(filepath, msg) {
    /** @type {string} */
    this.path = filepath;
    this.rethrow(msg);
  }
  var cb = getCb(1);
  /** @type {function(string): undefined} */
  cellPB.Reporter = o;
  /**
   * @param {string} obj
   * @return {?}
   */
  o.prototype.isError = function(obj) {
    return obj instanceof fn;
  };
  /**
   * @return {?}
   */
  o.prototype.save = function() {
    var state = this._reporterState;
    return {
      obj : state.obj,
      pathLen : state.path.length
    };
  };
  /**
   * @param {!Object} data
   * @return {undefined}
   */
  o.prototype.restore = function(data) {
    var state = this._reporterState;
    state.obj = data.obj;
    state.path = state.path.slice(0, data.pathLen);
  };
  /**
   * @param {!Object} key
   * @return {?}
   */
  o.prototype.enterKey = function(key) {
    return this._reporterState.path.push(key);
  };
  /**
   * @param {number} index
   * @return {undefined}
   */
  o.prototype.exitKey = function(index) {
    var state = this._reporterState;
    state.path = state.path.slice(0, index - 1);
  };
  /**
   * @param {!Array} index
   * @param {?} value
   * @param {(number|string)} key
   * @return {undefined}
   */
  o.prototype.leaveKey = function(index, value, key) {
    var state = this._reporterState;
    this.exitKey(index);
    if (null !== state.obj) {
      /** @type {(number|string)} */
      state.obj[value] = key;
    }
  };
  /**
   * @return {?}
   */
  o.prototype.path = function() {
    return this._reporterState.path.join("/");
  };
  /**
   * @return {?}
   */
  o.prototype.enterObject = function() {
    var state = this._reporterState;
    var id = state.obj;
    return state.obj = {}, id;
  };
  /**
   * @param {!Object} prev
   * @return {?}
   */
  o.prototype.leaveObject = function(prev) {
    var state = this._reporterState;
    var id = state.obj;
    return state.obj = prev, id;
  };
  /**
   * @param {string} str
   * @return {?}
   */
  o.prototype.error = function(str) {
    var result;
    var state = this._reporterState;
    /** @type {boolean} */
    var flag = str instanceof fn;
    if (result = flag ? str : new fn(state.path.map(function(storedComponents) {
      return "[" + JSON.stringify(storedComponents) + "]";
    }).join(""), str.message || str, str.stack), !state.options.partial) {
      throw result;
    }
    return flag || state.errors.push(result), result;
  };
  /**
   * @param {string} result
   * @return {?}
   */
  o.prototype.wrapResult = function(result) {
    var state = this._reporterState;
    return state.options.partial ? {
      result : this.isError(result) ? null : result,
      errors : state.errors
    } : result;
  };
  cb(fn, Error);
  /**
   * @param {string} msg
   * @return {?}
   */
  fn.prototype.rethrow = function(msg) {
    if (this.message = msg + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, fn), !this.stack) {
      try {
        throw new Error(this.message);
      } catch (e) {
        this.stack = e.stack;
      }
    }
    return this;
  };
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @param {!Object} parent
   * @return {undefined}
   */
  function decode(key, parent) {
    var state = {};
    this._baseState = state;
    /** @type {string} */
    state.enc = key;
    state.parent = parent || null;
    /** @type {null} */
    state.children = null;
    /** @type {null} */
    state.tag = null;
    /** @type {null} */
    state.args = null;
    /** @type {null} */
    state.reverseArgs = null;
    /** @type {null} */
    state.choice = null;
    /** @type {boolean} */
    state.optional = false;
    /** @type {boolean} */
    state.any = false;
    /** @type {boolean} */
    state.obj = false;
    /** @type {null} */
    state.use = null;
    /** @type {null} */
    state.useDecoder = null;
    /** @type {null} */
    state.key = null;
    /** @type {null} */
    state.default = null;
    /** @type {null} */
    state.explicit = null;
    /** @type {null} */
    state.implicit = null;
    /** @type {null} */
    state.contains = null;
    if (!state.parent) {
      /** @type {!Array} */
      state.children = [];
      this._wrap();
    }
  }
  var Reporter = require(25).Reporter;
  var HtmlAttribute = require(25).EncoderBuffer;
  var Uint8Array = require(25).DecoderBuffer;
  var assert = require(6);
  /** @type {!Array} */
  var specs = ["seq", "seqof", "set", "setof", "objid", "bool", "gentime", "utctime", "null_", "enum", "int", "objDesc", "bitstr", "bmpstr", "charstr", "genstr", "graphstr", "ia5str", "iso646str", "numstr", "octstr", "printstr", "t61str", "unistr", "utf8str", "videostr"];
  /** @type {!Array<?>} */
  var linkSpecs = ["key", "obj", "use", "optional", "explicit", "implicit", "def", "choice", "any", "contains"].concat(specs);
  /** @type {function(string, !Object): undefined} */
  module.exports = decode;
  /** @type {!Array} */
  var extraFields = ["enc", "parent", "children", "tag", "args", "reverseArgs", "choice", "optional", "any", "obj", "use", "alteredUse", "key", "default", "explicit", "implicit", "contains"];
  /**
   * @return {?}
   */
  decode.prototype.clone = function() {
    var state = this._baseState;
    var cstate = {};
    extraFields.forEach(function(prop) {
      cstate[prop] = state[prop];
    });
    var res = new this.constructor(cstate.parent);
    return res._baseState = cstate, res;
  };
  /**
   * @return {undefined}
   */
  decode.prototype._wrap = function() {
    var state = this._baseState;
    linkSpecs.forEach(function(pos) {
      /**
       * @return {?}
       */
      this[pos] = function() {
        var list = new this.constructor(this);
        return state.children.push(list), list[pos].apply(list, arguments);
      };
    }, this);
  };
  /**
   * @param {!Function} selector
   * @return {undefined}
   */
  decode.prototype._init = function(selector) {
    var state = this._baseState;
    assert(null === state.parent);
    selector.call(this);
    state.children = state.children.filter(function(child) {
      return child._baseState.parent === this;
    }, this);
    assert.equal(state.children.length, 1, "Root node can have only one child");
  };
  /**
   * @param {!Object} a
   * @return {undefined}
   */
  decode.prototype._useArgs = function(a) {
    var state = this._baseState;
    var children = a.filter(function(figure) {
      return figure instanceof this.constructor;
    }, this);
    a = a.filter(function(figure) {
      return !(figure instanceof this.constructor);
    }, this);
    if (0 !== children.length) {
      assert(null === state.children);
      state.children = children;
      children.forEach(function(child) {
        child._baseState.parent = this;
      }, this);
    }
    if (0 !== a.length) {
      assert(null === state.args);
      /** @type {!Object} */
      state.args = a;
      state.reverseArgs = a.map(function(data) {
        if ("object" !== typeof data || data.constructor !== Object) {
          return data;
        }
        var entry = {};
        return Object.keys(data).forEach(function(value) {
          if (value == (0 | value)) {
            /** @type {number} */
            value = value | 0;
          }
          var component = data[value];
          /** @type {string} */
          entry[component] = value;
        }), entry;
      });
    }
  };
  ["_peekTag", "_decodeTag", "_use", "_decodeStr", "_decodeObjid", "_decodeTime", "_decodeNull", "_decodeInt", "_decodeBool", "_decodeList", "_encodeComposite", "_encodeStr", "_encodeObjid", "_encodeTime", "_encodeNull", "_encodeInt", "_encodeBool"].forEach(function(method) {
    /**
     * @return {undefined}
     */
    decode.prototype[method] = function() {
      var state = this._baseState;
      throw new Error(method + " not implemented for encoding: " + state.enc);
    };
  });
  specs.forEach(function(i) {
    /**
     * @return {?}
     */
    decode.prototype[i] = function() {
      var state = this._baseState;
      /** @type {!Array<?>} */
      var args = Array.prototype.slice.call(arguments);
      return assert(null === state.tag), state.tag = i, this._useArgs(args), this;
    };
  });
  /**
   * @param {string} key
   * @return {?}
   */
  decode.prototype.use = function(key) {
    assert(key);
    var state = this._baseState;
    return assert(null === state.use), state.use = key, this;
  };
  /**
   * @return {?}
   */
  decode.prototype.optional = function() {
    return this._baseState.optional = true, this;
  };
  /**
   * @param {string} def
   * @return {?}
   */
  decode.prototype.def = function(def) {
    var state = this._baseState;
    return assert(null === state.default), state.default = def, state.optional = true, this;
  };
  /**
   * @param {string} value
   * @return {?}
   */
  decode.prototype.explicit = function(value) {
    var state = this._baseState;
    return assert(null === state.explicit && null === state.implicit), state.explicit = value, this;
  };
  /**
   * @param {string} key
   * @return {?}
   */
  decode.prototype.implicit = function(key) {
    var state = this._baseState;
    return assert(null === state.explicit && null === state.implicit), state.implicit = key, this;
  };
  /**
   * @return {?}
   */
  decode.prototype.obj = function() {
    var state = this._baseState;
    /** @type {!Array<?>} */
    var args = Array.prototype.slice.call(arguments);
    return state.obj = true, 0 !== args.length && this._useArgs(args), this;
  };
  /**
   * @param {string} key
   * @return {?}
   */
  decode.prototype.key = function(key) {
    var state = this._baseState;
    return assert(null === state.key), state.key = key, this;
  };
  /**
   * @return {?}
   */
  decode.prototype.any = function() {
    return this._baseState.any = true, this;
  };
  /**
   * @param {!Object} obj
   * @return {?}
   */
  decode.prototype.choice = function(obj) {
    var state = this._baseState;
    return assert(null === state.choice), state.choice = obj, this._useArgs(Object.keys(obj).map(function(sourcePropKey) {
      return obj[sourcePropKey];
    })), this;
  };
  /**
   * @param {!HTMLElement} item
   * @return {?}
   */
  decode.prototype.contains = function(item) {
    var state = this._baseState;
    return assert(null === state.use), state.contains = item, this;
  };
  /**
   * @param {!Object} input
   * @param {!Object} data
   * @return {?}
   */
  decode.prototype._decode = function(input, data) {
    var state = this._baseState;
    if (null === state.parent) {
      return input.wrapResult(state.children[0]._decode(input, data));
    }
    var prevObj;
    var result = state.default;
    /** @type {boolean} */
    var present = true;
    /** @type {null} */
    var prevKey = null;
    if (null !== state.key && (prevKey = input.enterKey(state.key)), state.optional) {
      /** @type {null} */
      var tag = null;
      if (null !== state.explicit ? tag = state.explicit : null !== state.implicit ? tag = state.implicit : null !== state.tag && (tag = state.tag), null !== tag || state.any) {
        if (present = this._peekTag(input, tag, state.any), input.isError(present)) {
          return present;
        }
      } else {
        var save = input.save();
        try {
          if (null === state.choice) {
            this._decodeGeneric(state.tag, input, data);
          } else {
            this._decodeChoice(input, data);
          }
          /** @type {boolean} */
          present = true;
        } catch (p) {
          /** @type {boolean} */
          present = false;
        }
        input.restore(save);
      }
    }
    if (state.obj && present && (prevObj = input.enterObject()), present) {
      if (null !== state.explicit) {
        var explicit = this._decodeTag(input, state.explicit);
        if (input.isError(explicit)) {
          return explicit;
        }
        input = explicit;
      }
      var start = input.offset;
      if (null === state.use && null === state.choice) {
        if (state.any) {
          save = input.save();
        }
        var explicit = this._decodeTag(input, null !== state.implicit ? state.implicit : state.tag, state.any);
        if (input.isError(explicit)) {
          return explicit;
        }
        if (state.any) {
          result = input.raw(save);
        } else {
          input = explicit;
        }
      }
      if (data && data.track && null !== state.tag && data.track(input.path(), start, input.length, "tagged"), data && data.track && null !== state.tag && data.track(input.path(), input.offset, input.length, "content"), result = state.any ? result : null === state.choice ? this._decodeGeneric(state.tag, input, data) : this._decodeChoice(input, data), input.isError(result)) {
        return result;
      }
      if (state.any || null !== state.choice || null === state.children || state.children.forEach(function(child) {
        child._decode(input, data);
      }), state.contains && ("octstr" === state.tag || "bitstr" === state.tag)) {
        var value = new Uint8Array(result);
        result = this._getUse(state.contains, input._reporterState.obj)._decode(value, data);
      }
    }
    return state.obj && present && (result = input.leaveObject(prevObj)), null === state.key || null === result && true !== present ? null !== prevKey && input.exitKey(prevKey) : input.leaveKey(prevKey, state.key, result), result;
  };
  /**
   * @param {string} undefined
   * @param {!Object} input
   * @param {!Object} options
   * @return {?}
   */
  decode.prototype._decodeGeneric = function(undefined, input, options) {
    var state = this._baseState;
    return "seq" === undefined || "set" === undefined ? null : "seqof" === undefined || "setof" === undefined ? this._decodeList(input, undefined, state.args[0], options) : /str$/.test(undefined) ? this._decodeStr(input, undefined, options) : "objid" === undefined && state.args ? this._decodeObjid(input, state.args[0], state.args[1], options) : "objid" === undefined ? this._decodeObjid(input, null, null, options) : "gentime" === undefined || "utctime" === undefined ? this._decodeTime(input, undefined, 
    options) : "null_" === undefined ? this._decodeNull(input, options) : "bool" === undefined ? this._decodeBool(input, options) : "objDesc" === undefined ? this._decodeStr(input, undefined, options) : "int" === undefined || "enum" === undefined ? this._decodeInt(input, state.args && state.args[0], options) : null !== state.use ? this._getUse(state.use, input._reporterState.obj)._decode(input, options) : input.error("unknown tag: " + undefined);
  };
  /**
   * @param {!Function} entity
   * @param {!Array} obj
   * @return {?}
   */
  decode.prototype._getUse = function(entity, obj) {
    var state = this._baseState;
    return state.useDecoder = this._use(entity, obj), assert(null === state.useDecoder._baseState.parent), state.useDecoder = state.useDecoder._baseState.children[0], state.implicit !== state.useDecoder._baseState.implicit && (state.useDecoder = state.useDecoder.clone(), state.useDecoder._baseState.implicit = state.implicit), state.useDecoder;
  };
  /**
   * @param {!Object} input
   * @param {!Object} callback
   * @return {?}
   */
  decode.prototype._decodeChoice = function(input, callback) {
    var state = this._baseState;
    /** @type {null} */
    var val = null;
    /** @type {boolean} */
    var orie = false;
    return Object.keys(state.choice).some(function(key) {
      var save = input.save();
      var node = state.choice[key];
      try {
        var result = node._decode(input, callback);
        if (input.isError(result)) {
          return false;
        }
        val = {
          type : key,
          value : result
        };
        /** @type {boolean} */
        orie = true;
      } catch (u) {
        return input.restore(save), false;
      }
      return true;
    }, this), orie ? val : input.error("Choice not matched");
  };
  /**
   * @param {!Object} name
   * @return {?}
   */
  decode.prototype._createEncoderBuffer = function(name) {
    return new HtmlAttribute(name, this.reporter);
  };
  /**
   * @param {?} value
   * @param {!Object} reporter
   * @param {!Array} parent
   * @return {?}
   */
  decode.prototype._encode = function(value, reporter, parent) {
    var state = this._baseState;
    if (null === state.default || state.default !== value) {
      var result = this._encodeValue(value, reporter, parent);
      if (void 0 !== result && !this._skipDefault(result, reporter, parent)) {
        return result;
      }
    }
  };
  /**
   * @param {!Array} data
   * @param {!Object} reporter
   * @param {!Array} parent
   * @return {?}
   */
  decode.prototype._encodeValue = function(data, reporter, parent) {
    var state = this._baseState;
    if (null === state.parent) {
      return state.children[0]._encode(data, reporter || new Reporter);
    }
    /** @type {null} */
    var result = null;
    if (this.reporter = reporter, state.optional && void 0 === data) {
      if (null === state.default) {
        return;
      }
      data = state.default;
    }
    /** @type {null} */
    var content = null;
    /** @type {boolean} */
    var primitive = false;
    if (state.any) {
      result = this._createEncoderBuffer(data);
    } else {
      if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else {
        if (state.contains) {
          content = this._getUse(state.contains, parent)._encode(data, reporter);
          /** @type {boolean} */
          primitive = true;
        } else {
          if (state.children) {
            content = state.children.map(function(child) {
              if ("null_" === child._baseState.tag) {
                return child._encode(null, reporter, data);
              }
              if (null === child._baseState.key) {
                return reporter.error("Child should have a key");
              }
              var prevKey = reporter.enterKey(child._baseState.key);
              if ("object" !== typeof data) {
                return reporter.error("Child expected, but input is not object");
              }
              var res = child._encode(data[child._baseState.key], reporter, data);
              return reporter.leaveKey(prevKey), res;
            }, this).filter(function(canCreateDiscussions) {
              return canCreateDiscussions;
            });
            content = this._createEncoderBuffer(content);
          } else {
            if ("seqof" === state.tag || "setof" === state.tag) {
              if (!state.args || 1 !== state.args.length) {
                return reporter.error("Too many args for : " + state.tag);
              }
              if (!Array.isArray(data)) {
                return reporter.error("seqof/setof, but data is not Array");
              }
              var child = this.clone();
              /** @type {null} */
              child._baseState.implicit = null;
              content = this._createEncoderBuffer(data.map(function(key) {
                var state = this._baseState;
                return this._getUse(state.args[0], data)._encode(key, reporter);
              }, child));
            } else {
              if (null !== state.use) {
                result = this._getUse(state.use, parent)._encode(data, reporter);
              } else {
                content = this._encodePrimitive(state.tag, data);
                /** @type {boolean} */
                primitive = true;
              }
            }
          }
        }
      }
    }
    if (!state.any && null === state.choice) {
      var tag = null !== state.implicit ? state.implicit : state.tag;
      /** @type {string} */
      var cls = null === state.implicit ? "universal" : "context";
      if (null === tag) {
        if (null === state.use) {
          reporter.error("Tag could be omitted only for .use()");
        }
      } else {
        if (null === state.use) {
          result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
    }
    return null !== state.explicit && (result = this._encodeComposite(state.explicit, false, "context", result)), result;
  };
  /**
   * @param {!Object} data
   * @param {!Object} reporter
   * @return {?}
   */
  decode.prototype._encodeChoice = function(data, reporter) {
    var state = this._baseState;
    var node = state.choice[data.type];
    return node || assert(false, data.type + " not found in " + JSON.stringify(Object.keys(state.choice))), node._encode(data.value, reporter);
  };
  /**
   * @param {string} tag
   * @param {boolean} data
   * @return {?}
   */
  decode.prototype._encodePrimitive = function(tag, data) {
    var state = this._baseState;
    if (/str$/.test(tag)) {
      return this._encodeStr(data, tag);
    }
    if ("objid" === tag && state.args) {
      return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
    }
    if ("objid" === tag) {
      return this._encodeObjid(data, null, null);
    }
    if ("gentime" === tag || "utctime" === tag) {
      return this._encodeTime(data, tag);
    }
    if ("null_" === tag) {
      return this._encodeNull();
    }
    if ("int" === tag || "enum" === tag) {
      return this._encodeInt(data, state.args && state.reverseArgs[0]);
    }
    if ("bool" === tag) {
      return this._encodeBool(data);
    }
    if ("objDesc" === tag) {
      return this._encodeStr(data, tag);
    }
    throw new Error("Unsupported tag: " + tag);
  };
  /**
   * @param {boolean} strVal
   * @return {?}
   */
  decode.prototype._isNumstr = function(strVal) {
    return /^[0-9 ]*$/.test(strVal);
  };
  /**
   * @param {boolean} strVal
   * @return {?}
   */
  decode.prototype._isPrintstr = function(strVal) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(strVal);
  };
}, function(canCreateDiscussions, data, context) {
  var that = context(95);
  data.tagClass = {
    0 : "universal",
    1 : "application",
    2 : "context",
    3 : "private"
  };
  data.tagClassByName = that._reverse(data.tagClass);
  data.tag = {
    0 : "end",
    1 : "bool",
    2 : "int",
    3 : "bitstr",
    4 : "octstr",
    5 : "null_",
    6 : "objid",
    7 : "objDesc",
    8 : "external",
    9 : "real",
    10 : "enum",
    11 : "embed",
    12 : "utf8str",
    13 : "relativeOid",
    16 : "seq",
    17 : "set",
    18 : "numstr",
    19 : "printstr",
    20 : "t61str",
    21 : "videostr",
    22 : "ia5str",
    23 : "utctime",
    24 : "gentime",
    25 : "graphstr",
    26 : "iso646str",
    27 : "genstr",
    28 : "unistr",
    29 : "charstr",
    30 : "bmpstr"
  };
  data.tagByName = that._reverse(data.tag);
}, function(canCreateDiscussions, rawtype, manip) {
  var r = rawtype;
  r.der = manip(96);
  r.pem = manip(185);
}, function(module, canCreateDiscussions, require) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function PEMDecoder(key) {
    proto.call(this, key);
    /** @type {string} */
    this.enc = "pem";
  }
  var inherits = require(1);
  var Buffer = require(3).Buffer;
  var proto = require(96);
  inherits(PEMDecoder, proto);
  /** @type {function(string): undefined} */
  module.exports = PEMDecoder;
  /**
   * @param {string} string
   * @param {!Object} options
   * @return {?}
   */
  PEMDecoder.prototype.decode = function(string, options) {
    var t = string.toString().split(/[\r\n]+/g);
    var targetChar = options.label.toUpperCase();
    /** @type {!RegExp} */
    var rDataName = /^-----(BEGIN|END) ([^-]+)-----$/;
    /** @type {number} */
    var min = -1;
    /** @type {number} */
    var max = -1;
    /** @type {number} */
    var j = 0;
    for (; j < t.length; j++) {
      var conformedValue = t[j].match(rDataName);
      if (null !== conformedValue && conformedValue[2] === targetChar) {
        if (-1 !== min) {
          if ("END" !== conformedValue[1]) {
            break;
          }
          /** @type {number} */
          max = j;
          break;
        }
        if ("BEGIN" !== conformedValue[1]) {
          break;
        }
        /** @type {number} */
        min = j;
      }
    }
    if (-1 === min || -1 === max) {
      throw new Error("PEM section not found for: " + targetChar);
    }
    var message = t.slice(min + 1, max).join("");
    message.replace(/[^a-z0-9\+\/=]+/gi, "");
    var data = new Buffer(message, "base64");
    return proto.prototype.decode.call(this, data, options);
  };
}, function(canCreateDiscussions, rawtype, manip) {
  var r = rawtype;
  r.der = manip(97);
  r.pem = manip(187);
}, function(module, canCreateDiscussions, r) {
  /**
   * @param {string} key
   * @return {undefined}
   */
  function PEMEncoder(key) {
    i.call(this, key);
    /** @type {string} */
    this.enc = "pem";
  }
  var path = r(1);
  var i = r(97);
  path(PEMEncoder, i);
  /** @type {function(string): undefined} */
  module.exports = PEMEncoder;
  /**
   * @param {!Array} v
   * @param {?} options
   * @return {?}
   */
  PEMEncoder.prototype.encode = function(v, options) {
    var p = i.prototype.encode.call(this, v).toString("base64");
    /** @type {!Array} */
    var out = ["-----BEGIN " + options.label + "-----"];
    /** @type {number} */
    var pos = 0;
    for (; pos < p.length; pos = pos + 64) {
      out.push(p.slice(pos, pos + 64));
    }
    return out.push("-----END " + options.label + "-----"), out.join("\n");
  };
}, function(module, canCreateDiscussions, require) {
  var Locale = require(24);
  var B = Locale.define("Time", function() {
    this.choice({
      utcTime : this.utctime(),
      generalTime : this.gentime()
    });
  });
  var artistTrack = Locale.define("AttributeTypeValue", function() {
    this.seq().obj(this.key("type").objid(), this.key("value").any());
  });
  var data = Locale.define("AlgorithmIdentifier", function() {
    this.seq().obj(this.key("algorithm").objid(), this.key("parameters").optional(), this.key("curve").objid().optional());
  });
  var s = Locale.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(this.key("algorithm").use(data), this.key("subjectPublicKey").bitstr());
  });
  var GET_AUTH_URL_TIMEOUT = Locale.define("RelativeDistinguishedName", function() {
    this.setof(artistTrack);
  });
  var handle = Locale.define("RDNSequence", function() {
    this.seqof(GET_AUTH_URL_TIMEOUT);
  });
  var f = Locale.define("Name", function() {
    this.choice({
      rdnSequence : this.use(handle)
    });
  });
  var opts = Locale.define("Validity", function() {
    this.seq().obj(this.key("notBefore").use(B), this.key("notAfter").use(B));
  });
  var Int = Locale.define("Extension", function() {
    this.seq().obj(this.key("extnID").objid(), this.key("critical").bool().def(false), this.key("extnValue").octstr());
  });
  var S = Locale.define("TBSCertificate", function() {
    this.seq().obj(this.key("version").explicit(0).int().optional(), this.key("serialNumber").int(), this.key("signature").use(data), this.key("issuer").use(f), this.key("validity").use(opts), this.key("subject").use(f), this.key("subjectPublicKeyInfo").use(s), this.key("issuerUniqueID").implicit(1).bitstr().optional(), this.key("subjectUniqueID").implicit(2).bitstr().optional(), this.key("extensions").explicit(3).seqof(Int).optional());
  });
  var storeMixin = Locale.define("X509Certificate", function() {
    this.seq().obj(this.key("tbsCertificate").use(S), this.key("signatureAlgorithm").use(data), this.key("signatureValue").bitstr());
  });
  module.exports = storeMixin;
}, function(mixin) {
  /** @type {*} */
  mixin.exports = JSON.parse('{"2.16.840.1.101.3.4.1.1":"aes-128-ecb","2.16.840.1.101.3.4.1.2":"aes-128-cbc","2.16.840.1.101.3.4.1.3":"aes-128-ofb","2.16.840.1.101.3.4.1.4":"aes-128-cfb","2.16.840.1.101.3.4.1.21":"aes-192-ecb","2.16.840.1.101.3.4.1.22":"aes-192-cbc","2.16.840.1.101.3.4.1.23":"aes-192-ofb","2.16.840.1.101.3.4.1.24":"aes-192-cfb","2.16.840.1.101.3.4.1.41":"aes-256-ecb","2.16.840.1.101.3.4.1.42":"aes-256-cbc","2.16.840.1.101.3.4.1.43":"aes-256-ofb","2.16.840.1.101.3.4.1.44":"aes-256-cfb"}');
}, function(mixin, canCreateDiscussions, __webpack_require__) {
  /** @type {!RegExp} */
  var reHeader = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r\+\/=]+)[\n\r]+/m;
  /** @type {!RegExp} */
  var multiLineCommentRegEx = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
  /** @type {!RegExp} */
  var FN_ARGS_FUNCTION = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r\+\/=]+)-----END \1-----$/m;
  var create = __webpack_require__(32);
  var crypto = __webpack_require__(46);
  var Buffer = __webpack_require__(2).Buffer;
  /**
   * @param {string} key
   * @param {string} index
   * @return {?}
   */
  mixin.exports = function(key, index) {
    var responseData;
    var tplFragment = key.toString();
    var match = tplFragment.match(reHeader);
    if (match) {
      var suite = "aes" + match[1];
      var iv = Buffer.from(match[2], "hex");
      var value = Buffer.from(match[3].replace(/[\r\n]/g, ""), "base64");
      var key = create(index, iv.slice(0, 8), parseInt(match[1], 10)).key;
      /** @type {!Array} */
      var body = [];
      var cipher = crypto.createDecipheriv(suite, key, iv);
      body.push(cipher.update(value));
      body.push(cipher.final());
      responseData = Buffer.concat(body);
    } else {
      var charcompOutput = tplFragment.match(FN_ARGS_FUNCTION);
      responseData = new Buffer(charcompOutput[2].replace(/[\r\n]/g, ""), "base64");
    }
    return {
      tag : tplFragment.match(multiLineCommentRegEx)[1],
      data : responseData
    };
  };
}, function(mixin, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {!Object} a
     * @param {!Object} b
     * @return {undefined}
     */
    function checkValue(a, b) {
      if (a.cmpn(0) <= 0) {
        throw new Error("invalid sig");
      }
      if (a.cmp(b) >= b) {
        throw new Error("invalid sig");
      }
    }
    var BN = require(4);
    var CompileContext = require(50).ec;
    var parseKeys = require(34);
    var DataSources = require(98);
    /**
     * @param {string} data
     * @param {string} value
     * @param {string} key
     * @param {undefined} url
     * @param {?} blob
     * @return {?}
     */
    mixin.exports = function(data, value, key, url, blob) {
      var pub = parseKeys(key);
      if ("ec" === pub.type) {
        if ("ecdsa" !== url && "ecdsa/rsa" !== url) {
          throw new Error("wrong public key type");
        }
        return function(sig, msg, pub) {
          var src = DataSources[pub.data.algorithm.curve.join(".")];
          if (!src) {
            throw new Error("unknown curve " + pub.data.algorithm.curve.join("."));
          }
          var ecdsa = new CompileContext(src);
          var pubkey = pub.data.subjectPrivateKey.data;
          return ecdsa.verify(msg, sig, pubkey);
        }(data, value, pub);
      }
      if ("dsa" === pub.type) {
        if ("dsa" !== url) {
          throw new Error("wrong public key type");
        }
        return function(e, hash, pub) {
          var p = pub.data.p;
          var q = pub.data.q;
          var g = pub.data.g;
          var y = pub.data.pub_key;
          var c = parseKeys.signature.decode(e, "der");
          var s = c.s;
          var r = c.r;
          checkValue(s, q);
          checkValue(r, q);
          var montp = BN.mont(p);
          var m = s.invm(q);
          return 0 === g.toRed(montp).redPow((new BN(hash)).mul(m).mod(q)).fromRed().mul(y.toRed(montp).redPow(r.mul(m).mod(q)).fromRed()).mod(p).mod(q).cmp(r);
        }(data, value, pub);
      }
      if ("rsa" !== url && "ecdsa/rsa" !== url) {
        throw new Error("wrong public key type");
      }
      value = Buffer.concat([blob, value]);
      var numPoistiveTicks = pub.modulus.byteLength();
      /** @type {!Array} */
      var result = [1];
      /** @type {number} */
      var p = 0;
      for (; value.length + result.length + 2 < numPoistiveTicks;) {
        result.push(255);
        p++;
      }
      result.push(0);
      /** @type {number} */
      var i = -1;
      for (; ++i < value.length;) {
        result.push(value[i]);
      }
      result = new Buffer(result);
      var xml = BN.mont(pub.modulus);
      data = (data = (new BN(data)).toRed(xml)).redPow(new BN(pub.publicExponent));
      data = new Buffer(data.fromRed().toArray());
      /** @type {number} */
      var y = p < 8 ? 1 : 0;
      /** @type {number} */
      numPoistiveTicks = Math.min(data.length, result.length);
      if (data.length !== result.length) {
        /** @type {number} */
        y = 1;
      }
      /** @type {number} */
      i = -1;
      for (; ++i < numPoistiveTicks;) {
        /** @type {number} */
        y = y | data[i] ^ result[i];
      }
      return 0 === y;
    };
  }).call(this, require(3).Buffer);
}, function(mixin, canCreateDiscussions, require) {
  (function(Buffer) {
    /**
     * @param {string} curve
     * @return {undefined}
     */
    function ECDH(curve) {
      this.curveType = aliases[curve];
      if (!this.curveType) {
        this.curveType = {
          name : curve
        };
      }
      this.curve = new elliptic.ec(this.curveType.name);
      this.keys = void 0;
    }
    /**
     * @param {!Array} item
     * @param {number} type
     * @param {number} len
     * @return {?}
     */
    function formatReturnValue(item, type, len) {
      if (!Array.isArray(item)) {
        item = item.toArray();
      }
      var data = new Buffer(item);
      if (len && data.length < len) {
        var zBuffer = new Buffer(len - data.length);
        zBuffer.fill(0);
        data = Buffer.concat([zBuffer, data]);
      }
      return type ? data.toString(type) : data;
    }
    var elliptic = require(50);
    var BN = require(4);
    /**
     * @param {string} key
     * @return {?}
     */
    mixin.exports = function(key) {
      return new ECDH(key);
    };
    var aliases = {
      secp256k1 : {
        name : "secp256k1",
        byteLength : 32
      },
      secp224r1 : {
        name : "p224",
        byteLength : 28
      },
      prime256v1 : {
        name : "p256",
        byteLength : 32
      },
      prime192v1 : {
        name : "p192",
        byteLength : 24
      },
      ed25519 : {
        name : "ed25519",
        byteLength : 32
      },
      secp384r1 : {
        name : "p384",
        byteLength : 48
      },
      secp521r1 : {
        name : "p521",
        byteLength : 66
      }
    };
    aliases.p224 = aliases.secp224r1;
    aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
    aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
    aliases.p384 = aliases.secp384r1;
    aliases.p521 = aliases.secp521r1;
    /**
     * @param {undefined} encoding
     * @param {string} format
     * @return {?}
     */
    ECDH.prototype.generateKeys = function(encoding, format) {
      return this.keys = this.curve.genKeyPair(), this.getPublicKey(encoding, format);
    };
    /**
     * @param {!Object} other
     * @param {string} inenc
     * @param {undefined} enc
     * @return {?}
     */
    ECDH.prototype.computeSecret = function(other, inenc, enc) {
      return inenc = inenc || "utf8", Buffer.isBuffer(other) || (other = new Buffer(other, inenc)), formatReturnValue(this.curve.keyFromPublic(other).getPublic().mul(this.keys.getPrivate()).getX(), enc, this.curveType.byteLength);
    };
    /**
     * @param {number} enc
     * @param {string} format
     * @return {?}
     */
    ECDH.prototype.getPublicKey = function(enc, format) {
      var out = this.keys.getPublic("compressed" === format, true);
      return "hybrid" === format && (out[out.length - 1] % 2 ? out[0] = 7 : out[0] = 6), formatReturnValue(out, enc);
    };
    /**
     * @param {undefined} enc
     * @return {?}
     */
    ECDH.prototype.getPrivateKey = function(enc) {
      return formatReturnValue(this.keys.getPrivate(), enc);
    };
    /**
     * @param {!Object} pub
     * @param {string} enc
     * @return {?}
     */
    ECDH.prototype.setPublicKey = function(pub, enc) {
      return enc = enc || "utf8", Buffer.isBuffer(pub) || (pub = new Buffer(pub, enc)), this.keys._importPublic(pub), this;
    };
    /**
     * @param {!Object} data
     * @param {string} encoding
     * @return {?}
     */
    ECDH.prototype.setPrivateKey = function(data, encoding) {
      encoding = encoding || "utf8";
      if (!Buffer.isBuffer(data)) {
        data = new Buffer(data, encoding);
      }
      var _priv = new BN(data);
      return _priv = _priv.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(_priv), this;
    };
  }).call(this, require(3).Buffer);
}, function(canCreateDiscussions, rsa, saveNotifs) {
  rsa.publicEncrypt = saveNotifs(194);
  rsa.privateDecrypt = saveNotifs(195);
  /**
   * @param {?} key
   * @param {?} buf
   * @return {?}
   */
  rsa.privateEncrypt = function(key, buf) {
    return rsa.publicEncrypt(key, buf, true);
  };
  /**
   * @param {?} key
   * @param {?} buf
   * @return {?}
   */
  rsa.publicDecrypt = function(key, buf) {
    return rsa.privateDecrypt(key, buf, true);
  };
}, function(mixin, canCreateDiscussions, require) {
  var sphereKnn = require(34);
  var round = require(16);
  var createHash = require(19);
  var add = require(99);
  var equal = require(100);
  var Error = require(4);
  var fn = require(101);
  var callback = require(49);
  var Buffer = require(2).Buffer;
  /**
   * @param {!Object} key
   * @param {string} name
   * @param {string} err
   * @return {?}
   */
  mixin.exports = function(key, name, err) {
    var d;
    d = key.padding ? key.padding : err ? 1 : 4;
    var error;
    var data = sphereKnn(key);
    if (4 === d) {
      error = function(data, value) {
        var l = data.modulus.byteLength();
        var s = value.length;
        var received = createHash("sha1").update(Buffer.alloc(0)).digest();
        var c = received.length;
        /** @type {number} */
        var d = 2 * c;
        if (s > l - d - 2) {
          throw new Error("message too long");
        }
        var appIdHash = Buffer.alloc(l - s - d - 2);
        /** @type {number} */
        var i = l - c - 1;
        var b = round(c);
        var x = equal(Buffer.concat([received, appIdHash, Buffer.alloc(1, 1), value], i), add(b, i));
        var ib = equal(b, add(x, c));
        return new Error(Buffer.concat([Buffer.alloc(1), ib, x], l));
      }(data, name);
    } else {
      if (1 === d) {
        error = function(data, value, errOrResult) {
          var decFinal;
          var end = value.length;
          var size = data.modulus.byteLength();
          if (end > size - 11) {
            throw new Error("message too long");
          }
          decFinal = errOrResult ? Buffer.alloc(size - end - 3, 255) : function(n) {
            var byte;
            var buf = Buffer.allocUnsafe(n);
            /** @type {number} */
            var index = 0;
            var b = round(2 * n);
            /** @type {number} */
            var i = 0;
            for (; index < n;) {
              if (i === b.length) {
                b = round(2 * n);
                /** @type {number} */
                i = 0;
              }
              if (byte = b[i++]) {
                buf[index++] = byte;
              }
            }
            return buf;
          }(size - end - 3);
          return new Error(Buffer.concat([Buffer.from([0, errOrResult ? 1 : 2]), decFinal, Buffer.alloc(1), value], size));
        }(data, name, err);
      } else {
        if (3 !== d) {
          throw new Error("unknown padding");
        }
        if ((error = new Error(name)).cmp(data.modulus) >= 0) {
          throw new Error("data too long for modulus");
        }
      }
    }
    return err ? callback(error, data) : fn(error, data);
  };
}, function(mixin, canCreateDiscussions, require) {
  var sphereKnn = require(34);
  var a = require(99);
  var process = require(100);
  var bn = require(4);
  var fn = require(49);
  var createHash = require(19);
  var callback = require(101);
  var Buffer = require(2).Buffer;
  /**
   * @param {!Object} key
   * @param {string} result
   * @param {string} err
   * @return {?}
   */
  mixin.exports = function(key, result, err) {
    var length;
    length = key.padding ? key.padding : err ? 1 : 4;
    var out;
    var data = sphereKnn(key);
    var size = data.modulus.byteLength();
    if (result.length > size || (new bn(result)).cmp(data.modulus) >= 0) {
      throw new Error("decryption error");
    }
    out = err ? callback(new bn(result), data) : fn(result, data);
    var appIdHash = Buffer.alloc(size - out.length);
    if (out = Buffer.concat([appIdHash, out], size), 4 === length) {
      return function(data, extension) {
        var betweenAngle = data.modulus.byteLength();
        var stickersJSON = createHash("sha1").update(Buffer.alloc(0)).digest();
        var i = stickersJSON.length;
        if (0 !== extension[0]) {
          throw new Error("decryption error");
        }
        var lines = extension.slice(1, i + 1);
        var u = extension.slice(i + 1);
        var o = process(lines, a(u, i));
        var v = process(u, a(o, betweenAngle - i - 1));
        if (function(a, b) {
          a = Buffer.from(a);
          b = Buffer.from(b);
          /** @type {number} */
          var rot = 0;
          var l = a.length;
          if (a.length !== b.length) {
            rot++;
            /** @type {number} */
            l = Math.min(a.length, b.length);
          }
          /** @type {number} */
          var i = -1;
          for (; ++i < l;) {
            /** @type {number} */
            rot = rot + (a[i] ^ b[i]);
          }
          return rot;
        }(stickersJSON, v.slice(0, i))) {
          throw new Error("decryption error");
        }
        var p = i;
        for (; 0 === v[p];) {
          p++;
        }
        if (1 !== v[p++]) {
          throw new Error("decryption error");
        }
        return v.slice(p);
      }(data, out);
    }
    if (1 === length) {
      return function(addedRenderer, val, errOrResult) {
        var prevblockidbuf = val.slice(0, 2);
        /** @type {number} */
        var i = 2;
        /** @type {number} */
        var o = 0;
        for (; 0 !== val[i++];) {
          if (i >= val.length) {
            o++;
            break;
          }
        }
        var expRecords = val.slice(2, i - 1);
        if ("0002" !== prevblockidbuf.toString("hex") && !errOrResult || "0001" !== prevblockidbuf.toString("hex") && errOrResult) {
          o++;
        }
        if (expRecords.length < 8) {
          o++;
        }
        if (o) {
          throw new Error("decryption error");
        }
        return val.slice(i);
      }(0, out, err);
    }
    if (3 === length) {
      return out;
    }
    throw new Error("unknown padding");
  };
}, function(isSlidingUp, state, __webpack_require__) {
  (function(global, process) {
    /**
     * @return {?}
     */
    function parenthetical() {
      throw new Error("secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11");
    }
    /**
     * @param {number} value
     * @param {number} c
     * @return {undefined}
     */
    function print(value, c) {
      if ("number" !== typeof value || value !== value) {
        throw new TypeError("offset must be a number");
      }
      if (value > max || value < 0) {
        throw new TypeError("offset must be a uint32");
      }
      if (value > b || value > c) {
        throw new RangeError("offset out of range");
      }
    }
    /**
     * @param {number} x
     * @param {string} v
     * @param {?} size
     * @return {undefined}
     */
    function log(x, v, size) {
      if ("number" !== typeof x || x !== x) {
        throw new TypeError("size must be a number");
      }
      if (x > max || x < 0) {
        throw new TypeError("size must be a uint32");
      }
      if (x + v > size || x > b) {
        throw new RangeError("buffer too small");
      }
    }
    /**
     * @param {!Object} value
     * @param {!Array} start
     * @param {number} size
     * @param {!Function} cb
     * @return {?}
     */
    function callback(value, start, size, cb) {
      if (process.browser) {
        var buffer = value.buffer;
        /** @type {!Uint8Array} */
        var bytes = new Uint8Array(buffer, start, size);
        return _crypto.getRandomValues(bytes), cb ? void process.nextTick(function() {
          cb(null, value);
        }) : value;
      }
      if (!cb) {
        return get(size).copy(value, start), value;
      }
      get(size, function(fallbackReleases, t) {
        if (fallbackReleases) {
          return cb(fallbackReleases);
        }
        t.copy(value, start);
        cb(null, value);
      });
    }
    var root = __webpack_require__(2);
    var get = __webpack_require__(16);
    var util = root.Buffer;
    var b = root.kMaxLength;
    var _crypto = global.crypto || global.msCrypto;
    /** @type {number} */
    var max = Math.pow(2, 32) - 1;
    if (_crypto && _crypto.getRandomValues || !process.browser) {
      /**
       * @param {!Array} data
       * @param {!Object} start
       * @param {number} size
       * @param {undefined} cb
       * @return {?}
       */
      state.randomFill = function(data, start, size, cb) {
        if (!util.isBuffer(data) && !(data instanceof global.Uint8Array)) {
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        }
        if ("function" === typeof start) {
          /** @type {!Object} */
          cb = start;
          /** @type {number} */
          start = 0;
          size = data.length;
        } else {
          if ("function" === typeof size) {
            /** @type {number} */
            cb = size;
            /** @type {number} */
            size = data.length - start;
          } else {
            if ("function" !== typeof cb) {
              throw new TypeError('"cb" argument must be a function');
            }
          }
        }
        return print(start, data.length), log(size, start, data.length), callback(data, start, size, cb);
      };
      /**
       * @param {!Array} err
       * @param {?} s
       * @param {number} e
       * @return {?}
       */
      state.randomFillSync = function(err, s, e) {
        if ("undefined" === typeof s) {
          /** @type {number} */
          s = 0;
        }
        if (!util.isBuffer(err) && !(err instanceof global.Uint8Array)) {
          throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
        }
        print(s, err.length);
        if (void 0 === e) {
          /** @type {number} */
          e = err.length - s;
        }
        return log(e, s, err.length), callback(err, s, e);
      };
    } else {
      /** @type {function(): ?} */
      state.randomFill = parenthetical;
      /** @type {function(): ?} */
      state.randomFillSync = parenthetical;
    }
  }).call(this, __webpack_require__(5), __webpack_require__(8));
}, function(canCreateDiscussions, sha1) {
  /**
   * @param {string} key
   * @param {string} data
   * @return {?}
   */
  function core_hmac_sha1(key, data) {
    var bkey = str2binb(key);
    if (bkey.length > 16) {
      bkey = core_sha1(bkey, 8 * key.length);
    }
    /** @type {!Array} */
    var ipad = Array(16);
    /** @type {!Array} */
    var opad = Array(16);
    /** @type {number} */
    var i = 0;
    for (; i < 16; i++) {
      /** @type {number} */
      ipad[i] = 909522486 ^ bkey[i];
      /** @type {number} */
      opad[i] = 1549556828 ^ bkey[i];
    }
    var hash = core_sha1(ipad.concat(str2binb(data)), 512 + 8 * data.length);
    return binb2str(core_sha1(opad.concat(hash), 672));
  }
  /**
   * @param {string} _
   * @return {?}
   */
  function next(_) {
    /** @type {string} */
    var result = "";
    var count = _.length;
    /** @type {number} */
    var i = 0;
    for (; i < count; i = i + 3) {
      /** @type {number} */
      var o = _.charCodeAt(i) << 16 | (i + 1 < count ? _.charCodeAt(i + 1) << 8 : 0) | (i + 2 < count ? _.charCodeAt(i + 2) : 0);
      /** @type {number} */
      var j = 0;
      for (; j < 4; j++) {
        if (8 * i + 6 * j > 8 * _.length) {
          /** @type {string} */
          result = result + overrideSubItems;
        } else {
          /** @type {string} */
          result = result + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(o >>> 6 * (3 - j) & 63);
        }
      }
    }
    return result;
  }
  /**
   * @param {string} str
   * @return {?}
   */
  function o(str) {
    var character;
    var r;
    /** @type {string} */
    var str = "";
    /** @type {number} */
    var i = -1;
    for (; ++i < str.length;) {
      character = str.charCodeAt(i);
      r = i + 1 < str.length ? str.charCodeAt(i + 1) : 0;
      if (55296 <= character && character <= 56319 && 56320 <= r && r <= 57343) {
        /** @type {number} */
        character = 65536 + ((1023 & character) << 10) + (1023 & r);
        i++;
      }
      if (character <= 127) {
        /** @type {string} */
        str = str + String.fromCharCode(character);
      } else {
        if (character <= 2047) {
          /** @type {string} */
          str = str + String.fromCharCode(192 | character >>> 6 & 31, 128 | 63 & character);
        } else {
          if (character <= 65535) {
            /** @type {string} */
            str = str + String.fromCharCode(224 | character >>> 12 & 15, 128 | character >>> 6 & 63, 128 | 63 & character);
          } else {
            if (character <= 2097151) {
              /** @type {string} */
              str = str + String.fromCharCode(240 | character >>> 18 & 7, 128 | character >>> 12 & 63, 128 | character >>> 6 & 63, 128 | 63 & character);
            }
          }
        }
      }
    }
    return str;
  }
  /**
   * @param {string} str
   * @return {?}
   */
  function str2binb(str) {
    /** @type {!Array} */
    var bin = Array(str.length >> 2);
    /** @type {number} */
    var i = 0;
    for (; i < bin.length; i++) {
      /** @type {number} */
      bin[i] = 0;
    }
    /** @type {number} */
    i = 0;
    for (; i < 8 * str.length; i = i + 8) {
      bin[i >> 5] |= (255 & str.charCodeAt(i / 8)) << 24 - i % 32;
    }
    return bin;
  }
  /**
   * @param {!Object} bin
   * @return {?}
   */
  function binb2str(bin) {
    /** @type {string} */
    var str = "";
    /** @type {number} */
    var i = 0;
    for (; i < 32 * bin.length; i = i + 8) {
      /** @type {string} */
      str = str + String.fromCharCode(bin[i >> 5] >>> 24 - i % 32 & 255);
    }
    return str;
  }
  /**
   * @param {!Object} x
   * @param {number} len
   * @return {?}
   */
  function core_sha1(x, len) {
    x[len >> 5] |= 128 << 24 - len % 32;
    /** @type {number} */
    x[15 + (len + 64 >> 9 << 4)] = len;
    /** @type {!Array} */
    var a = Array(80);
    /** @type {number} */
    var l = 1732584193;
    /** @type {number} */
    var b = -271733879;
    /** @type {number} */
    var c = -1732584194;
    /** @type {number} */
    var d = 271733878;
    /** @type {number} */
    var e = -1009589776;
    /** @type {number} */
    var i = 0;
    for (; i < x.length; i = i + 16) {
      var t = l;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      var i = e;
      /** @type {number} */
      var j = 0;
      for (; j < 80; j++) {
        a[j] = j < 16 ? x[i + j] : rol(a[j - 3] ^ a[j - 8] ^ a[j - 14] ^ a[j - 16], 1);
        var t = add(add(rol(l, 5), sha1_ft(j, b, c, d)), add(add(e, a[j]), sha1_kt(j)));
        e = d;
        d = c;
        c = rol(b, 30);
        b = l;
        l = t;
      }
      l = add(l, t);
      b = add(b, oldb);
      c = add(c, oldc);
      d = add(d, oldd);
      e = add(e, i);
    }
    return Array(l, b, c, d, e);
  }
  /**
   * @param {number} t
   * @param {number} b
   * @param {number} c
   * @param {number} d
   * @return {?}
   */
  function sha1_ft(t, b, c, d) {
    return t < 20 ? b & c | ~b & d : t < 40 ? b ^ c ^ d : t < 60 ? b & c | b & d | c & d : b ^ c ^ d;
  }
  /**
   * @param {number} t
   * @return {?}
   */
  function sha1_kt(t) {
    return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {?}
   */
  function add(x, y) {
    /** @type {number} */
    var r = (65535 & x) + (65535 & y);
    return (x >> 16) + (y >> 16) + (r >> 16) << 16 | 65535 & r;
  }
  /**
   * @param {number} num
   * @param {number} cnt
   * @return {?}
   */
  function rol(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  /** @type {string} */
  var overrideSubItems = "=";
  /**
   * @param {string} el
   * @param {?} data
   * @return {?}
   */
  sha1.HMACSHA1 = function(el, data) {
    return tmp = data, next(core_hmac_sha1(o(el), o(tmp)));
    var tmp;
  };
}, function(mixin, canCreateDiscussions, __webpack_require__) {
  (function(Buffer, window, $process) {
    var config = __webpack_require__(102);
    var inherits = __webpack_require__(1);
    var _http = __webpack_require__(103);
    var stream = __webpack_require__(20);
    var filter = __webpack_require__(199);
    var GetMoreCommand = _http.IncomingMessage;
    var FakeXMLHttpRequest = _http.readyStates;
    /** @type {function(!Object): undefined} */
    var self = mixin.exports = function(value) {
      var r;
      var self = this;
      stream.Writable.call(self);
      /** @type {!Object} */
      self._opts = value;
      /** @type {!Array} */
      self._body = [];
      self._headers = {};
      if (value.auth) {
        self.setHeader("Authorization", "Basic " + (new Buffer(value.auth)).toString("base64"));
      }
      Object.keys(value.headers).forEach(function(key) {
        self.setHeader(key, value.headers[key]);
      });
      /** @type {boolean} */
      var timeout = true;
      if ("disable-fetch" === value.mode || "requestTimeout" in value && !config.abortController) {
        /** @type {boolean} */
        timeout = false;
        /** @type {boolean} */
        r = true;
      } else {
        if ("prefer-streaming" === value.mode) {
          /** @type {boolean} */
          r = false;
        } else {
          if ("allow-wrong-content-type" === value.mode) {
            /** @type {boolean} */
            r = !config.overrideMimeType;
          } else {
            if (value.mode && "default" !== value.mode && "prefer-fast" !== value.mode) {
              throw new Error("Invalid value for opts.mode");
            }
            /** @type {boolean} */
            r = true;
          }
        }
      }
      self._mode = function(password, why) {
        return config.fetch && why ? "fetch" : config.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : config.msstream ? "ms-stream" : config.arraybuffer && password ? "arraybuffer" : config.vbArray && password ? "text:vbarray" : "text";
      }(r, timeout);
      /** @type {null} */
      self._fetchTimer = null;
      self.on("finish", function() {
        self._onFinish();
      });
    };
    inherits(self, stream.Writable);
    /**
     * @param {string} name
     * @param {!Object} value
     * @return {undefined}
     */
    self.prototype.setHeader = function(name, value) {
      var i = name.toLowerCase();
      if (-1 === forbiddenRequestHeaders.indexOf(i)) {
        this._headers[i] = {
          name : name,
          value : value
        };
      }
    };
    /**
     * @param {string} all
     * @return {?}
     */
    self.prototype.getHeader = function(all) {
      var header = this._headers[all.toLowerCase()];
      return header ? header.value : null;
    };
    /**
     * @param {string} name
     * @return {undefined}
     */
    self.prototype.removeHeader = function(name) {
      delete this._headers[name.toLowerCase()];
    };
    /**
     * @return {?}
     */
    self.prototype._onFinish = function() {
      var self = this;
      if (!self._destroyed) {
        var request = self._opts;
        var headers = self._headers;
        /** @type {null} */
        var body = null;
        if ("GET" !== request.method && "HEAD" !== request.method) {
          body = config.arraybuffer ? filter(Buffer.concat(self._body)) : config.blobConstructor ? new window.Blob(self._body.map(function(filteredLine) {
            return filter(filteredLine);
          }), {
            type : (headers["content-type"] || {}).value || ""
          }) : Buffer.concat(self._body).toString();
        }
        /** @type {!Array} */
        var size = [];
        if (Object.keys(headers).forEach(function(componentIndex) {
          var func = headers[componentIndex].name;
          var r = headers[componentIndex].value;
          if (Array.isArray(r)) {
            r.forEach(function(scale) {
              size.push([func, scale]);
            });
          } else {
            size.push([func, r]);
          }
        }), "fetch" === self._mode) {
          /** @type {null} */
          var signal = null;
          if (config.abortController) {
            var opt = new AbortController;
            signal = opt.signal;
            self._fetchAbortController = opt;
            if ("requestTimeout" in request && 0 !== request.requestTimeout) {
              self._fetchTimer = window.setTimeout(function() {
                self.emit("requestTimeout");
                if (self._fetchAbortController) {
                  self._fetchAbortController.abort();
                }
              }, request.requestTimeout);
            }
          }
          window.fetch(self._opts.url, {
            method : self._opts.method,
            headers : size,
            body : body || void 0,
            mode : "cors",
            credentials : request.withCredentials ? "include" : "same-origin",
            signal : signal
          }).then(function(resp) {
            /** @type {!Object} */
            self._fetchResponse = resp;
            self._connect();
          }, function(on_requestretry) {
            window.clearTimeout(self._fetchTimer);
            if (!self._destroyed) {
              self.emit("error", on_requestretry);
            }
          });
        } else {
          var xhr = self._xhr = new window.XMLHttpRequest;
          try {
            xhr.open(self._opts.method, self._opts.url, true);
          } catch (on_requestretry) {
            return void $process.nextTick(function() {
              self.emit("error", on_requestretry);
            });
          }
          if ("responseType" in xhr) {
            xhr.responseType = self._mode.split(":")[0];
          }
          if ("withCredentials" in xhr) {
            /** @type {boolean} */
            xhr.withCredentials = !!request.withCredentials;
          }
          if ("text" === self._mode && "overrideMimeType" in xhr) {
            xhr.overrideMimeType("text/plain; charset=x-user-defined");
          }
          if ("requestTimeout" in request) {
            xhr.timeout = request.requestTimeout;
            /**
             * @return {undefined}
             */
            xhr.ontimeout = function() {
              self.emit("requestTimeout");
            };
          }
          size.forEach(function(header) {
            xhr.setRequestHeader(header[0], header[1]);
          });
          /** @type {null} */
          self._response = null;
          /**
           * @return {undefined}
           */
          xhr.onreadystatechange = function() {
            switch(xhr.readyState) {
              case FakeXMLHttpRequest.LOADING:
              case FakeXMLHttpRequest.DONE:
                self._onXHRProgress();
            }
          };
          if ("moz-chunked-arraybuffer" === self._mode) {
            /**
             * @return {undefined}
             */
            xhr.onprogress = function() {
              self._onXHRProgress();
            };
          }
          /**
           * @return {undefined}
           */
          xhr.onerror = function() {
            if (!self._destroyed) {
              self.emit("error", new Error("XHR error"));
            }
          };
          try {
            xhr.send(body);
          } catch (on_requestretry) {
            return void $process.nextTick(function() {
              self.emit("error", on_requestretry);
            });
          }
        }
      }
    };
    /**
     * @return {undefined}
     */
    self.prototype._onXHRProgress = function() {
      if (function(result) {
        try {
          var code = result.status;
          return null !== code && 0 !== code;
        } catch (r) {
          return false;
        }
      }(this._xhr) && !this._destroyed) {
        if (!this._response) {
          this._connect();
        }
        this._response._onXHRProgress();
      }
    };
    /**
     * @return {undefined}
     */
    self.prototype._connect = function() {
      var self = this;
      if (!self._destroyed) {
        self._response = new GetMoreCommand(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);
        self._response.on("error", function(on_requestretry) {
          self.emit("error", on_requestretry);
        });
        self.emit("response", self._response);
      }
    };
    /**
     * @param {!Object} data
     * @param {!Object} value
     * @param {number} callback
     * @return {undefined}
     */
    self.prototype._write = function(data, value, callback) {
      this._body.push(data);
      callback();
    };
    /** @type {function(): undefined} */
    self.prototype.abort = self.prototype.destroy = function() {
      /** @type {boolean} */
      this._destroyed = true;
      window.clearTimeout(this._fetchTimer);
      if (this._response) {
        /** @type {boolean} */
        this._response._destroyed = true;
      }
      if (this._xhr) {
        this._xhr.abort();
      } else {
        if (this._fetchAbortController) {
          this._fetchAbortController.abort();
        }
      }
    };
    /**
     * @param {string} key
     * @param {string} result
     * @param {string} instance
     * @return {undefined}
     */
    self.prototype.end = function(key, result, instance) {
      if ("function" === typeof key) {
        /** @type {string} */
        instance = key;
        key = void 0;
      }
      stream.Writable.prototype.end.call(this, key, result, instance);
    };
    /**
     * @return {undefined}
     */
    self.prototype.flushHeaders = function() {
    };
    /**
     * @return {undefined}
     */
    self.prototype.setTimeout = function() {
    };
    /**
     * @return {undefined}
     */
    self.prototype.setNoDelay = function() {
    };
    /**
     * @return {undefined}
     */
    self.prototype.setSocketKeepAlive = function() {
    };
    /** @type {!Array} */
    var forbiddenRequestHeaders = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"];
  }).call(this, __webpack_require__(3).Buffer, __webpack_require__(5), __webpack_require__(8));
}, function(mixin, canCreateDiscussions, require) {
  var Buffer = require(3).Buffer;
  /**
   * @param {!Object} data
   * @return {?}
   */
  mixin.exports = function(data) {
    if (data instanceof Uint8Array) {
      if (0 === data.byteOffset && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      if ("function" === typeof data.buffer.slice) {
        return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
      }
    }
    if (Buffer.isBuffer(data)) {
      /** @type {!Uint8Array} */
      var newdata = new Uint8Array(data.length);
      var num_arrays = data.length;
      /** @type {number} */
      var n = 0;
      for (; n < num_arrays; n++) {
        newdata[n] = data[n];
      }
      return newdata.buffer;
    }
    throw new Error("Argument must be a Buffer");
  };
}, function(mixin, canCreateDiscussions) {
  /**
   * @return {?}
   */
  mixin.exports = function() {
    var rVal = {};
    /** @type {number} */
    var index = 0;
    for (; index < arguments.length; index++) {
      var item = arguments[index];
      var i;
      for (i in item) {
        if (has.call(item, i)) {
          rVal[i] = item[i];
        }
      }
    }
    return rVal;
  };
  /** @type {function(this:Object, *): boolean} */
  var has = Object.prototype.hasOwnProperty;
}, function(mixin, canCreateDiscussions) {
  mixin.exports = {
    100 : "Continue",
    101 : "Switching Protocols",
    102 : "Processing",
    200 : "OK",
    201 : "Created",
    202 : "Accepted",
    203 : "Non-Authoritative Information",
    204 : "No Content",
    205 : "Reset Content",
    206 : "Partial Content",
    207 : "Multi-Status",
    208 : "Already Reported",
    226 : "IM Used",
    300 : "Multiple Choices",
    301 : "Moved Permanently",
    302 : "Found",
    303 : "See Other",
    304 : "Not Modified",
    305 : "Use Proxy",
    307 : "Temporary Redirect",
    308 : "Permanent Redirect",
    400 : "Bad Request",
    401 : "Unauthorized",
    402 : "Payment Required",
    403 : "Forbidden",
    404 : "Not Found",
    405 : "Method Not Allowed",
    406 : "Not Acceptable",
    407 : "Proxy Authentication Required",
    408 : "Request Timeout",
    409 : "Conflict",
    410 : "Gone",
    411 : "Length Required",
    412 : "Precondition Failed",
    413 : "Payload Too Large",
    414 : "URI Too Long",
    415 : "Unsupported Media Type",
    416 : "Range Not Satisfiable",
    417 : "Expectation Failed",
    418 : "I'm a teapot",
    421 : "Misdirected Request",
    422 : "Unprocessable Entity",
    423 : "Locked",
    424 : "Failed Dependency",
    425 : "Unordered Collection",
    426 : "Upgrade Required",
    428 : "Precondition Required",
    429 : "Too Many Requests",
    431 : "Request Header Fields Too Large",
    451 : "Unavailable For Legal Reasons",
    500 : "Internal Server Error",
    501 : "Not Implemented",
    502 : "Bad Gateway",
    503 : "Service Unavailable",
    504 : "Gateway Timeout",
    505 : "HTTP Version Not Supported",
    506 : "Variant Also Negotiates",
    507 : "Insufficient Storage",
    508 : "Loop Detected",
    509 : "Bandwidth Limit Exceeded",
    510 : "Not Extended",
    511 : "Network Authentication Required"
  };
}, function(e, t, callback) {
  (function(module, exports) {
    var result;
    !function(canCreateDiscussions) {
      /**
       * @param {string} type
       * @return {?}
       */
      function error(type) {
        throw new RangeError(errors[type]);
      }
      /**
       * @param {!Object} a
       * @param {!Function} fn
       * @return {?}
       */
      function map(a, fn) {
        var i = a.length;
        /** @type {!Array} */
        var array = [];
        for (; i--;) {
          array[i] = fn(a[i]);
        }
        return array;
      }
      /**
       * @param {string} string
       * @param {!Function} fn
       * @return {?}
       */
      function mapDomain(string, fn) {
        var parts = string.split("@");
        /** @type {string} */
        var th_field = "";
        return parts.length > 1 && (th_field = parts[0] + "@", string = parts[1]), th_field + map((string = string.replace(refLinkIDRegex, ".")).split("."), fn).join(".");
      }
      /**
       * @param {string} string
       * @return {?}
       */
      function ucs2decode(string) {
        var t;
        var r;
        /** @type {!Array} */
        var output = [];
        /** @type {number} */
        var i = 0;
        var stringLength = string.length;
        for (; i < stringLength;) {
          if ((t = string.charCodeAt(i++)) >= 55296 && t <= 56319 && i < stringLength) {
            if (56320 == (64512 & (r = string.charCodeAt(i++)))) {
              output.push(((1023 & t) << 10) + (1023 & r) + 65536);
            } else {
              output.push(t);
              i--;
            }
          } else {
            output.push(t);
          }
        }
        return output;
      }
      /**
       * @param {!Array} array
       * @return {?}
       */
      function ucs2encode(array) {
        return map(array, function(codePoint) {
          /** @type {string} */
          var output = "";
          return codePoint > 65535 && (output = output + stringFromCharCode((codePoint = codePoint - 65536) >>> 10 & 1023 | 55296), codePoint = 56320 | 1023 & codePoint), output = output + stringFromCharCode(codePoint);
        }).join("");
      }
      /**
       * @param {number} digit
       * @param {number} flag
       * @return {?}
       */
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
      }
      /**
       * @param {number} delta
       * @param {number} numPoints
       * @param {boolean} firstTime
       * @return {?}
       */
      function adapt(delta, numPoints, firstTime) {
        /** @type {number} */
        var val = 0;
        /** @type {number} */
        delta = firstTime ? floor(delta / 700) : delta >> 1;
        /** @type {number} */
        delta = delta + floor(delta / numPoints);
        for (; delta > 455; val = val + 36) {
          /** @type {number} */
          delta = floor(delta / 35);
        }
        return floor(val + 36 * delta / (delta + 38));
      }
      /**
       * @param {string} string
       * @return {?}
       */
      function decode(string) {
        var out;
        var sources;
        var index;
        var j;
        var oldi;
        var w;
        var k;
        var digit;
        var fixedBarsHeight;
        var mult;
        var d;
        /** @type {!Array} */
        var output = [];
        var m = string.length;
        /** @type {number} */
        var i = 0;
        /** @type {number} */
        var n = 128;
        /** @type {number} */
        var bias = 72;
        if ((sources = string.lastIndexOf("-")) < 0) {
          /** @type {number} */
          sources = 0;
        }
        /** @type {number} */
        index = 0;
        for (; index < sources; ++index) {
          if (string.charCodeAt(index) >= 128) {
            error("not-basic");
          }
          output.push(string.charCodeAt(index));
        }
        j = sources > 0 ? sources + 1 : 0;
        for (; j < m;) {
          /** @type {number} */
          oldi = i;
          /** @type {number} */
          w = 1;
          /** @type {number} */
          k = 36;
          for (; j >= m && error("invalid-input"), ((digit = (d = string.charCodeAt(j++)) - 48 < 10 ? d - 22 : d - 65 < 26 ? d - 65 : d - 97 < 26 ? d - 97 : 36) >= 36 || digit > floor((maxInt - i) / w)) && error("overflow"), i = i + digit * w, !(digit < (fixedBarsHeight = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k = k + 36) {
            if (w > floor(maxInt / (mult = 36 - fixedBarsHeight))) {
              error("overflow");
            }
            /** @type {number} */
            w = w * mult;
          }
          bias = adapt(i - oldi, out = output.length + 1, 0 == oldi);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          /** @type {number} */
          n = n + floor(i / out);
          /** @type {number} */
          i = i % out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      /**
       * @param {string} input
       * @return {?}
       */
      function encode(input) {
        var n;
        var delta;
        var handledCPCount;
        var basicLength;
        var bias;
        var j;
        var m;
        var q;
        var k;
        var t;
        var currentValue;
        var inputLength;
        var handledCPCountPlusOne;
        var baseMinusT;
        var qMinusT;
        /** @type {!Array} */
        var output = [];
        inputLength = (input = ucs2decode(input)).length;
        /** @type {number} */
        n = 128;
        /** @type {number} */
        delta = 0;
        /** @type {number} */
        bias = 72;
        /** @type {number} */
        j = 0;
        for (; j < inputLength; ++j) {
          if ((currentValue = input[j]) < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        /** @type {number} */
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push("-");
        }
        for (; handledCPCount < inputLength;) {
          /** @type {number} */
          m = maxInt;
          /** @type {number} */
          j = 0;
          for (; j < inputLength; ++j) {
            if ((currentValue = input[j]) >= n && currentValue < m) {
              m = currentValue;
            }
          }
          if (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1))) {
            error("overflow");
          }
          /** @type {number} */
          delta = delta + (m - n) * handledCPCountPlusOne;
          n = m;
          /** @type {number} */
          j = 0;
          for (; j < inputLength; ++j) {
            if ((currentValue = input[j]) < n && ++delta > maxInt && error("overflow"), currentValue == n) {
              /** @type {number} */
              q = delta;
              /** @type {number} */
              k = 36;
              for (; !(q < (t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k = k + 36) {
                /** @type {number} */
                qMinusT = q - t;
                /** @type {number} */
                baseMinusT = 36 - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                /** @type {number} */
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              /** @type {number} */
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      if (t) {
        t.nodeType;
      }
      if (module) {
        module.nodeType;
      }
      var win = "object" == typeof exports && exports;
      if (win.global !== win && win.window !== win) {
        win.self;
      }
      var punycode;
      /** @type {number} */
      var maxInt = 2147483647;
      /** @type {!RegExp} */
      var regBigBrackets = /^xn--/;
      /** @type {!RegExp} */
      var regCls = /[^\x20-\x7E]/;
      /** @type {!RegExp} */
      var refLinkIDRegex = /[\x2E\u3002\uFF0E\uFF61]/g;
      var errors = {
        overflow : "Overflow: input needs wider integers to process",
        "not-basic" : "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input" : "Invalid input"
      };
      /** @type {function(?): number} */
      var floor = Math.floor;
      /** @type {function(...number): string} */
      var stringFromCharCode = String.fromCharCode;
      punycode = {
        version : "1.4.1",
        ucs2 : {
          decode : ucs2decode,
          encode : ucs2encode
        },
        decode : decode,
        encode : encode,
        toASCII : function(domain) {
          return mapDomain(domain, function(s) {
            return regCls.test(s) ? "xn--" + encode(s) : s;
          });
        },
        toUnicode : function(domain) {
          return mapDomain(domain, function(string) {
            return regBigBrackets.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }
      };
      if (!(void 0 === (result = function() {
        return punycode;
      }.call(t, callback, t, module)))) {
        module.exports = result;
      }
    }();
  }).call(this, callback(87)(e), callback(5));
}, function(module, canCreateDiscussions, isSlidingUp) {
  module.exports = {
    isString : function(source) {
      return "string" === typeof source;
    },
    isObject : function(value) {
      return "object" === typeof value && null !== value;
    },
    isNull : function(val) {
      return null === val;
    },
    isNullOrUndefined : function(val) {
      return null == val;
    }
  };
}, function(mixin, canCreateDiscussions, isSlidingUp) {
  /**
   * @param {?} object
   * @param {string} prop
   * @return {?}
   */
  function __hasOwn(object, prop) {
    return Object.prototype.hasOwnProperty.call(object, prop);
  }
  /**
   * @param {string} key
   * @param {string} type
   * @param {string} element
   * @param {!Object} options
   * @return {?}
   */
  mixin.exports = function(key, type, element, options) {
    type = type || "&";
    element = element || "=";
    var obj = {};
    if ("string" !== typeof key || 0 === key.length) {
      return obj;
    }
    /** @type {!RegExp} */
    var named_param_regex = /\+/g;
    /** @type {!Array<string>} */
    key = key.split(type);
    /** @type {number} */
    var maxKeys = 1E3;
    if (options && "number" === typeof options.maxKeys) {
      /** @type {number} */
      maxKeys = options.maxKeys;
    }
    /** @type {number} */
    var len = key.length;
    if (maxKeys > 0 && len > maxKeys) {
      /** @type {number} */
      len = maxKeys;
    }
    /** @type {number} */
    var j = 0;
    for (; j < len; ++j) {
      var data;
      var part;
      var name;
      var value;
      /** @type {string} */
      var s = key[j].replace(named_param_regex, "%20");
      /** @type {number} */
      var index = s.indexOf(element);
      if (index >= 0) {
        /** @type {string} */
        data = s.substr(0, index);
        /** @type {string} */
        part = s.substr(index + 1);
      } else {
        /** @type {string} */
        data = s;
        /** @type {string} */
        part = "";
      }
      /** @type {string} */
      name = decodeURIComponent(data);
      /** @type {string} */
      value = decodeURIComponent(part);
      if (__hasOwn(obj, name)) {
        if (i(obj[name])) {
          obj[name].push(value);
        } else {
          /** @type {!Array} */
          obj[name] = [obj[name], value];
        }
      } else {
        /** @type {string} */
        obj[name] = value;
      }
    }
    return obj;
  };
  /** @type {function(*): boolean} */
  var i = Array.isArray || function(key) {
    return "[object Array]" === Object.prototype.toString.call(key);
  };
}, function(mixin, canCreateDiscussions, isSlidingUp) {
  /**
   * @param {!Array} elems
   * @param {!Function} callback
   * @return {?}
   */
  function map(elems, callback) {
    if (elems.map) {
      return elems.map(callback);
    }
    /** @type {!Array} */
    var results = [];
    /** @type {number} */
    var i = 0;
    for (; i < elems.length; i++) {
      results.push(callback(elems[i], i));
    }
    return results;
  }
  /**
   * @param {!Object} v
   * @return {?}
   */
  var stringifyPrimitive = function(v) {
    switch(typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  };
  /**
   * @param {!Object} obj
   * @param {string} value
   * @param {string} type
   * @param {string} name
   * @return {?}
   */
  mixin.exports = function(obj, value, type, name) {
    return value = value || "&", type = type || "=", null === obj && (obj = void 0), "object" === typeof obj ? map(objectKeys(obj), function(k) {
      var prefix = encodeURIComponent(stringifyPrimitive(k)) + type;
      return isNaN(obj[k]) ? map(obj[k], function(name) {
        return prefix + encodeURIComponent(stringifyPrimitive(name));
      }).join(value) : prefix + encodeURIComponent(stringifyPrimitive(obj[k]));
    }).join(value) : name ? encodeURIComponent(stringifyPrimitive(name)) + type + encodeURIComponent(stringifyPrimitive(obj)) : "";
  };
  /** @type {function(*): boolean} */
  var isNaN = Array.isArray || function(key) {
    return "[object Array]" === Object.prototype.toString.call(key);
  };
  /** @type {function(!Object): !Array<string>} */
  var objectKeys = Object.keys || function(obj) {
    /** @type {!Array} */
    var newaxe = [];
    var field;
    for (field in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, field)) {
        newaxe.push(field);
      }
    }
    return newaxe;
  };
}, function(canCreateDiscussions, exports, require) {
  (function(Buffer) {
    var qs = require(54);
    var HHgText = (require(64), require(55));
    var Pages = require(53);
    var uri = require(26);
    var angular = require(104);
    /**
     * @param {string} clientId
     * @param {string} clientSecret
     * @param {?} baseSite
     * @param {string} authorizePath
     * @param {string} accessTokenPath
     * @param {number} customHeaders
     * @return {undefined}
     */
    exports.OAuth2 = function(clientId, clientSecret, baseSite, authorizePath, accessTokenPath, customHeaders) {
      /** @type {string} */
      this._clientId = clientId;
      /** @type {string} */
      this._clientSecret = clientSecret;
      this._baseSite = baseSite;
      this._authorizeUrl = authorizePath || "/oauth/authorize";
      this._accessTokenUrl = accessTokenPath || "/oauth/access_token";
      /** @type {string} */
      this._accessTokenName = "access_token";
      /** @type {string} */
      this._authMethod = "Bearer";
      this._customHeaders = customHeaders || {};
      /** @type {boolean} */
      this._useAuthorizationHeaderForGET = false;
      this._agent = void 0;
    };
    /**
     * @param {!Object} agent
     * @return {undefined}
     */
    exports.OAuth2.prototype.setAgent = function(agent) {
      /** @type {!Object} */
      this._agent = agent;
    };
    /**
     * @param {!Array} name
     * @return {undefined}
     */
    exports.OAuth2.prototype.setAccessTokenName = function(name) {
      /** @type {!Array} */
      this._accessTokenName = name;
    };
    /**
     * @param {string} authMethod
     * @return {undefined}
     */
    exports.OAuth2.prototype.setAuthMethod = function(authMethod) {
      /** @type {string} */
      this._authMethod = authMethod;
    };
    /**
     * @param {boolean} useIt
     * @return {undefined}
     */
    exports.OAuth2.prototype.useAuthorizationHeaderforGET = function(useIt) {
      /** @type {boolean} */
      this._useAuthorizationHeaderForGET = useIt;
    };
    /**
     * @return {?}
     */
    exports.OAuth2.prototype._getAccessTokenUrl = function() {
      return this._baseSite + this._accessTokenUrl;
    };
    /**
     * @param {string} token
     * @return {?}
     */
    exports.OAuth2.prototype.buildAuthHeader = function(token) {
      return this._authMethod + " " + token;
    };
    /**
     * @param {!Object} parsedUrl
     * @return {?}
     */
    exports.OAuth2.prototype._chooseHttpLibrary = function(parsedUrl) {
      var t = HHgText;
      return "https:" != parsedUrl.protocol && (t = Pages), t;
    };
    /**
     * @param {string} method
     * @param {string} url
     * @param {!Object} config
     * @param {string} data
     * @param {string} access_token
     * @param {!Function} callback
     * @return {undefined}
     */
    exports.OAuth2.prototype._request = function(method, url, config, data, access_token, callback) {
      var parsedUrl = uri.parse(url, true);
      if (!("https:" != parsedUrl.protocol || parsedUrl.port)) {
        /** @type {number} */
        parsedUrl.port = 443;
      }
      var http_library = this._chooseHttpLibrary(parsedUrl);
      var headers = {};
      var key;
      for (key in this._customHeaders) {
        headers[key] = this._customHeaders[key];
      }
      if (config) {
        for (key in config) {
          headers[key] = config[key];
        }
      }
      headers.Host = parsedUrl.host;
      if (!headers["User-Agent"]) {
        /** @type {string} */
        headers["User-Agent"] = "Node-oauth";
      }
      if (data) {
        if (Buffer.isBuffer(data)) {
          headers["Content-Length"] = data.length;
        } else {
          headers["Content-Length"] = Buffer.byteLength(data);
        }
      } else {
        /** @type {number} */
        headers["Content-length"] = 0;
      }
      if (!(!access_token || "Authorization" in headers)) {
        if (!parsedUrl.query) {
          parsedUrl.query = {};
        }
        /** @type {string} */
        parsedUrl.query[this._accessTokenName] = access_token;
      }
      var queryStr = qs.stringify(parsedUrl.query);
      if (queryStr) {
        /** @type {string} */
        queryStr = "?" + queryStr;
      }
      var options = {
        host : parsedUrl.hostname,
        port : parsedUrl.port,
        path : parsedUrl.pathname + queryStr,
        method : method,
        headers : headers
      };
      this._executeRequest(http_library, options, data, callback);
    };
    /**
     * @param {!Element} http_library
     * @param {(Object|string)} options
     * @param {!Object} callback
     * @param {!Function} resolve
     * @return {undefined}
     */
    exports.OAuth2.prototype._executeRequest = function(http_library, options, callback, resolve) {
      /**
       * @param {!Object} res
       * @param {string} url
       * @return {undefined}
       */
      function onerror(res, url) {
        if (!o) {
          /** @type {boolean} */
          o = true;
          if (res.statusCode >= 200 && res.statusCode <= 299 || 301 == res.statusCode || 302 == res.statusCode) {
            resolve(null, url, res);
          } else {
            resolve({
              statusCode : res.statusCode,
              data : url
            });
          }
        }
      }
      var i = angular.isAnEarlyCloseHost(options.host);
      /** @type {boolean} */
      var o = false;
      /** @type {string} */
      var url = "";
      if (this._agent) {
        options.agent = this._agent;
      }
      var u = http_library.request(options);
      u.on("response", function(response) {
        response.on("data", function(hashtagName) {
          url = url + hashtagName;
        });
        response.on("close", function(canCreateDiscussions) {
          if (i) {
            onerror(response, url);
          }
        });
        response.addListener("end", function() {
          onerror(response, url);
        });
      });
      u.on("error", function(defaultSounds) {
        /** @type {boolean} */
        o = true;
        resolve(defaultSounds);
      });
      if (!("POST" != options.method && "PUT" != options.method || !callback)) {
        u.write(callback);
      }
      u.end();
    };
    /**
     * @param {number} params
     * @return {?}
     */
    exports.OAuth2.prototype.getAuthorizeUrl = function(params) {
      return (params = params || {}).client_id = this._clientId, this._baseSite + this._authorizeUrl + "?" + qs.stringify(params);
    };
    /**
     * @param {?} tokenSecret
     * @param {!Object} params
     * @param {?} callback
     * @return {undefined}
     */
    exports.OAuth2.prototype.getOAuthAccessToken = function(tokenSecret, params, callback) {
      (params = params || {}).client_id = this._clientId;
      params.client_secret = this._clientSecret;
      params["refresh_token" === params.grant_type ? "refresh_token" : "code"] = tokenSecret;
      var queryParams = qs.stringify(params);
      this._request("POST", this._getAccessTokenUrl(), {
        "Content-Type" : "application/x-www-form-urlencoded"
      }, queryParams, null, function(identifierPositions, response, i) {
        if (identifierPositions) {
          callback(identifierPositions);
        } else {
          var token;
          try {
            /** @type {*} */
            token = JSON.parse(response);
          } catch (f) {
            token = qs.parse(response);
          }
          var accessToken = token.access_token;
          var refreshToken = token.refresh_token;
          delete token.refresh_token;
          callback(null, accessToken, refreshToken, token);
        }
      });
    };
    /**
     * @param {string} url
     * @param {string} access_token
     * @param {!Function} callback
     * @return {undefined}
     */
    exports.OAuth2.prototype.getProtectedResource = function(url, access_token, callback) {
      this._request("GET", url, {}, "", access_token, callback);
    };
    /**
     * @param {string} path
     * @param {string} access_token
     * @param {!Function} callback
     * @return {undefined}
     */
    exports.OAuth2.prototype.get = function(path, access_token, callback) {
      if (this._useAuthorizationHeaderForGET) {
        var headers = {
          Authorization : this.buildAuthHeader(access_token)
        };
        /** @type {null} */
        access_token = null;
      } else {
        headers = {};
      }
      this._request("GET", path, headers, "", access_token, callback);
    };
  }).call(this, require(3).Buffer);
}, , function(module, canCreateDiscussions, bind) {
  var toString = bind(209);
  var fn = bind(210);
  var v = bind(107);
  module.exports = {
    formats : v,
    parse : fn,
    stringify : toString
  };
}, function(mixin, canCreateDiscussions, require) {
  var utils = require(57);
  var config = require(107);
  /** @type {function(this:Object, *): boolean} */
  var _ = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets : function(prefix) {
      return prefix + "[]";
    },
    comma : "comma",
    indices : function(key, prefix) {
      return key + "[" + prefix + "]";
    },
    repeat : function(s) {
      return s;
    }
  };
  /** @type {function(*): boolean} */
  var isArray = Array.isArray;
  /** @type {function(this:IArrayLike<T>, ...T): number} */
  var self = Array.prototype.push;
  /**
   * @param {!Array} event
   * @param {string} a
   * @return {undefined}
   */
  var merge = function(event, a) {
    self.apply(event, isArray(a) ? a : [a]);
  };
  /** @type {function(this:Date): string} */
  var toISO = Date.prototype.toISOString;
  var type = config.default;
  var defaults = {
    addQueryPrefix : false,
    allowDots : false,
    charset : "utf-8",
    charsetSentinel : false,
    delimiter : "&",
    encode : true,
    encoder : utils.encode,
    encodeValuesOnly : false,
    format : type,
    formatter : config.formatters[type],
    indices : false,
    serializeDate : function(date) {
      return toISO.call(date);
    },
    skipNulls : false,
    strictNullHandling : false
  };
  /**
   * @param {?} min
   * @param {string} value
   * @param {string} type
   * @param {?} payload
   * @param {boolean} opts
   * @param {string} fn
   * @param {string} c
   * @param {number} t
   * @param {string} url
   * @param {?} f
   * @param {?} assert
   * @param {string} err
   * @param {?} status
   * @return {?}
   */
  var transform = function callback(min, value, type, payload, opts, fn, c, t, url, f, assert, err, status) {
    var path;
    var v = min;
    if ("function" === typeof c ? v = c(value, v) : v instanceof Date ? v = f(v) : "comma" === type && isArray(v) && (v = v.join(",")), null === v) {
      if (payload) {
        return fn && !err ? fn(value, defaults.encoder, status, "key") : value;
      }
      /** @type {string} */
      v = "";
    }
    if ("string" === typeof(path = v) || "number" === typeof path || "boolean" === typeof path || "symbol" === typeof path || "bigint" === typeof path || utils.isBuffer(v)) {
      return fn ? [assert(err ? value : fn(value, defaults.encoder, status, "key")) + "=" + assert(fn(v, defaults.encoder, status, "value"))] : [assert(value) + "=" + assert(String(v))];
    }
    var a;
    /** @type {!Array} */
    var args = [];
    if ("undefined" === typeof v) {
      return args;
    }
    if (isArray(c)) {
      /** @type {string} */
      a = c;
    } else {
      /** @type {!Array<string>} */
      var b = Object.keys(v);
      /** @type {!Array<string>} */
      a = t ? b.sort(t) : b;
    }
    /** @type {number} */
    var i = 0;
    for (; i < a.length; ++i) {
      var id = a[i];
      if (!(opts && null === v[id])) {
        if (isArray(v)) {
          merge(args, callback(v[id], "function" === typeof type ? type(value, id) : value, type, payload, opts, fn, c, t, url, f, assert, err, status));
        } else {
          merge(args, callback(v[id], value + (url ? "." + id : "[" + id + "]"), type, payload, opts, fn, c, t, url, f, assert, err, status));
        }
      }
    }
    return args;
  };
  /**
   * @param {string} value
   * @param {!Object} options
   * @return {?}
   */
  mixin.exports = function(value, options) {
    var arr;
    /** @type {string} */
    var data = value;
    var defaults = function(options) {
      if (!options) {
        return defaults;
      }
      if (null !== options.encoder && void 0 !== options.encoder && "function" !== typeof options.encoder) {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = options.charset || defaults.charset;
      if ("undefined" !== typeof options.charset && "utf-8" !== options.charset && "iso-8859-1" !== options.charset) {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var type = config.default;
      if ("undefined" !== typeof options.format) {
        if (!_.call(config.formatters, options.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        type = options.format;
      }
      var formatter = config.formatters[type];
      var filter = defaults.filter;
      return ("function" === typeof options.filter || isArray(options.filter)) && (filter = options.filter), {
        addQueryPrefix : "boolean" === typeof options.addQueryPrefix ? options.addQueryPrefix : defaults.addQueryPrefix,
        allowDots : "undefined" === typeof options.allowDots ? defaults.allowDots : !!options.allowDots,
        charset : charset,
        charsetSentinel : "boolean" === typeof options.charsetSentinel ? options.charsetSentinel : defaults.charsetSentinel,
        delimiter : "undefined" === typeof options.delimiter ? defaults.delimiter : options.delimiter,
        encode : "boolean" === typeof options.encode ? options.encode : defaults.encode,
        encoder : "function" === typeof options.encoder ? options.encoder : defaults.encoder,
        encodeValuesOnly : "boolean" === typeof options.encodeValuesOnly ? options.encodeValuesOnly : defaults.encodeValuesOnly,
        filter : filter,
        formatter : formatter,
        serializeDate : "function" === typeof options.serializeDate ? options.serializeDate : defaults.serializeDate,
        skipNulls : "boolean" === typeof options.skipNulls ? options.skipNulls : defaults.skipNulls,
        sort : "function" === typeof options.sort ? options.sort : null,
        strictNullHandling : "boolean" === typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling
      };
    }(options);
    if ("function" === typeof defaults.filter) {
      data = (0, defaults.filter)("", data);
    } else {
      if (isArray(defaults.filter)) {
        arr = defaults.filter;
      }
    }
    var arrayFormat;
    /** @type {!Array} */
    var result = [];
    if ("object" !== typeof data || null === data) {
      return "";
    }
    arrayFormat = options && options.arrayFormat in arrayPrefixGenerators ? options.arrayFormat : options && "indices" in options ? options.indices ? "indices" : "repeat" : "indices";
    var key = arrayPrefixGenerators[arrayFormat];
    if (!arr) {
      /** @type {!Array<string>} */
      arr = Object.keys(data);
    }
    if (defaults.sort) {
      arr.sort(defaults.sort);
    }
    /** @type {number} */
    var i = 0;
    for (; i < arr.length; ++i) {
      /** @type {string} */
      var name = arr[i];
      if (!(defaults.skipNulls && null === data[name])) {
        merge(result, transform(data[name], name, key, defaults.strictNullHandling, defaults.skipNulls, defaults.encode ? defaults.encoder : null, defaults.filter, defaults.sort, defaults.allowDots, defaults.serializeDate, defaults.formatter, defaults.encodeValuesOnly, defaults.charset));
      }
    }
    /** @type {string} */
    var throbText = result.join(defaults.delimiter);
    /** @type {string} */
    var msg = true === defaults.addQueryPrefix ? "?" : "";
    return defaults.charsetSentinel && ("iso-8859-1" === defaults.charset ? msg = msg + "utf8=%26%2310003%3B&" : msg = msg + "utf8=%E2%9C%93&"), throbText.length > 0 ? msg + throbText : "";
  };
}, function(mixin, canCreateDiscussions, require) {
  var utils = require(57);
  /** @type {function(this:Object, *): boolean} */
  var has = Object.prototype.hasOwnProperty;
  /** @type {function(*): boolean} */
  var isArray = Array.isArray;
  var defaults = {
    allowDots : false,
    allowPrototypes : false,
    arrayLimit : 20,
    charset : "utf-8",
    charsetSentinel : false,
    comma : false,
    decoder : utils.decode,
    delimiter : "&",
    depth : 5,
    ignoreQueryPrefix : false,
    interpretNumericEntities : false,
    parameterLimit : 1E3,
    parseArrays : true,
    plainObjects : false,
    strictNullHandling : false
  };
  /**
   * @param {string} tags
   * @return {?}
   */
  var callback = function(tags) {
    return tags.replace(/&#(\d+);/g, function(canCreateDiscussions, hexaCode) {
      return String.fromCharCode(parseInt(hexaCode, 10));
    });
  };
  /**
   * @param {string} givenKey
   * @param {string} val
   * @param {!Object} options
   * @return {?}
   */
  var set = function(givenKey, val, options) {
    if (givenKey) {
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      /** @type {!RegExp} */
      var RE_PART = /(\[[^[\]]*])/g;
      /** @type {(Array<string>|boolean|null)} */
      var segment = options.depth > 0 && /(\[[^[\]]*])/.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      /** @type {!Array} */
      var keys = [];
      if (parent) {
        if (!options.plainObjects && has.call(Object.prototype, parent) && !options.allowPrototypes) {
          return;
        }
        keys.push(parent);
      }
      /** @type {number} */
      var i = 0;
      for (; options.depth > 0 && null !== (segment = RE_PART.exec(key)) && i < options.depth;) {
        if (i = i + 1, !options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1)) && !options.allowPrototypes) {
          return;
        }
        keys.push(segment[1]);
      }
      return segment && keys.push("[" + key.slice(segment.index) + "]"), function(object, fn, options) {
        /** @type {string} */
        var obj = fn;
        /** @type {number} */
        var hash = object.length - 1;
        for (; hash >= 0; --hash) {
          var newObj;
          var id = object[hash];
          if ("[]" === id && options.parseArrays) {
            /** @type {!Array<?>} */
            newObj = [].concat(obj);
          } else {
            /** @type {!Object} */
            newObj = options.plainObjects ? Object.create(null) : {};
            var key = "[" === id.charAt(0) && "]" === id.charAt(id.length - 1) ? id.slice(1, -1) : id;
            /** @type {number} */
            var index = parseInt(key, 10);
            if (options.parseArrays || "" !== key) {
              if (!isNaN(index) && id !== key && String(index) === key && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
                (newObj = [])[index] = obj;
              } else {
                newObj[key] = obj;
              }
            } else {
              newObj = {
                0 : obj
              };
            }
          }
          /** @type {!Object} */
          obj = newObj;
        }
        return obj;
      }(keys, val, options);
    }
  };
  /**
   * @param {string} value
   * @param {string} o
   * @return {?}
   */
  mixin.exports = function(value, o) {
    var options = function(options) {
      if (!options) {
        return defaults;
      }
      if (null !== options.decoder && void 0 !== options.decoder && "function" !== typeof options.decoder) {
        throw new TypeError("Decoder has to be a function.");
      }
      if ("undefined" !== typeof options.charset && "utf-8" !== options.charset && "iso-8859-1" !== options.charset) {
        throw new Error("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = "undefined" === typeof options.charset ? defaults.charset : options.charset;
      return {
        allowDots : "undefined" === typeof options.allowDots ? defaults.allowDots : !!options.allowDots,
        allowPrototypes : "boolean" === typeof options.allowPrototypes ? options.allowPrototypes : defaults.allowPrototypes,
        arrayLimit : "number" === typeof options.arrayLimit ? options.arrayLimit : defaults.arrayLimit,
        charset : charset,
        charsetSentinel : "boolean" === typeof options.charsetSentinel ? options.charsetSentinel : defaults.charsetSentinel,
        comma : "boolean" === typeof options.comma ? options.comma : defaults.comma,
        decoder : "function" === typeof options.decoder ? options.decoder : defaults.decoder,
        delimiter : "string" === typeof options.delimiter || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter,
        depth : "number" === typeof options.depth || false === options.depth ? +options.depth : defaults.depth,
        ignoreQueryPrefix : true === options.ignoreQueryPrefix,
        interpretNumericEntities : "boolean" === typeof options.interpretNumericEntities ? options.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit : "number" === typeof options.parameterLimit ? options.parameterLimit : defaults.parameterLimit,
        parseArrays : false !== options.parseArrays,
        plainObjects : "boolean" === typeof options.plainObjects ? options.plainObjects : defaults.plainObjects,
        strictNullHandling : "boolean" === typeof options.strictNullHandling ? options.strictNullHandling : defaults.strictNullHandling
      };
    }(o);
    if ("" === value || null === value || "undefined" === typeof value) {
      return options.plainObjects ? Object.create(null) : {};
    }
    var group = "string" === typeof value ? function(string, options) {
      var i;
      var target = {};
      /** @type {string} */
      var path = options.ignoreQueryPrefix ? string.replace(/^\?/, "") : string;
      var opts = options.parameterLimit === 1 / 0 ? void 0 : options.parameterLimit;
      /** @type {!Array<string>} */
      var args = path.split(options.delimiter, opts);
      /** @type {number} */
      var label_col = -1;
      var context = options.charset;
      if (options.charsetSentinel) {
        /** @type {number} */
        i = 0;
        for (; i < args.length; ++i) {
          if (0 === args[i].indexOf("utf8=")) {
            if ("utf8=%E2%9C%93" === args[i]) {
              /** @type {string} */
              context = "utf-8";
            } else {
              if ("utf8=%26%2310003%3B" === args[i]) {
                /** @type {string} */
                context = "iso-8859-1";
              }
            }
            /** @type {number} */
            label_col = i;
            /** @type {number} */
            i = args.length;
          }
        }
      }
      /** @type {number} */
      i = 0;
      for (; i < args.length; ++i) {
        if (i !== label_col) {
          var name;
          var value;
          /** @type {string} */
          var key = args[i];
          /** @type {number} */
          var y = key.indexOf("]=");
          /** @type {number} */
          var pos = -1 === y ? key.indexOf("=") : y + 1;
          if (-1 === pos) {
            name = options.decoder(key, defaults.decoder, context, "key");
            /** @type {(null|string)} */
            value = options.strictNullHandling ? null : "";
          } else {
            name = options.decoder(key.slice(0, pos), defaults.decoder, context, "key");
            value = options.decoder(key.slice(pos + 1), defaults.decoder, context, "value");
          }
          if (value && options.interpretNumericEntities && "iso-8859-1" === context) {
            value = callback(value);
          }
          if (value && "string" === typeof value && options.comma && value.indexOf(",") > -1) {
            /** @type {!Array<string>} */
            value = value.split(",");
          }
          if (key.indexOf("[]=") > -1) {
            value = isArray(value) ? [value] : value;
          }
          if (has.call(target, name)) {
            target[name] = utils.combine(target[name], value);
          } else {
            target[name] = value;
          }
        }
      }
      return target;
    }(value, options) : value;
    /** @type {!Object} */
    var result = options.plainObjects ? Object.create(null) : {};
    /** @type {!Array<string>} */
    var p = Object.keys(group);
    /** @type {number} */
    var i = 0;
    for (; i < p.length; ++i) {
      /** @type {string} */
      var key = p[i];
      var path = set(key, group[key], options);
      result = utils.merge(result, path, options);
    }
    return utils.compact(result);
  };
}]]);
